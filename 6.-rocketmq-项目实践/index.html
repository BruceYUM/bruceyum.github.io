<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>RocketMQ 项目实践 - 三此君的博客</title><meta name=description content="程序员自我救赎之路：编程知识、职场经验、程序人生、个人管理……"><meta property="og:title" content="RocketMQ 项目实践"><meta property="og:description" content="前 言 大家好，我是三此君，一个在自我救赎之路上的非典型程序员。 “一张图”系列旨在通过“一张图”系统性的解析一个板块的知识点： 三此君向来不喜欢零"><meta property="og:type" content="article"><meta property="og:url" content="https://sancijun.github.io/6.-rocketmq-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"><meta property="og:image" content="https://sancijun.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-10T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-10T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sancijun.github.io/logo.png"><meta name=twitter:title content="RocketMQ 项目实践"><meta name=twitter:description content="前 言 大家好，我是三此君，一个在自我救赎之路上的非典型程序员。 “一张图”系列旨在通过“一张图”系统性的解析一个板块的知识点： 三此君向来不喜欢零"><meta name=application-name content="三此君"><meta name=apple-mobile-web-app-title content="三此君"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://sancijun.github.io/6.-rocketmq-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/><link rel=next href=https://sancijun.github.io/5.rocketmq-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/><link rel=stylesheet href=/css/page.min.css><link rel=stylesheet href=/css/home.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"RocketMQ 项目实践","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/sancijun.github.io\/6.-rocketmq-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5\/"},"image":["https:\/\/cdn.jsdelivr.net\/gh\/sancijun\/images\/pics\/avatar.webp"],"genre":"posts","keywords":"RocketMQ, MQ, 消息队列, 消息中间件, kafka, 项目实践, 消息中心, 重试, 幂等, 消息堆积","wordcount":6206,"url":"https:\/\/sancijun.github.io\/6.-rocketmq-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5\/","datePublished":"2022-03-10T00:00:00+00:00","dateModified":"2022-03-10T00:00:00+00:00","license":"TODO: This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"三此君","logo":"https:\/\/cdn.jsdelivr.net\/gh\/sancijun\/images\/pics\/avatar.webp"},"author":{"@type":"Person","name":"三此君"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=三此君的博客><span class=header-title-pre><i class="fa fa-home"></i></span>三此君</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/categories/documentation/>文档 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=https://github.com/sancijun title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=# class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a class=menu-item href=/index.xml title=RSS><i class="fas fa-rss fa-fw" title=RSS></i> </a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=三此君的博客><span class=header-title-pre><i class="fa fa-home"></i></span>三此君</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=# class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=# class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/categories/documentation/ title>文档</a><a class=menu-item href=/about/ title>关于</a><a class=menu-item href=https://github.com/sancijun title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><div class=menu-item><a href=/index.xml title=RSS><i class="fas fa-rss fa-fw" title=RSS></i></a>
<span>&nbsp;|&nbsp;</span><a href=javascript:void(0); class=theme-switch title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single" data-toc=enable><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/1651996418678rocketmq-banner.png data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/1651996418678rocketmq-banner.png, https://cdn.jsdelivr.net/gh/sancijun/images/pics/1651996418678rocketmq-banner.png 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/1651996418678rocketmq-banner.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/1651996418678rocketmq-banner.png title=https://cdn.jsdelivr.net/gh/sancijun/images/pics/1651996418678rocketmq-banner.png></div><div class=single-card data-image=true><h2 class="single-title animated flipInX">RocketMQ 项目实践</h2><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>三此君</a></span>&nbsp;<span class=post-category>出版于 <a href=/categories/rocketmq/><i class="far fa-folder fa-fw"></i>RocketMQ</a></span></div><div class=post-meta-line><span><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-03-10>2022-03-10</time></span>&nbsp;<span><i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 6206 字</span>&nbsp;
<span><i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 13 分钟</span>&nbsp;</div></div><hr><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#前----言>前 言</a></li><li><a href=#项目概述>项目概述</a><ul><li><a href=#1整体架构>1、整体架构</a></li><li><a href=#2整体流程>2、整体流程</a></li></ul></li><li><a href=#项目部署>项目部署</a><ul><li><a href=#1获取源码>1、获取源码</a></li><li><a href=#2安装-docker-及-docker-compose>2、安装 Docker 及 docker-compose</a></li><li><a href=#3安装中间件>3、安装中间件</a></li><li><a href=#4启动-austin-web>4、启动 austin-web</a></li><li><a href=#5启动-austin-admin>5、启动 austin-admin</a></li><li><a href=#6验证>6、验证</a></li></ul></li><li><a href=#通用幂等>通用幂等</a><ul><li><a href=#1存在问题>1、存在问题</a></li><li><a href=#2mysql-排重表>2、MySQL 排重表</a></li><li><a href=#3redis-记录消息状态>3、Redis 记录消息状态</a></li><li><a href=#4幂等实现>4、幂等实现</a></li></ul></li><li><a href=#消息堆积>消息堆积</a><ul><li><a href=#1背景>1、背景</a></li><li><a href=#2消息堆积原因>2、消息堆积原因</a></li><li><a href=#3消息堆积解决方案>3、消息堆积解决方案</a><ul><li><a href=#避免消息堆积和延迟事前>避免消息堆积和延迟（事前）</a></li><li><a href=#队列及消费者实例扩容事中>队列及消费者实例扩容（事中）</a></li><li><a href=#线上排查消费耗时事中>线上排查消费耗时（事中）</a></li></ul></li></ul></li><li><a href=#消息堆积-1>消息堆积</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></div><div class=content id=content><h2 id=前----言>前 言</h2><p>大家好，我是三此君，一个在自我救赎之路上的非典型程序员。</p><p>“一张图”系列旨在通过“一张图”系统性的解析一个板块的知识点：</p><ul><li>三此君向来不喜欢零零散散的知识点，通过一张图将零散的知识点连接起来，能够让我们对一个板块有更深入、更系统的理解。</li><li>同时本系列尽可能的精炼，希望能够让大家花 20% 的时间，快速理解这个板块下 80% 的内容。</li></ul><p>本文是“一张图”系列的第一个板块：一张图解析 RocketMQ。</p><ul><li>为了叙述的方便，绘图的时候将整个系列分为许多小的模块，讲解的时候也是按照模块循序渐进的。<a href=https://sm.ms/image/vPtlGbaqHhJ9Tcg target=_blank rel="noopener noreffer">一张图解析 RocketMQ 原图</a></li><li>一张图解析 RocketMQ 是会深入到源码层面，但是文中不会粘贴源码。三此君在看源码的时候写了很多备注，可以降低大家看源码的难度，需要的同学自行到三此君的仓库中 Fork：<a href=https://github.com/sancijun/rocketmq/tree/release-4.3.0 target=_blank rel="noopener noreffer">rocketmq release-4.3.0</a></li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508151240.jpeg data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508151240.jpeg, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508151240.jpeg 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508151240.jpeg 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508151240.jpeg title="一张图进阶 RocketMQ"></p><p>三此君经常会遇见这样的问题，理论学完觉得啥都会了，实践的时候又觉得啥都不会了。今天，我们通过一个真实的项目来看看 RocketMQ 在生产实践中如何使用，以及使用过程中会遇到什么问题，这些问题又如何解决？</p><p>消息队列在生产实践中是很常见的中间件，甚至很多团队不管三七二十一，适不适用都往消息队列里面扔。我们也无法穷尽消息队列的所有场景及问题，所以本文只是通过一个简单的项目，演示 RocketMQ 的应用及问题。</p><h2 id=项目概述>项目概述</h2><p>今天分享的项目几乎是每个应用都会有的模块，每个人都用过，甚至会让有些人产生“恐惧”。这个项目就是消息中心，也就是给大家发消息的，如果还觉得不熟悉的话我提醒下你，你的应用是不是有个红点（有的还有数字），你是不是经常收到 Xxx 应用给你发送的短信/邮件？这些就是消息中心要做的事儿，给大家发消息。</p><p>消息中心的业务逻辑很简单，就是根据各个业务放的需求，按照模块，给用户发送消息。而消息可能是短信、邮件、站内信、推送通知（屏幕下滑出现的消息）、微信推送等各种渠道的消息，消息的类型也可以氛围营销、账号、验证码等。</p><p>首先是一些声明：本项目是<code>三此君</code>根据 <code>Java3y</code> 的 <code>austin</code> 项目修改而来，用于演示 RocketMQ 项目实践及问题，主要修改点如下：</p><blockquote><ol><li>kafka 替换为 RocketMQ。</li><li>为了展示 RocketMQ 项目实践及问题，尽量减少依赖项，故去掉 Apollo/xxl-job/graylog 等依赖。</li><li>简化部署，更改 docker 模块，只需要一个命令即可部署好所有依赖的中间件。</li><li>简化部署，austin/austin-admin 合并。</li><li>去掉原有的业务上的去重逻辑，新增 <code>通用幂等/重试</code> 实现。</li><li>消费堆积处理</li></ol></blockquote><h3 id=1整体架构>1、整体架构</h3><p>我们先来看看消息通知的整体架构。这里只体现一些和消息中心自身强相关的组件或服务，要应用与实际生产环境中，肯定还有注册中心，监控告警，链路追踪等一系列微服务基础设施。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153823.png data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153823.png, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153823.png 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153823.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153823.png title=整体架构></p><h3 id=2整体流程>2、整体流程</h3><p>业务方 <code>business service</code> 调用 austin 消息发送接口（指定消息模板 ID 及接受者等参数），austin 调用 RocketMQ Producer API 将消息发送到 RocketMQ Broker。消费者消费消息并生成消息发送 Task 放入线程池中。线程被调度执行，不同渠道的消息使用不同的 Handler，Handler 调用三方服务发送消息。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153850.png data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153850.png, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153850.png 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153850.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153850.png title=整体流程></p><p>项目的具体实现细节三此君就不在此赘述了，大家可以获取源码，根据上面的流程图看就行。如果对实现有任何问题可以留言或者加三此君微信私聊。</p><h2 id=项目部署>项目部署</h2><h3 id=1获取源码>1、获取源码</h3><ul><li>GitHub：https://github.com/sancijun/austin.git</li><li>Gitee：</li></ul><h3 id=2安装-docker-及-docker-compose>2、安装 Docker 及 docker-compose</h3><ul><li><a href=https://www.runoob.com/docker/windows-docker-install.html target=_blank rel="noopener noreffer">Windows 安装 Docker</a></li><li><a href=https://www.runoob.com/docker/macos-docker-install.html target=_blank rel="noopener noreffer">MacOS 安装 Docker</a></li></ul><h3 id=3安装中间件>3、安装中间件</h3><p>进入项目 docker 目录，执行 docker-compose up -d，等待镜像下载，容器启动。你获取不了解 Docker 及 docker-compose，但是并不影响，我们只是方便大家部署，部署好之正常使用就行。启动之后可在 docker dashboard 查看相关容器：
<img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153925.png data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153925.png, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153925.png 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153925.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153925.png title=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153925.png></p><ul><li>mysql: 127.0.0.1:13306 username: root password:（空）</li><li>redis: 127.0.0.1：:6379 username: （空） password:（空）</li><li>rocketmq-broker: 127.0.0.1:10909</li><li>rocketmq-namesrv: 127.0.0.1:9876</li><li>rocketmq-console: 127.0.0.1:8081 （访问 127.0.0.1:8081 即可查看 RocketMQ 控制台）</li></ul><h3 id=4启动-austin-web>4、启动 austin-web</h3><p>修改 austin-web/src/main/resources/application.properties 配置，打包启动即可。</p><p>需要特别说明的是，SMS、WeChat 渠道的接入会比较麻烦，只是为了加深对 RocketMQ 的理解的话，可以只接入 Email。接入 Email 的方式很简单，以 QQ 邮箱为例：进入 QQ 邮箱->点击设置->账号->开启 POP3/SMTP 服务->生成 Token；</p><p>替换 application.properties 中邮箱相关配置 <code>account.emailAccount</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>account.emailAccount = [{&#34;email_10&#34;:{&#34;host&#34;:&#34;smtp.qq.com&#34;,&#34;port&#34;:465,&#34;user&#34;:&#34;your_email&#34;,&#34;pass&#34;:&#34;your_token&#34;,&#34;from&#34;:&#34;your_email&#34;}}]
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153945.png data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153945.png, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153945.png 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153945.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153945.png title=image-20220418224003650></p><h3 id=5启动-austin-admin>5、启动 austin-admin</h3><p>进入 austin-admin 目录，执行以下命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 安装依赖</span>
</span></span><span class=line><span class=cl>npm i
</span></span><span class=line><span class=cl><span class=c1># 打开服务</span>
</span></span><span class=line><span class=cl>npm start
</span></span></code></pre></td></tr></table></div></div><p>访问 localhost:3000
<img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153955.png data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153955.png, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153955.png 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153955.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508153955.png title=austin-admin></p><h3 id=6验证>6、验证</h3><p>可以直接在 austin-admin 上点击测试，也可以使用 postman 调用接口，查看消息是否正常发送。</p><p>到这里，我们大致了解了 austin 项目，也能够正常的收到消息了。一切都是那么顺利，但是直觉告诉三此君，《没那么简单》。我发送的消息要是没送到怎么办？是因为生产者的问题还是</p><h2 id=通用幂等>通用幂等</h2><h3 id=1存在问题>1、存在问题</h3><p>网络二将军问题的存在使得消息的发送者往往要重复发送消息，直到收到接收者的确认才认为发送成功，但这往往又会导致消息的重复发送。由于网络二将军问题的存在，RocketMQ 需要通过重试保证消息的可靠性，也因此 RocketMQ 无法避免消息重复（Exactly-Once）。消息中心是重度依赖 RocketMQ 的能力，可能出现重复发送消息等问题，因此需要实现消费幂等。</p><h3 id=2mysql-排重表>2、MySQL 排重表</h3><p><strong>业务唯一标识</strong>：可以借助关系数据库进行去重。首先需要确定消息的唯一键，根据消息中心目前实现没有合适的字段可以作为唯一标识。</p><p>1.部分接口有requestMsgId字段，是上游业务传过来的随机数，当前用于接口层面的防重。但是requestMsgId本身跟业务唯一性没有关系，并且RocketMQ消费者测试没有针对requestMsgId做处理。</p><p>2.每条消息会有 messageId，当前的实现方式是 UUID。简单的改造 messageId = SHA256(message content+telephone/uid/email/fcmToken+timestamp)，在同一时间，同一用户，相同的内容应该不会重复发送（业务唯一）。以messageId为唯一key实现排重。</p><p>3.message</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=mi>1</span><span class=p>.</span><span class=err>开始事务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>begin</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=mi>2</span><span class=p>.</span><span class=err>插入消息表（处理好主键冲突的问题）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>msg_center_tab_xxx</span><span class=w> </span><span class=k>values</span><span class=w> </span><span class=p>(</span><span class=n>messageId</span><span class=p>,</span><span class=w> </span><span class=p>...)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=mi>3</span><span class=p>.</span><span class=err>提交事务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>commit</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>实现问题：</p><p>1.消息的消费逻辑必须是依赖于关系型数据库事务。如果消费的消费过程中还涉及其他数据的修改，例如Redis这种不支持事务特性的数据源，则这些数据是不可回滚的。</p><p>2.不是通用方案：如果其他模块有需要处理幂等的地方，每个模块需要单独处理。</p><h3 id=3redis-记录消息状态>3、Redis 记录消息状态</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154752.png data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154752.png, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154752.png 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154752.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154752.png title="Redis 通用幂等流程"></p><p>1）以业务唯一标识 messageId 为 Key 从 Redis 获取消息记录状态，如果在是消费中则延迟消费，消费成功则直接返回成功。</p><p>2）如果消息记录不存在，则先将消息记录到Redis, 业务唯一标识为key，消息状态为消费中，需要加入合理的过期时间；</p><p>3）插入消息记录成功后执行原有的业务逻辑，执行失败的话删除消息表记录；</p><h3 id=4幂等实现>4、幂等实现</h3><p><strong>幂等注解</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Target</span><span class=o>({</span><span class=n>ElementType</span><span class=o>.</span><span class=na>METHOD</span><span class=o>})</span>
</span></span><span class=line><span class=cl><span class=nd>@Retention</span><span class=o>(</span><span class=n>RetentionPolicy</span><span class=o>.</span><span class=na>RUNTIME</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nd>@Documented</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=nd>@interface</span> <span class=n>Idempotent</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** 幂等 Redis  Key 前缀，用于区分业务*/</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>prefix</span><span class=o>()</span> <span class=k>default</span> <span class=s>&#34;&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** 组成幂等 Key 的参数，通过拼接前缀及参数生成幂等业务唯一key*/</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span><span class=o>[]</span> <span class=nf>params</span><span class=o>()</span> <span class=k>default</span> <span class=o>{};</span>
</span></span><span class=line><span class=cl>  	<span class=cm>/** 如果接口有多个参数，需要指定subKeys包含在哪个目标参数中 */</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>target</span><span class=o>()</span> <span class=k>default</span> <span class=s>&#34;&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>幂等切面</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Around</span><span class=o>(</span><span class=s>&#34;@annotation(com.shopee.banking.annotation.Idempotent)&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>Object</span> <span class=nf>around</span><span class=o>(</span><span class=n>ProceedingJoinPoint</span> <span class=n>joinPoint</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Throwable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Integer</span> <span class=n>status</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1.获取参数生成业务唯一标识 key，从 Redis 获取消息记录状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>String</span> <span class=n>key</span> <span class=o>=</span> <span class=n>getUniqueKey</span><span class=o>(</span><span class=n>joinPoint</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2.插入消费状态记录
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>boolean</span> <span class=n>first</span> <span class=o>=</span> <span class=n>redisTemplate</span><span class=o>.</span><span class=na>opsForValue</span><span class=o>().</span><span class=na>setIfAbsent</span><span class=o>(</span><span class=n>key</span><span class=o>,</span><span class=n>status</span><span class=o>,</span><span class=n>60</span><span class=o>*</span><span class=n>60</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>SECONDS</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 3.插入不成功：消费成功则直接返回，消费不成功则抛出异常；
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 4.执行业务代码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Object</span> <span class=n>result</span> <span class=o>=</span> <span class=n>joinPoint</span><span class=o>.</span><span class=na>proceed</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 5.设置为消费成功
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>redisTemplate</span><span class=o>.</span><span class=na>opsForValue</span><span class=o>().</span><span class=na>set</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Throwable</span> <span class=n>throwable</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 6.消费失败删除消息状态记录，等待重试
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>String</span> <span class=n>key</span> <span class=o>=</span> <span class=n>getUniqueKey</span><span class=o>(</span><span class=n>joinPoint</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>redisTemplate</span><span class=o>.</span><span class=na>delete</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>throwable</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=消息堆积>消息堆积</h2><h3 id=1背景>1、背景</h3><p>“2021-09-29 20:12，local反馈用户没有收到 Email OTP，通过监控面板发现，kafka消息堆积了约32w的消息”。原因是批量发送了大量消息，并且Email OTP 这样高优先级的消息和批量的不重要消息没有做区分。消息堆积后，重要的消息也无法正常发送。</p><p>这个问题 ID 市场已经临时处理。短期方案通过增加 kafka 分区数，增加消费者线程数处理堆积消息；长期方案将消息模板按优先级区分，高优先级和低优先级的消息通知通过topic隔离，互不影响。</p><p>目前 ID 市场就 2021-09-29 的消息堆积问题解决方案已经较为完善，但是 PH 市场 kafka 切换 RocketMQ，消息队列本身的特性不一致，如果再遇到消息堆积问题又如何处理呢？针对消息堆积还有没有其他的问题呢？同时本次事故除了消息堆积，还有个很重要的关注点是普通消息堆积，影响了重要的消息发送。</p><h3 id=2消息堆积原因>2、消息堆积原因</h3><p>消息处理流程中，如果客户端的消费速度跟不上服务端的发送速度，未处理的消息会越来越多，这部分消息就被称为堆积消息。RocketMQ DefaultPushConsumer 通过长轮询从 Broker 拉取消息，缓存到本地，再提交给业务线程。</p><p>Broker 消息堆积：主要关注下 Broker 端消息堆积的情况。Broker 端消息堆积是由于消息的生产和消费速度不匹配了，通常是由于客户端的消费能力不足。而客户端消费能力不足通常是由于受 <strong>消费耗时</strong> 和 <strong>消费并行度</strong> 影响。想要避免和解决消息堆积问题，必须合理的控制消费耗时和消息并发度，其中消费耗时的优先级高于消费并发度，必须先保证消费耗时的合理性，再考虑消费并发度问题。</p><p>客户端消息堆积：客户端堆积我们不经常遇到，<a href=https://www.jianshu.com/p/58bb1610fb8c target=_blank rel="noopener noreffer">RocketMQ 的消息堆积</a> 这篇文档记录了客户端消息堆积的内容。简单来说就是，存在1 个消费者实例负责消费 n 个 ConsumeQueue，Push 消费模式消是 RocketMQ 将消息拉倒本地放在缓存里（每次消息量大于100M会执行流控）。那么，n 个 线程同时拉取 100M 的消息缓存到本地，本地的消息就会堆积了。</p><h3 id=3消息堆积解决方案>3、消息堆积解决方案</h3><h4 id=避免消息堆积和延迟事前>避免消息堆积和延迟（事前）</h4><blockquote><p>为了避免在业务使用时出现非预期的消息堆积和延迟问题，您需要在前期设计阶段对整个业务逻辑进行完善的排查和梳理。整理出正常业务运行场景下的性能基线，才能在故障场景下迅速定位到阻塞点。其中最重要的就是梳理消息的消费耗时和消息消费的并发度。</p><ul><li><p>梳理消息的消费耗时</p><p>通过压测获取消息的消费耗时，并对耗时较高的操作的代码逻辑进行分析。查询消费耗时，请参见<a href=https://help.aliyun.com/document_detail/193952.htm#step-zbp-czw-m7t target=_blank rel="noopener noreffer">获取消息消费耗时</a>。梳理消息的消费耗时需要关注以下信息：</p><ul><li>消息消费逻辑的计算复杂度是否过高，代码是否存在无限循环和递归等缺陷。</li><li>消息消费逻辑中的I/O操作（如：外部调用、读写存储等）是否是必须的，能否用本地缓存等方案规避。</li><li>消费逻辑中的复杂耗时的操作是否可以做异步化处理，如果可以是否会造成逻辑错乱（消费完成但异步操作未完成）。</li></ul></li><li><p>设置消息的消费并发度</p><ul><li>逐步调大线程的单个节点的线程数，并观测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量。</li><li>得到单个节点的最优线程数和消息吞吐量后，根据上下游链路的流量峰值计算出需要设置的节点数，节点数=流量峰值/单线程消息吞吐量。</li></ul></li></ul></blockquote><h4 id=队列及消费者实例扩容事中>队列及消费者实例扩容（事中）</h4><p>RocketMQ 可以扩容 ComsumeQueue 及增加消费者线程数。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154850.png data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154850.png, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154850.png 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154850.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/20220508154850.png title=image-20211029115145268></p><p>但是只是扩容 ConsumeQueue 及线程数对于已经堆积的消息是没有用的，因为已经堆积的消息本身还是存储在原来的 ConsumeQueue 中。而根据 RocketMQ 消费者负载均衡策略（默认平均分配），同一个 ConsumeQueue 中的消息只会被同一个消费者组中的一个实例消费。例如：原本有4个 ConsumeQueue，扩容到 16 个ConsumeQueue，根据负载策略。原本的消息所在的 4 个ConsumeQueue 依然最多只能被 4 个消费者实例消费。短时间内堆积的消息还是无法。针对以上问题，可以考虑如下方案：</p><p>方案一：如果消息是可以被丢弃的，在 rocketmq-comsole 可以重置消费位移。</p><p>方案二：首先我们要评估在 Topic 创建的时候就设置足够的 ConsumeQueue。那么 Topic 中 MessageQueue 的数量大于 Consumer 的实例数量，可以将 Consumer 扩容，MessageQueue 会进行 Rebalance 重新分配给 Consumer 实例，此时多个 Consumer 实例可以迅速消费掉堆积的消息，但是要考虑到的后续如果业务是否能够支撑突增的并发量。</p><p>方案三：出现消息大量堆积，并且 Topic 中 MessageQueue 的数量小于 Consumer 的实例数量，也就是上面描述的问题，仅仅增加 Consumer 是无效的。可以执行步骤：</p><ol><li>消费者入口增加 comsume.accumulation.exception.swtch，默认为 false。当开关开启时，不执行具体的消费逻辑，直接将消息发回到原有的 topic。</li><li>当遇到消息严重堆积时，先执行 ConsumeQueue 动态扩容，接着执行 Consume 扩容，增加消费线程数，然后打开 comsume.accumulation.exception.swtch 开关时消息平均分配到扩容后的 ConsumeQueue 中。</li><li>当存量的消息均匀分布在扩容后的 ConsumeQueue 时关闭开关，扩容后的 Consumer 根据负载策略可以较好的消费存量消息了。</li></ol><h4 id=线上排查消费耗时事中>线上排查消费耗时（事中）</h4><p>有很多可以参考的资料，这里就不复制粘贴了。</p><p>如何处理消息堆积：https://help.aliyun.com/document_detail/193952.htm?spm=a2c4g.11186623.0.0.52cc466csEvAYq#trouble-2004065</p><p>Arthas 用户文档：https://arthas.aliyun.com/doc/</p><p>综上，消息堆积通常由于消费者耗时和消费者并行度问题。为了避免消息堆积，在编码的时候应该详细评估消费者代码性能瓶颈，优化单此消费本身耗时。如果出现消息堆积大量堆积问题，根据情况不同有三种了应急策略：直接丢弃堆积消息，扩容消费者实例，ConsumeQueue 和 Consumer 同时扩容，并且将堆积的消息平均分布到扩容后的 ConsumeQueue。在应急之后还是应该分析耗时原因，具体是代码本身耗时，关联耗时？落到根本还是要解决消费者耗时问题上。</p><h2 id=消息堆积-1>消息堆积</h2><p><strong>1. 提高消费并行度</strong></p><p>绝大部分消息消费行为都属于 IO 密集型，即可能是操作数据库，或者调用 RPC，这类消费行为的消费速度在于后端数据库或者外系统的吞吐量，通过增加消费并行度，可以提高总的消费吞吐量，但是并行度增加到一定程度，反而会下降。所以，应用必须要设置合理的并行度。 如下有几种修改消费并行度的方法：</p><ul><li>同一个 ConsumerGroup 下，通过增加 Consumer 实例数量来提高并行度（需要注意的是超过订阅队列数的 Consumer 实例无效）。可以通过加机器，或者在已有机器启动多个进程的方式。</li><li>提高单个 Consumer 的消费并行线程，通过修改参数 consumeThreadMin、consumeThreadMax 实现。</li></ul><p><strong>2. 批量方式消费</strong></p><p>某些业务流程如果支持批量方式消费，则可以很大程度上提高消费吞吐量，例如订单扣款类应用，一次处理一个订单耗时 1 s，一次处理 10 个订单可能也只耗时 2 s，这样即可大幅度提高消费的吞吐量，通过设置 consumer 的 consumeMessageBatchMaxSize 返个参数，默认是 1，即一次只消费一条消息，例如设置为 N，那么每次消费的消息数小于等于 N。</p><p><strong>3. 跳过非重要消息</strong></p><p>发生消息堆积时，如果消费速度一直追不上发送速度，如果业务对数据要求不高的话，可以选择丢弃不重要的消息。例如，当某个队列的消息数堆积到 100000 条以上，则尝试丢弃部分或全部消息，这样就可以快速追上发送消息的速度。示例代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>ConsumeConcurrentlyStatus</span> <span class=nf>consumeMessage</span><span class=o>(</span>
</span></span><span class=line><span class=cl>            <span class=n>List</span><span class=o>&lt;</span><span class=n>MessageExt</span><span class=o>&gt;</span> <span class=n>msgs</span><span class=o>,</span>
</span></span><span class=line><span class=cl>            <span class=n>ConsumeConcurrentlyContext</span> <span class=n>context</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>offset</span> <span class=o>=</span> <span class=n>msgs</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>).</span><span class=na>getQueueOffset</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>maxOffset</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=n>msgs</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>).</span><span class=na>getProperty</span><span class=o>(</span><span class=n>Message</span><span class=o>.</span><span class=na>PROPERTY_MAX_OFFSET</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>diff</span> <span class=o>=</span> <span class=n>Long</span><span class=o>.</span><span class=na>parseLong</span><span class=o>(</span><span class=n>maxOffset</span><span class=o>)</span> <span class=o>-</span> <span class=n>offset</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>diff</span> <span class=o>&gt;</span> <span class=n>100000</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// TODO 消息堆积情况的特殊处理
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=n>ConsumeConcurrentlyStatus</span><span class=o>.</span><span class=na>CONSUME_SUCCESS</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// TODO 正常消费过程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>ConsumeConcurrentlyStatus</span><span class=o>.</span><span class=na>CONSUME_SUCCESS</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>    
</span></span></code></pre></td></tr></table></div></div><p><strong>4. 优化每条消息消费过程</strong></p><p>举例如下，某条消息的消费过程如下：</p><ul><li>根据消息从 DB 查询【数据 1】</li><li>根据消息从 DB 查询【数据 2】</li><li>复杂的业务计算</li><li>向 DB 插入【数据 3】</li><li>向 DB 插入【数据 4】</li></ul><p>这条消息的消费过程中有 4 次与 DB 的 交互，如果按照每次 5ms 计算，那么总共耗时 20ms，假设业务计算耗时 5ms，那么总过耗时 25ms，所以如果能把 4 次 DB 交互优化为 2 次，那么总耗时就可以优化到 15ms，即总体性能提高了 40%。所以应用如果对时延敏感的话，可以把 DB 部署在 SSD 硬盘，相比于 SCSI 磁盘，前者的 RT 会小很多。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/sancijun/images/pics/qrcode_banner.webp data-srcset="https://cdn.jsdelivr.net/gh/sancijun/images/pics/qrcode_banner.webp, https://cdn.jsdelivr.net/gh/sancijun/images/pics/qrcode_banner.webp 1.5x, https://cdn.jsdelivr.net/gh/sancijun/images/pics/qrcode_banner.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/sancijun/images/pics/qrcode_banner.webp title=https://cdn.jsdelivr.net/gh/sancijun/images/pics/qrcode_banner.webp></p><h2 id=参考文献>参考文献</h2><ul><li><p><a href=https://github.com/apache/rocketmq/tree/master/docs/cn target=_blank rel="noopener noreffer">RocketMQ 官方文档</a></p></li><li><p>丁威, 周继锋. RocketMQ技术内幕：RocketMQ架构设计与实现原理. 机械工业出版社, 2019-01.</p></li><li><p>李伟. RocketMQ分布式消息中间件：核心原理与最佳实践. 电子工业出版社, 2020-08.</p></li><li><p>杨开元. RocketMQ实战与原理解析. 机械工业出版社, 2018-06.</p></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-tag><span><a href=/tags/rocketmq/>RocketMQ</a>
</span><span><a href=/tags/mq/>MQ</a>
</span><span><a href=/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/>消息队列</a>
</span><span><a href=/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/>消息中间件</a>
</span><span><a href=/tags/kafka/>kafka</a>
</span><span><a href=/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/>项目实践</a>
</span><span><a href=/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83/>消息中心</a>
</span><span><a href=/tags/%E9%87%8D%E8%AF%95/>重试</a>
</span><span><a href=/tags/%E5%B9%82%E7%AD%89/>幂等</a>
</span><span><a href=/tags/%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF/>消息堆积</a></span></div><div class=post-info-line><div class=post-info-mod><span>更新于 2022-03-10</span></div><div class=post-info-mod><span><a class=link-to-markdown href=/6.-rocketmq-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/index.md target=_blank>阅读原始文档</a>
</span><span>&nbsp;|&nbsp;
<a class=link-to-markdown href=https://github.com/sancijunposts/%e4%b8%ad%e9%97%b4%e4%bb%b6/RocketMQ/6.%20RocketMQ%20%e9%a1%b9%e7%9b%ae%e5%ae%9e%e8%b7%b5.md target=_blank>Improve Article</a></span></div></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://sancijun.github.io/6.-rocketmq-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/ data-title="RocketMQ 项目实践" data-image=https://cdn.jsdelivr.net/gh/sancijun/images/pics/1651996418678rocketmq-banner.png data-ralateuid=u/5649725064><i class="fab fa-weibo fa-fw"></i></a></span></div></div><div class=post-nav><a href=/5.rocketmq-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/ class=next rel=next title="RocketMQ 事务消息">Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div></div><div id=comments class=single-card><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/>三此君</a></span>&nbsp;|&nbsp;<span class=license><p>本作品采用<a href=http://creativecommons.org/licenses/by-nc-nd/4.0/ style=color:#a9a9a9>《知识共享署名-非商业性使用-禁止演绎 4.0 国际》</a>许可协议进行许可</p></span></div></div><script>"serviceWorker"in navigator&&(navigator.serviceWorker.register("/sw.min.js?version=1.0.1",{scope:"/"}).then(()=>{console.info("三此君的博客\u00A0Service Worker Registered")},e=>console.error("三此君的博客\u00A0Service Worker registration failed: ",e)),navigator.serviceWorker.ready.then(()=>{console.info("三此君的博客\u00A0Service Worker Ready")}))</script></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-chevron-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment-alt fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.0/dist/autocomplete.min.js></script><script src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script src=/lib/lunr/lunr.stemmer.support.min.js></script><script src=/lib/lunr/lunr.zh.min.js></script><script src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js></script><script src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.1/sharer.min.js></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"",lightTheme:"github-light",repo:"sancijun/sancijun.github.io"}},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script src=/js/theme.min.js></script></body></html>