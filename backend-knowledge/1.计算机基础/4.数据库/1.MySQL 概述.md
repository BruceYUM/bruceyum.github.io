# 概述

[toc]


## MySQL 概述

### 1、MySQL 架构简介

InnoDB 后台线程

- Master Thread：核心线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等。
- IO Thread：在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。
- Purge Thread：事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。在InnoDB 1.1版本之前，purge操作仅在InnoDB存储引擎的Master Thread中完成。而从InnoDB 1.1版本开始，purge操作可以独立到单独的线程中进行，以此来减轻Master Thread的工作，从而提高CPU的使用率以及提升存储引擎的性能。
- Page clear thread：Page Cleaner Thread是在InnoDB 1.2.x版本中引入的。其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。

### 2、MySQL 查询流程

从图中我们可以看出，服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是 连接管理 、 解析与优化 、 存储引擎 。

![MySQL_query](https://gitee.com/bruceyum/pictures/raw/master/pics/MySQL_query.jpg)

**1.连接管理**

客户端进程可以采用我们上边介绍的 TCP/IP 、 命名管道或共享内存 、 Unix域套接字 这几种方式之一来与服务器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。从这一点大家也能看出， MySQL 服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量，至于怎么限制我们后边再说哈～

在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了 SSL （安全套接字）的网络连接进行通信，来保证数据传输的安全性。

当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求， MySQL 服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理。

**2.解析与优化**

到现在为止， MySQL 服务器已经获得了文本形式的请求，接着 还要经过九九八十一难的处理，其中的几个比较重要的部分分别是 查询缓存 、 语法解析 和 查询优化 ，下边我们详细来看。

**3.查询缓存**

 MySQL 服务器会把刚刚处理过的查询请求和结果 缓存 起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。

当然， MySQL 服务器并没有人聪明，如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW ，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！

不过既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了 INSERT 、  UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或  DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从**高速缓存中删除**！

> 小贴士： 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。

**4.语法解析**

如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。因为客户端程序发送过来的请求只是一段文本而已，所以 MySQL 服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到 MySQL 服务器内部使用的一些数据结构上来。

> 小贴士： 这个从指定的文本中提取出我们需要的信息本质上算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段，这些问题不属于我们讨论的范畴，大家只要了解在处理请求的过程中需要这个步骤就好了。

**5.查询优化**

语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的 MySQL 语句执行起来效率可能并不是很高， MySQL 的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接吧啦吧啦的一堆东西。MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用 EXPLAIN 语句来查看某个语句的执行计划，关于查询优化这部分的详细内容我们后边会仔细唠叨，现在你只需要知道在 MySQL 服务器程序处理请求的过程中有这么一个步骤就好了。

**6.存储引擎**

截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表， MySQL 服务器把数据的存储和提取操作都封装到了一个叫 存储引擎 的模块里。我们知道 表 是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是 存储引擎 负责的事情。为了实现不同的功能， MySQL 提供了各式各样的 存储引擎 ，不同 存储引擎 管理的表具体的存储结构可能不同，采用的存取算法也可能不同。

> 小贴士： 为什么叫 引擎 呢？因为这个名字更拉风～ 其实这个存储引擎以前叫做 表处理器 ，后来可能人们觉得太土，就改成了 存储引擎 的叫法，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。

为了管理方便，人们把 连接管理 、 查询缓存 、 语法解析 、 查询优化 这些并不涉及真实数据存储的功能划分为 MySQL server 的功能，把真实存取数据的功能划分为 存储引擎 的功能。各种不同的存储引擎向上边的 MySQL server 层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像"读取索引第一条内容"、"读取索引下一条内容"、"插入记录"等等。

所以在 MySQL server 完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。

回头总结一下MySQL整个查询执行过程，总的来说分为6个步骤：

- 客户端向MySQL服务器发送一条查询请求
- 服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
- 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划
- MySQL根据执行计划，调用存储引擎的API来执行查询
- 将结果返回给客户端，同时缓存查询结果

### 3、MySQL 更新流程

MySQL更新语句的执行过程是包含查询语句的执行过程的，因为你要更新一条记录，首先都查询到这条记录，然后才能基于查询出来的数据再做更新的操作。


![sql_update_flow](https://gitee.com/bruceyum/pictures/raw/master/pics/sql_update_flow.png)

简单根据上图的流程，描述一下更新语句的执行过程。

1. 客户端发起连接MySQL服务的请求。连接器接受客户端的请求，验证其账号密码信息是否正确。如果正确运行登录MySQL数据库，不正确拒绝登录，并返回错误信息。

2. 如果开启了MySQL的查询缓存的功能，会先根据查询的SQL语句去查询缓存中查看是否有这样的SQL对应的缓存结果。

3. - 如果发现缓存结果，则直接基于缓存的结果进行更新语句的操作，进入下面的第7步。
   - 如果没有缓存结果，则跳出查询缓存模块，走向解析器模块。

4. 解析器解析SQL语句是否正确，语法词法是对。

5. - 如果词法或者语法有问题，则返回错误信息给客户端。
   - 如果词法语句正确，则继续往后面的组件“预处理器”中走。

6. 预处理器会根据验证后SQL语句生成语法树。

7. 查询优化器根据预处理生成的语法树，基于规则及成本优化，生成一个最优的执行计划。

8. 执行器根据优化器提供的执行计划去执行调用存储引擎层的接口执行SQL语句。

9. 存储引擎层接受到执行器的请求后，**去查询缓存（Buffer Pool）中去查询是否有对应的数据（图中1.x）**。

10. - 如果有对应的数据则直接返回给Server层的执行器。
    - 如果没有对应要查询的数据，则根据对应的执行计划去决定如何去磁盘中扫描对应要查询的数据。这里查询的时候，可能使用到索引，也可能不使用索引，具体就看执行计划是怎么样的。
    - 这里的查询缓存并不是Server层的查询缓存，而是存储引擎内部的查询缓存（Buffer Pool）。它是由每一个存储引擎自己来实现的。

11. 图中少画了一步，获取到待修改的数据后，将旧的**数据记录到 undolog** 中，便于事务回滚。

12. 执行器接受存储引擎层的结果，进行更新语句的操作，然后把更新后的数据，发送给存储引擎层（图中3.x）。

13. 存储引擎层接收到执行器发送过来的更新数据后，做了如下几个动作

14. - 首选去**更新缓存（Buffer Pool）中的数据**，避免后续有再次查询此次被修改的数据的时候，从缓存中返回给执行器的数据是旧的数据。这里其实是吧更新记录到 Change Buffer 中，会有相应的机制将更新记录合并，并最终更新到磁盘上（图中4）。
    - 在**日志缓存中记录 redolog**，并且把 redolog 的状态标记为待提交 prepare 状态（图中5）。
    - 返回消息给执行器，告知上面的操作已经完成。

15. 执行器在收到存储引擎层的更新消息后，做了如下几个动作（图中7、8）

16. - 在 **binlog 日志中记录此次的修改语句**，便于以后通过 binlog 恢复数据的时候，不丢失此次修改操作。
    - 发送消息给存储引擎层，告诉它可以把 **redolog 的状态由 prepare 改为 commit 状态**。

17. 存储引擎层接收到执行器的消息后，做了如下几个动作（图中9）

18. - **更新日志缓存中的 redolog 的状态为 commit 状态**。
    - 发送消息通知执行器，redolog 已经提交。

19. 执行器接收到存储引擎层的消息后，通知客户端，更新成功。至此，整个更新语句就执行完成了。

从上面的流程我们可以看到redo log的写入分为两步：prepare、commit，这就是所谓的**两阶段提交**。而且两阶段提交一定是成功的写入了两个日志文件：redo log & binlog，只有这样事务才能提交，数据才能满足一致性原则。


### 3、MySQL 存储引擎

**1. InnoDB**

是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

**2. MyISAM**

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

**3. 比较**

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。

- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。

- 外键：InnoDB 支持外键。

- 备份：InnoDB 支持在线热备份。

- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。

- 其它特性：MyISAM 支持压缩表和空间数据索引。

### 4、MySQL 数据储存

页（页目录，页内记录之间单向链表）-> 页与页之间双向链表； 
主键查询：遍历双向链表定位页，页内通过页记录二分查找； 
非主键查询：遍历双向链表定位页，页内仍需遍历记录单链表； 

Mysql的基本存储结构是页(记录都存在页里边)，各个数据页可以组成一个双向链表

而每个数据页中的记录又可以组成一个单向链表

![img](http://cdn.processon.com/605a0b0cf346fb6d9edbdc01)

![img](http://cdn.processon.com/605a0b25e401fd4c0391907d)

每个数据页都会为存储在它里面的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录

如果我们写select * from user where username = 'Java3y'这样没有进行任何优化的sql语句，默认会这样做：

1）定位到记录所在的页：需要遍历双向链表，找到所在的页...

2）从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了

### 5、MySQL 安装配置

下载地址：https://dev.mysql.com/downloads/mysql/

MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。MariaDB完全兼容 MySQL，使用方法也是一样的


**1. 安装**

有的 CentOS 7 已经默认安装了 Mariadb，可以查看自己的有没有安装，没有安装的再进行安装，已经安装了可以不用安装也可以卸载了重装。卸载命令 yum remove mariadb-server
安装命令：

[root@centos02 ~]# yum install mariadb-server

**2. 配置MariaDB**

1）安装完成后首先要把MariaDB服务开启，并设置为开机启动

[root@centos02 ~]# systemctl start mariadb  # 开启服务 
[root@centos02 ~]# systemctl enable mariadb  # 设置为开机自启动服务... 

检查当前系统是否安装过MariaDB

可以用 rpm -qa|grep MariaDB 查看当前的系统进程，如果有 MariaDB 服务就会显示的。


**3. 修改字符集**

设置 MariaDB 字符集为 utf-8

- /etc/my.cnf：在  [mysqld]  标签下添加

- /etc/my.cnf.d/client.cnf：在  [client]  标签下添加

- /etc/my.cnf.d/mysql-clients.cnf  文件...


**4. MySQL 的安装位置**

|             路径             |           解释            |           备注           |
| :--------------------------: | :-----------------------: | :----------------------: |
|        /var/lib/mysql        | mysql数据库文件的存放路径 | eg: /var/lib/mysql/mysql |
| /ect/my.conf;/ect/my.conf.d; |       配置文件目录        |        eg:my.conf        |
|           /usr/bin           |       相关命令目录        |      eg: mysqladmin      |


**5. MySQL 配置文件**   

windows：my.ini文件

Linux：/etc/my.cnf文件

二进制日志 log-bin：主重复制

错误日志 log-error：默认是关闭的,记录严重的警告和错误信息,每次启动和关闭的详细信息等.

查询日志 log：默认关闭,记录查询的sql语句，如果开启会减低mysql的整体性能，因为记录日志也是需要消耗系统资源的

**6. MySQL 数据文件**

windows：D:\ProgramFiles\MySQL\MySQLServer5.5\data目录下可以挑选很多库

linux：默认路径：/var/lib/mysql

frm文件：存放表结构

myd文件：存放表数据

myi文件：存放表索引

## 范式

### 1、函数依赖

记 A-\>B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 A-\>B，如果能找到 A 的真子集 A'，使得 A'-\> B，那么 A-\>B 就是部分函数依赖，否则就是完全函数依赖。

对于 A-\>B，B-\>C，则 A-\>C 是一个传递函数依赖。

### 2、范式

范式理论是为了解决以上提到四种异常。

高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。

**1. 第一范式 (1NF)**

属性不可分。

**2. 第二范式 (2NF)**

每个非主属性完全函数依赖于键码。

可以通过分解来满足。

**分解前**

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| :--: | :----: | :----: | :----: | :----: | :---: |
|  1   | 学生-1 | 学院-1 | 院长-1 | 课程-1 |  90   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-2 |  80   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-1 |  100  |
|  3   | 学生-3 | 学院-2 | 院长-2 | 课程-2 |  95   |

以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：

- Sno -\> Sname, Sdept
- Sdept -\> Mname
- Sno, Cname-\> Grade

Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。

Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

**分解后**

关系-1

| Sno  | Sname  | Sdept  | Mname  |
| :--: | :----: | :----: | :----: |
|  1   | 学生-1 | 学院-1 | 院长-1 |
|  2   | 学生-2 | 学院-2 | 院长-2 |
|  3   | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖：

- Sno -\> Sname, Sdept
- Sdept -\> Mname

关系-2

| Sno  | Cname  | Grade |
| :--: | :----: | :---: |
|  1   | 课程-1 |  90   |
|  2   | 课程-2 |  80   |
|  2   | 课程-1 |  100  |
|  3   | 课程-2 |  95   |

有以下函数依赖：

- Sno, Cname -\>  Grade

**3. 第三范式 (3NF)**

非主属性不传递函数依赖于键码。

上面的 关系-1 中存在以下传递函数依赖：

- Sno -\> Sdept -\> Mname

可以进行以下分解：

关系-11

| Sno  | Sname  | Sdept  |
| :--: | :----: | :----: |
|  1   | 学生-1 | 学院-1 |
|  2   | 学生-2 | 学院-2 |
|  3   | 学生-3 | 学院-2 |

关系-12

| Sdept  | Mname  |
| :----: | :----: |
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |

### 3、异常

以下的学生课程关系的函数依赖为 {Sno, Cname} -\> {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| :--: | :----: | :----: | :----: | :----: | :---: |
|  1   | 学生-1 | 学院-1 | 院长-1 | 课程-1 |  90   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-2 |  80   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-1 |  100  |
|  3   | 学生-3 | 学院-2 | 院长-2 | 课程-2 |  95   |

不符合范式的关系，会产生很多异常，主要有以下四种异常：

- 冗余数据：例如  学生-2  出现了两次。
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了  课程-1  需要删除第一行和第三行，那么  学生-1  的信息就会丢失。
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

## ER 图

Entity-Relationship，有三个组成部分：实体、属性、联系。

用来进行关系型数据库系统的概念设计。

### 1、实体的三种联系

包含一对一，一对多，多对多三种。

- 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；
- 如果是一对一，画两个带箭头的线段；
- 如果是多对多，画两个不带箭头的线段。

下图的 Course 和 Student 是一对多的关系。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png) 

表示出现多次的关系

一个实体在联系出现几次，就要用几条线连接。

下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/ac929ea3-daca-40ec-9e95-4b2fa6678243.png) 

### 2、联系的多向性

虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/5bb1b38a-527e-4802-a385-267dadbd30ba.png) 

### 3、表示子类

用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/14389ea4-8d96-4e96-9f76-564ca3324c1e.png)


