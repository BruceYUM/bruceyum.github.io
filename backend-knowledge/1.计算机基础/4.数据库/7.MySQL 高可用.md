# MySQL高可用

[toc]


## 主从复制

### 基本原理
主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

-   **binlog 线程**  ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
-   **I/O 线程**  ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
-   **SQL 线程**  ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png)<br>

### 复制的基本原则

- 每个slave只有一个master

- 每个slave只能有一个唯一的服务器ID

- 每个master可以有多个salve

复制最大问题：延时


### 一主一从常见配置


1、主机修改my.ini配置文件


1.【必须】主服务器唯一ID：server-id =1

2.【必须】启用二进制日志：log-bin=自己本地的路径/mysqlbin

3.【可选】启动错误日志：log-err=自己本地的路径/mysqlerr，log-err=D:/devSoft/MySQLServer5.5/data/mysqlerr

4.【可选】根目录：basedir="自己本地路径"，basedir="D：/devSoft/MySQLService5.5/"

5.【可选】临时目录：tmpdir="自己的本地路劲"，tmpdir="D：/devSoft/MySQLService5.5/"

6.【可选】数据目录：datadir="自己本地路径/Data/"，datadir="D：/devSoft/MySQLService5.5/Data/"

7.read-only=0：主机，读写都可以

8.【可选】设置不要复制的数据库：binlog-lgnore-db=mysql

9.【可选】设置需要复制的数据：binlog-do-db=需要复制的主数据库名字


2、从机修改my.cnf配置文件

- 【必须】从服务器唯一ID

- 【可选】启用二进制文件


因修改过配置文件，请主机+从机都启动后台mysql服务


主机从机都关闭防火墙

windows手动关闭

关闭虚拟机linux防火墙service iptables stop


在Windows主机上简历账户并授权slave

GRANT REPLICATION SLAVE  ON*.* TO 'zhangsan'@'从机器数据库IP‘ IDENTIFIED BY '123456';
flush privileges;

查询master的状态：show master status；

记录下File和Position的值

执行完此步骤后不再执行主服务器MySQL，防止主服务器状态值变化


在Linux从机上配置需要复制的主机

CHANGE MASTER TO MASTER_HOST='主机IP',MASTER_USER='zhangsan'，MASTER_PASSWORD='123456',MASTER_LOG_FILE='File名字'，MASTER_LOG_POS=Position数字；

启动从服务器复制功能

start slave; show slave status\G

下面两个参数都是YES，则说明主从配置成功！

Slave_IO_Running:Yes

Slave_SQL_Running:Yes

主机新建库、新建表、insert记录，从机复制


如何停止从服务复制功能

stop slave;


## 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png)<br>

## 分库分表

##### **2.6.1 数据库瓶颈**

不管是 IO 瓶颈，还是 CPU 瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。在业务 Service 来看就是，可用数据库连接少甚至无连接可用。接下来就可以想象了吧（并发量、吞吐量、崩溃）。

1. IO 瓶颈 
   第一种：磁盘读 IO 瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的 IO，降低查询速度 -> 分库和垂直分表。

   第二种：网络 IO 瓶颈，请求的数据太多，网络带宽不够 -> 分库。

2. CPU 瓶颈 
   第一种：SQL 问题，如 SQL 中包含 join，group by，order by，非索引字段条件查询等，增加 CPU 运算的操作 -> SQL 优化，建立合适的索引，在业务 Service 层进行业务计算。

   第二种：单表数据量太大，查询时扫描的行太多，SQL 效率低，CPU 率先出现瓶颈 -> 水平分表。

##### **2.6.2 分库分表**

1. 水平分库
   ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaufKISYMVA6xk1p9XpneMNj8Ia5K9ibTicpLibzzT6Nyco07Tgyr5V4O1qc875OXbnbS0vFjgcurMj3Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

概念：以字段为依据，按照一定策略（hash、range 等），将一个库中的数据拆分到多个库中。结果：每个库的结构都一样；每个库的数据都不一样，没有交集；所有库的并集是全量数据；场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。分析：库多了，io 和 cpu 的压力自然可以成倍缓解。

1. 水平分表

   ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaufKISYMVA6xk1p9XpneMNjTNs8uqR60d9OGjYB4WKlIiaIQ0diaskXNoRx56sRR8fhIicqLUkRyTYiaw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

概念：以字段为依据，按照一定策略（hash、range 等），将一个表中的数据拆分到多个表中。结果：每个表的结构都一样；每个表的数据都不一样，没有交集；所有表的并集是全量数据。

场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了 SQL 效率，加重了 CPU 负担，以至于成为瓶颈。

分析：表的数据量少了，单次 SQL 执行效率高，自然减轻了 CPU 的负担。

1. 垂直分库
   ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaufKISYMVA6xk1p9XpneMNjicT4ZWCEXMnv6yNA1NTqibAHVsG10k1DiaquQrO5KDVYJ21ibtfjfibSSCA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。

结果：每个库的结构都不一样；每个库的数据也不一样，没有交集；所有库的并集是全量数据。

场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。

分析：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。

1. 垂直分表
   ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaufKISYMVA6xk1p9XpneMNjV1lXZJWVANqECRdbPFtV6HqVYx4lJDgY9dtWhiaLBpFEs1OhEQ0Z7RQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

概念：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

结果：每个表的结构都不一样；每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；所有表的并集是全量数据。

##### **2.6.3 分库分表工具**

目前市面上的分库分表中间件相对较多，其中基于代理方式的有 MySQL Proxy 和 Amoeba， 基于 Hibernate 框架的是 Hibernate Shards，基于 jdbc 的有当当 sharding-jdbc， 基于 mybatis 的类似 maven 插件式的有蘑菇街的蘑菇街 TSharding， 通过重写 spring 的 ibatis template 类的 Cobar Client。

还有一些大公司的开源产品：

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaufKISYMVA6xk1p9XpneMNjOdRiaA53bchSbSLvEraC0M1Bu3uoOdc0BAiaBTuXibSsgvrj4IKQsv2IA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### Sharding 策略

- 哈希取模：hash(key) % N；
- 范围：可以是 ID 范围也可以是时间范围；
- 映射表：使用单独的一个数据库来存储映射关系。

### Sharding 存在的问题

#### 1. 事务问题

使用分布式事务来解决，比如 XA 接口。

#### 2. 连接

可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。

#### 3. ID 唯一性

- 使用全局唯一 ID（GUID）
- 为每个分片指定一个 ID 范围
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)

