# 查询执行及优化

[toc]

MySQL Server 有一个称为 查询优化器 的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的 执行计划 ，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。

## 单表访问方法

**1、const**

通过主键或者唯一二级索引列与常数的等值比较来查询一条记录。因为只匹配一行数据，所以很快。如将主键至于where列表中，MySQL就能将该查询转换为一个常量

 const 访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个 const 访问方法才有效；唯一二级索引查询该列为 NULL 值不是 const 方法。

**2、ref**

普通的二级索引列与常数进行等值比较。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体
二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，所以 MySQL 可能选择使用索引而不是全表扫描的方式来执行查询。

不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含 NULL 值的数量并不限制，所以我们采用 key IS NULL 这种形式的搜索条件最多只能使用 ref 的访问方法，而不是 const 的访问方法。

对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用 ref 的访问方法。

**3、ref_or_null**

找出普通的二级索引列与常数进行等值比较 或者 索引列为 NULL 的记录。

```sql
SELECT * FROM single_table WHERE key1 = 'abc' OR key1 IS NULL;
```

**4、range**

利用索引进行范围匹配的访问方法称为 range，一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围扫描索引通常扫描比全表扫描要好，因为他只需要开始索引的某一点，而结束于另一点，不用扫描全部索引。

**5、index**

遍历二级索引记录的执行方式称之为： index ，这通常比 ALL 快，因为索引文件通常比数据文件小。例如：

```sql
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
```

由于 key_part2 并不是联合索引 idx_key_part 最左索引列，所以我们无法使用 ref 或者 range 访问方法来执行这个语句。但是这个查询符合下边这两个条件：

- 它的查询列表只有3个列： key_part1 ,  key_part2 ,  key_part3 ，而索引 idx_key_part 又包含这三个列，SELECT子句选取的列包含在索引中，也就是所取得数据在二级索引上可以获取，不需要回表。
- 搜索条件中只有 key_part2 列。这个列也包含在索引 idx_key_part 中。

**6、all**：全表扫描, 直接扫描聚簇索引。

## 索引合并

 MySQL 在一般情况下执行一个查询时最多只会用到单个二级索引，但不是还有特殊情况么，在这些特殊情况下也可能在一个查询中使用到多个二级索引，设计 MySQL 的大叔把这种使用到多个索引来完成一次查询的执行方法称之为： index merge 

### 1、索引及范围区间

般情况下执行一个查询只会用到单个二级索引，不过有些情况会进行索引合并。对于 B+ 树索引来说，只要索引列和常数使用 = 、 <=> 、 IN 、 NOT IN 、 IS NULL 、 IS NOT NULL 、 > 、 < 、 >= 、 <= 、 BETWEEN 、 != （不等于也可以写成 <> ）或者 LIKE 操作符连接起来，就可以产生一个所谓的 区间 。 WHERE 子句可能有很多个小的搜索条件，这些搜索条件需要使用 AND 或者 OR 操作符连接起来，AND 将多个区间取交集，OR将多个区间取并集。

所有搜索条件都可以使用某个索引的情况

```sql
SELECT * FROM single_table WHERE key2 > 100 AND key2 > 200; # 区间交集
SELECT * FROM single_table WHERE key2 > 100 OR key2 > 200;	# 区间并集
```

有的搜索条件无法使用索引的情况：没有索引的条件语句在回表的时候才使用，确定 范围区间 的时候默认为为 TRUE 就好了。

```sql
#范围区间就是：(100, +∞)
SELECT * FROM single_table WHERE key2 > 100 AND common_field = 'abc'; 
#范围区间是(-∞, +∞)，如果强制索引的话会导致扫描所有索引项，并且全部回表，比全表扫描性能更差
SELECT * FROM single_table WHERE key2 > 100 OR common_field = 'abc';
```

### 2、Intersection合并

 MySQL 在某些特定的情况下才可能会使用到 Intersection 索引合并：化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过 Intersection 索引合并后需要回表的记录数大大减少时才会使用 Intersection 索引合并。

- 情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。

  ```sql
  SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
  ```


  例如上面的SQL，可以通过单个索引确定范围区间，再回表后判断另外一个条件，也可以读取两个二级索引范围区间，合并主键后回表。虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是 顺序I/O ，而回表操作是 随机I/O ，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为 回表 而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。

- 情况二：主键列可以是范围匹配，二级索引等职匹配；

  ```sql
  SELECT * FROM single_table WHERE id > 100 AND key1 = 'a';
  ```

  之索引主键列可以范围查找，是因为主键列范围查找后得到的主键值依然是有序的，而二级索引列范围查找则主键列不是有序的。如果主键列不是有序的，那需要先对主键排序再进行交集，多了一个排序的过程。按照有序的主键值去回表取记录有个专有名词儿，叫：Rowid Ordered Retrieval，简称ROR。

### 3、Union合并

 MySQL 在某些特定的情况下才可能会使用到 Union 索引合并：优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过 Union 索引合并后进行访问的代价比全表扫描更小时才会使用 Union 索引合并。

- 情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。

  ```sql
  SELECT * FROM single_table WHERE key1 = 'a' OR ( key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c');
  ```

- 情况二：主键列可以是范围匹配，二级索引等值匹配。

- 情况三：使用 Intersection 索引合并的搜索条件：搜索条件的某些部分使用 Intersection 索引合并的方式得到的主键集合和其他方式得到的主键集合取交集

  ```sql
  SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');
  ```

### 4、Sort-Union合并

 Union 索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，Sort-Union 合并也是再多个二级索引 OR 范围查找时可能使用的索引合并方法。MySQL 先将单个索引条件范围区间获取的主键 排序，再进行合并。这种先按照二级索引记录的主键值进行排序，之后按照 Union 索引合并方式执行的方式称之为 Sort-Union 索引合并

 Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高 

注：建议使用联合索引替代 Intersection 索引合并。

## 连接的原理

### 1、嵌套循环连接

![image_1ctsr5ui2cdk1jduqafm7p1d3426、png-129、4kB](https://gitee.com/bruceyum/pictures/raw/master/pics/167e43ab3fa0f107)



- 步骤一：确定第一个需要查询的表，这个表称之为 驱动表 ，选取代价最小的那种访问方法去执行驱动表单表查询语句。

- 步骤二：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。

通过下面这个例子，看一下连接的过程：两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。

```sql
mysql> SELECT * FROM t1;
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+

mysql> SELECT * FROM t2;
+------+------+
| m2   | n2   |
+------+------+
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+

SELECT * FROM t1, t2 WHERE t1、m1 > 1 AND t1、m1 = t2、m2 AND t2、n2 < 'd';
```

![image_1ctrsprar1bbh17lee79le63ls2m.png-49、6kB](https://gitee.com/bruceyum/pictures/raw/master/pics/167e43ab3a02660b)

第一步：通过单表查询驱动表 t1，得到两条记录；

第二步：因为是根据 t1 表中的记录去找 t2 表中的记录，所以 t2 表也可以被称之为 被驱动表 。上一步骤从驱动表中得到了2条记录，所以需要查询2次 t2 表。将连接中t1于t2匹配条件换成第一步中查询出来 t1 表中相应的值，再到 t2 中进行单表查询。当 t1、m1 = 2 时，过滤条件 t1、m1 = t2、m2 就相当于 t2、m2 = 2 ，所以此时 t2 表相当于有了 t2、m2 = 2 、 t2、n2 < 'd' 这两个过滤条件，然后到 t2 表中执行单表查询。

注：可以使用索引加快连接速度，例如再 t2 表的 m2 列或者 n2 列加索引。建立了索引不一定使用索引，只有在 二级索引 + 回表 的代价比全表扫描的代价更低时才会使用索引。在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为： eq_ref 。

### 2、基于块的嵌套循环连接

如果按照“嵌套循环连接”方式执行连接，那么驱动表有多少条记录，就需要执行多少次被驱动表，如果不能使用索引，每次全盘扫描被驱动表在记录特别多的时候，磁盘性能损耗非常高。在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。

 MySQL 提出了一个 join buffer 的概念， join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 join buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 I/O 代价。

只有查询列表中的列和过滤条件中的列才会被放到 join buffer 中，所以再次提醒我们，最好不要把 * 作为查询列表。

![image_1ctuhe3t71ahd10gn19917fo1nft4g.png-57、7kB](https://gitee.com/bruceyum/pictures/raw/master/pics/167e43ab3e5fa2f6)



 MySQL 中一条查询语句的执行成本是由下边这两个方面组成的：

-  I/O 成本：我们的表经常使用的 MyISAM 、 InnoDB 存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为 I/O 成本。对于 InnoDB 存储引擎来说，页是磁盘和内存之间交互的基本单位， MySQL 规定读取一个页面花费的成本默认是 1、0 
-  CPU 成本：读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 CPU 成本。读取以及检测一条记录是否符合搜索条件的成本默认是 0.2 

 1、0 、 0.2 这些数字称之为 成本常数 。不论某个索引范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的 I/O 成本和读取一个页面是相同的。

## 查询成本计算

### 1、单表查询成本

在一条单表查询语句真正执行之前， MySQL 的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的 执行计划 ，之后才会调用存储引擎提供的接口真正的执行查询

```sql
SELECT * FROM single_table WHERE key2 > 10 AND key2 < 1000
SHOW TABLE STATUS LIKE 'single_table'\G
*************************** 1、 row ***************************
           Name: single_table
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 9693		#本选项表示表中的记录条数,是一个估算值
    Data_length: 1589248	#数据文件的大小,相当于聚簇索引占用的存储空间大小
   Index_length: 2752512
1 row in set (0.01 sec)
```

**1、找出可能的索引**

根据搜索条件，找出所有可能使用的索引，查询中可能使用到的索引称之为 possible keys 

**2、计算全表扫描的代价**

全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集。查询成本= I/O 成本+ CPU 成本，I/O 成本和数据所占页面数相关，而 CPU 成本和记录行数相关。查询成本= (页面数\*1、0 + 1、1) + (记录数\*0.2 + 1、0)

```
聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97
I/O 成本：97 x 1、0 + 1、1 = 98、1
CPU 成本：9693 x 0.2 + 1、0 = 1939、6
总成本：98、1 + 1939、6 = 2037、7
```

**3、计算使用不同索引执行查询的代价**
分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。使用 二级索引 + 回表 方式的查询，成本计算依赖两个方面的数据：范围区间数量和需要回表的记录数。

- 范围区间数量
  不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的 I/O 成本和读取一个页面是相同的。

- 需要回表的记录数

  先获取索引对应的 B+ 树的 区间最左记录 和 区间最右记录 ，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。读取二级索引记录的成本=区间记录数\*0.2 + 1（相当于用二级索引做条件判断）

- 根据这些记录里的主键值到聚簇索引中做回表操作

  MySQL 规定每次回表操作都相当于访问一个页面，回表成本=记录数*1、0。

- 回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立：记录数*0.2

```
I/O成本：1、0 + 95 x 1、0 = 96、0 (范围区间的数量 + 二级索引记录条数回表成本)
CPU成本：95 x 0.2 + 0.01 + 95 x 0.2 = 38、01 （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）
```

**4、对比各种执行方案的代价，找出成本最低的那一个**

**5、索引区间记录数统计**

**index dive**

先获取索引对应的 B+ 树的 区间最左记录 和 区间最右记录 ，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。这种通过直接访问索引对应的 B+ 树来计算某个范围区间对应的索引记录条数的方式称之为 index dive 。

首先根据搜索条件定位索引 区间最左记录 和 区间最右记录（这部分消耗忽略不计） ，如果 区间最左记录 和 区间最右记录相隔不太远（在 MySQL 5、7、21 这个版本里，只要相隔不大于10个页面即可），那就可以精确统计区间内的记录数
大于10个页面就需要沿着 区间最左记录 向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以 区间最左记录 和 区间最右记录 之间的页面数量就可以了。 区间最左记录 和 区间最右记录 之间页面数就是对应的索引内部节点目录项记录数。



![image_1cubndfil1i02ddfas1j3brq9m.png-85、3kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16998b505d7a278a)

**索引统计数据估算**

有时候使用索引执行查询时会有许多单点区间，比如使用 IN 语句就很容易产生非常多的单点区间， MySQL 的查询优化器为了计算这些单点区间对应的索引记录条数，要进行很多次 index dive 操作，这性能损耗可就大了，可能计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。

MySQL 定义了系统变量 eq_range_index_dive_limit 默认为 200, 如果我们的 IN 语句中的参数个数小于200个的话，将使用 index dive 的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话就使用的索引统计数据来进行估算。

 MySQL 也会为表中的每一个索引维护一份统计数据，可以使用 SHOW INDEX FROM 表名 查看某个表中索引的统计数据。其中 Cardinality 直译过来就是 基数 的意思，表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的 Cardinality 属性是 10000 ，那意味着该列中没有重复的值，如果 Cardinality 属性是 1 的话，就意味着该列的值全部是重复的。

```
一个值的重复次数 ≈ Rows ÷ Cardinality
单点区间总记录数 ≈ 一个值的重复次数 * 单点区间个数
```

使用统计数据来计算单点区间对应的索引记录条数可比 index dive 的方式简单多了，但是它的致命弱点就是：不精确！

### 2、连接查询成本

驱动表进行查询后得到的记录条数称之为驱动表的 扇出 （英文名： fanout ）

- 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。
- 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本

连接查询成本占大头的其实是 驱动表扇出数 x 单次访问被驱动表的成本 ，所以我们的优化重点其实是下边这两个部分：尽量减少驱动表的扇出 和 对被驱动表的访问成本尽量低。

 **join 的优化**

1. 小结果集驱动大结果集。用数据量小的表去驱动数据量大的表，这样可以减少内循环个数，也就是被驱动表的扫描次数。（MySQL会自动根据成本优化，如果是外链接并且不能转内连接的话要注意小表驱动大表）
2. 用来进行 join 的字段要加索引，会触发 INLJ 算法，如果是主键的聚簇索引，性能最优。例子：第一个子查询是 72075 条数据，join 的第二条子查询是 50w 数据，主要的优化还是驱动表是小表，后面的是大表，on 的条件加上了唯一索引。
3. 如果无法使用索引，那么注意调整 join buffer 大小，适当调大些
4. 减少不必要的字段查询（字段越少，join buffer 所缓存的数据就越多）

## 基于规则的优化

MySQL依据一些规则，将糟糕的 SQL 语句转换成某种可以比较高效执行的形式，这个过程也可以被称作 查询重写 。

1、**移除不必要的括号**

**2、常量传递**： AND 条件查询中，某个条件是常量匹配则可以将常量传递到其它匹配条件。

```sql
a = 5 AND b > a -> a = 5 AND b > 5
```

**3、移除没用的条件**：明显永远为 TRUE 或者 FALSE 的表达式，优化器会移除掉它们

表达式计算：如果表达式中只包含常量的话，它的值会被先计算出来。某个列并不是以单独的形式作为表达式的操作数时不会被查询优化器计算。

```sql
a = 5 + 1 #会被先计算出来
ABS(a) > 5 #不会提前计算出来
```

**4、HAVING子句和WHERE子句的合并**：如果查询语句中没有出现诸如 SUM 、 MAX 等等的聚集函数以及 GROUP BY 子句，优化器就把 HAVING 子句和 WHERE 子句合并起来。

**5、常量表检测**：如果表中只有一条记录或者是 const 方法查询某个表，这个表称为常量表。优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。

```sql
SELECT * FROM table1 INNER JOIN table2 ON table1、column1 = table2、column2 WHERE table1、primary_key = 1;
```

**6、外连接消除**：

外连接和内连接主要的区别就是外连接中如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；指定的 WHERE 子句中包含被驱动表中的列不为 NULL 值的条件称之为 空值拒绝 （英文名： reject-NULL ）。在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。

```sql
SELECT * FROM t1 LEFT JOIN t2 ON t1、m1 = t2、m2 WHERE t2、n2 IS NOT NULL; # 指定n2不为NULL
SELECT * FROM t1 LEFT JOIN t2 ON t1、m1 = t2、m2 WHERE t2、m2 = 2; #隐含m2不为NULL
```

## 子查询执行及优化

### 1、子查询基础

按子查询所在位置区分子查询： SELECT 子句中， FROM 子句中， WHERE 或 ON 子句中的子查询， ORDER BY / GROUP BY 子句中无意义。

按返回的结果集区分子查询：

- 标量子查询：只返回一个单一值的子查询称之为 标量子查询 
- 行子查询：返回一条记录的子查询，不过这条记录需要包含多个列
- 列子查询：列子查询就是查询出一个列的数据，不过这个列的数据需要包含多条记录
- 表子查询：子查询的结果既包含很多条记录，又包含很多个列

按与外层查询关系来区分子查询

- 不相关子查询：如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为 不相关子查询 。

- 相关子查询：如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为 相关子查询 。

EXISTS子查询：有的时候我们仅仅需要判断子查询的结果集中是否有记录，而不在乎它的记录具体是个啥，可以使用把 EXISTS 或者 NOT EXISTS 放在子查询语句前边

### 2、标量子查询/行子查询的执行方式

对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询

```sql
SELECT * FROM s1 
    WHERE key1 = (SELECT common_field FROM s2 WHERE key3 = 'a' LIMIT 1);
```

- 先单独执行 (SELECT common_field FROM s2 WHERE key3 = 'a' LIMIT 1) 这个子查询。
- 然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询 SELECT * FROM s1 WHERE key1 = ... 。

对于相关的标量子查询或者行子查询来说，例如：

```sql
SELECT * FROM s1 WHERE 
    key1 = (SELECT common_field FROM s2 WHERE s1、key3 = s2、key3 LIMIT 1);
```

- 先从外层查询中获取一条记录，本例中也就是先从 s1 表中获取一条记录。
- 然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从 s1 表中获取的那条记录中找出 s1、key3 列的值，然后执行子查询。
- 最后根据子查询的查询结果来检测外层查询 WHERE 子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。
- 再次执行第一步，获取第二条外层查询中的记录，依次类推～

### 3、IN子查询优化/半连接

**1.物化表的提出**

如果子查询的结果集中的记录条数很少，那么把子查询和外层查询分别看成两个单独的单表查询效率还是蛮高的，但是如果单独执行子查询后的结果集太多的话，可能内存放不下，多个单点区间的成本可能大于权标扫描成本，则MySQL会更倾向于权标扫描，无法很好的利用索引。所以 MySQL 不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里，该临时表的列就是子查询结果集中的列，写入临时表的记录会被去重。MySQL 把这个将子查询结果集中的记录保存到临时表的过程称之为 物化 ，把那个存储子查询结果集的临时表称之为 物化表 。

一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用 Memory 存储引擎的临时表，而且会为该表建立哈希索引。如果子查询的结果集非常大，超过了系统变量 tmp_table_size 或者 max_heap_table_size ，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为 B+ 树索引。

**2.物化表转连接**

IN 子查询相当于 原表和物化表做内连接，转化成内连接之后就有意思了，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。

```sql
SELECT * FROM s1 
    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
```

也就是说其实上边的查询就相当于表 s1 和子查询物化表 materialized_table 进行内连接：

```sql
SELECT s1、* FROM s1 INNER JOIN materialized_table ON key1 = m_val;
```

转化成内连接之后就有意思了，查询优化器可以评估不同连接顺序需要的成

**3.将子查询转换为semi-join**

通过物化表转连接的方式需要先将子查询物化然后转连接，能不能不进行物化操作直接把子查询转换为连接呢？

```sql
SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
SELECT s1、* FROM s1 INNER JOIN s2 ON s1、key1 = s2、common_field WHERE s2、key3 = 'a';
```

例如，将上面的 子查询直接转为下面的内连接？但是直接转为内连接会有一个问题，IN子查询语句语义是去重的，物化表的时候也会去重，而直接转内连接是不会去重的，所以 IN 子查询和两表连接之间并不完全等价。但是将子查询转换为连接又真的可以充分发挥优化器的作用，所以设计 MySQL 的大叔在这里提出了一个新概念 ---  半连接 （英文名： semi-join ）。将 s1 表和 s2 表进行半连接的意思就是：对于 s1 表的某条记录来说，我们只关心在 s2 表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留 s1 表的记录。半连接的实现方式有如下几种：

- Table pullout （子查询中的表上拉）：当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表 上拉 到外层查询的 FROM 子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中。因为是主键或者唯一索引，不存在重复值，故可以直接转内连接。

  ```sql
  SELECT * FROM s1 WHERE key2 IN (SELECT key2 FROM s2 WHERE key3 = 'a');
  SELECT s1、* FROM s1 INNER JOIN s2 ON s1、key2 = s2、key2 WHERE s2、key3 = 'a';
  ```

- DuplicateWeedout execution strategy （重复值消除）：为了消除重复，我们可以建立一个临时表。这样在执行连接查询的过程中，每当某条 s1 表中的记录要加入结果集时，就首先把这条记录的 id 值加入到这个临时表里，如果添加成功，说明之前这条 s1 表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，说明之前这条 s1 表中的记录已经加入过最终的结果集，这里直接把它丢弃就好了。

  ```sql
  SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
  CREATE TABLE tmp (id PRIMARY KEY); # 去重表
  ```

- LooseScan execution strategy （松散扫描）：驱动表中相同的记录只需要取第一条的值到被驱动表表中查找匹配条件的记录。这种虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为 松散扫描 。

- Semi-join Materialization execution strategy：也就是物化表，然后将外层查询和物化表转内连接，这种方式也是Semi-join的一种。

- FirstMatch execution strategy （首次匹配）：先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。

并不是所有包含 IN 子查询的查询语句都可以转换为 semi-join ：

- 该子查询必须是和 IN 语句组成的布尔表达式，并且在外层查询的 WHERE 或者 ON 子句中出现。
- 外层查询也可以有其他的搜索条件，只不过和 IN 子查询的搜索条件必须使用 AND 连接起来。
- 该子查询必须是一个单一的查询，不能是由若干查询由 UNION 连接起来的形式。
- 该子查询不能包含 GROUP BY 或者 HAVING 语句或者聚集函数。

如果不能转化成 Semi-join：

- 对于不相关子查询来说，可以尝试把它们物化之后再参与查询，这里只是物化，而不知物化转链接。

- 不管子查询是相关的还是不相关的， IN 子查询是放在 WHERE 或者 ON 子句中的，就是可以把 IN 子查询尝试转为 EXISTS 子查询。 IN 子查询不满足转换为 semi-join 的条件，又不能转换为物化表或者转换为物化表的成本太大，那么它就会被转换为 EXISTS 查询。IN 子查询可能不能使用索引，但是转化成 EXISTS 子查询可能会使用索引。

  ```sql
  outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)
  EXISTS (SELECT inner_expr FROM ... WHERE subquery_where AND outer_expr=inner_expr)
  ```

如果 IN 子查询符合转换为 semi-join 的条件，查询优化器会优先把该子查询转换为 semi-join ，然后再考虑下边5种执行半连接的策略中哪个成本最低：Table pullout, DuplicateWeedout, LooseScan, Materialization, FirstMatch。选择成本最低的那种执行策略来执行子查询。

如果 IN 子查询不符合转换为 semi-join 的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：先将子查询物化之后再执行查询，执行 IN to EXISTS 转换。

### 4、EXISTS 子查询的执行

如果 [NOT] EXISTS 子查询是不相关子查询，可以先执行子查询，得出该 [NOT] EXISTS 子查询的结果是 TRUE 还是 FALSE ，并重写原先的查询语句。

```sql
SELECT * FROM s1 WHERE EXISTS (SELECT 1 FROM s2 WHERE key1 = 'a') OR key2 > 100;
SELECT * FROM s1 WHERE TRUE OR key2 > 100; # 重写
```

对于相关的 [NOT] EXISTS 子查询来说，只能从外层查询中去一条记录执行子查询，在根据子查询结果判断这条记录是否加入结果集。

### 5、派生表优化

子查询放在外层查询的 FROM 子句后，那么这个子查询的结果相当于一个 派生表 。对于含有 派生表 的查询， MySQL 提供了两种执行策略：派生表物化 或者 将派生表和外层的表合并，也就是将查询重写为没有派生表的形式。 MySQL 在执行带有派生表的时候，优先尝试把派生表和外层查询合并掉，如果不行的话，再把派生表物化掉执行查询。

```sql
SELECT * FROM (SELECT * FROM s1 WHERE key1 = 'a') AS derived_s1;
SELECT * FROM s1 WHERE key1 = 'a'; # 派生表和外层表合并
```

当派生表中有复杂函数, DISTINCT, GROUP BY, HAVING, LIMIT,  UNION 或者 UNION ALL等情况时不可以和外层查询合并。

## Explain 执行计划

一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的 执行计划 ，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL 提供了 EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，各项内容简介如下：

| 列名          | 描述                                                      |
| ------------- | --------------------------------------------------------- |
| id            | 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id |
| select_type   | SELECT 关键字对应的那个查询的类型                         |
| table         | 表名                                                      |
| partitions    | 匹配的分区信息                                            |
| type          | 针对单表的访问方法                                        |
| possible_keys | 可能用到的索引                                            |
| key           | 实际上使用的索引                                          |
| key_len       | 实际使用到的索引长度                                      |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息    |
| rows          | 预估的需要读取的记录条数                                  |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比              |
| Extra         | 一些额外的信息：Using filesort                            |

```sql
mysql> EXPLAIN SELECT * FROM s1  UNION SELECT * FROM s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL            |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
3 rows in set, 1 warning (0.00 sec)
```

### 1、id

查询语句中每出现一个 SELECT 关键字， MySQL 就会为它分配一个唯一的 id 值，表示查询中执行select子句或操作表的顺序

- id 相同，执行顺序由上至下。在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表。

- id 不同，如果是子查询（可能被重写成连接查询），id 的序号会递增，id 值越大优先级越高，越先被执行。

### 2、select_type

查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询

| 名称                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `SIMPLE`               | 查询语句中不包含`UNION`或者子查询的查询都算作是`SIMPLE`类型，连接查询也算是`SIMPLE`类型。 |
| `PRIMARY`              | 包含`UNION`、`UNION ALL`或者子查询的大查询来说，它是由几个小查询组成的，其中最外层或者最左边的那个查询的`select_type`值就是`PRIMARY` |
| `UNION`                | 对于包含`UNION`或者`UNION ALL`的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的`select_type`值就是`UNION` |
| `UNION RESULT`         | `MySQL`选择使用临时表来完成`UNION`查询的去重工作，针对该临时表的查询的`select_type`就是`UNION RESULT` |
| `SUBQUERY`             | 子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个`SELECT`关键字代表的那个查询的`select_type`就是`SUBQUERY` |
| `DEPENDENT SUBQUERY`   | 子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是相关子查询，则该子查询的第一个`SELECT`关键字代表的那个查询的`select_type`就是`DEPENDENT SUBQUERY` |
| `DEPENDENT UNION`      | 包含`UNION`或者`UNION ALL`的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的`select_type`的值就是`DEPENDENT UNION` |
| `DERIVED`              | 采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的`select_type`就是`DERIVED` |
| `MATERIALIZED`         | 当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的`select_type`属性就是`MATERIALIZED` |
| `UNCACHEABLE SUBQUERY` | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query |
| `UNCACHEABLE UNION`    | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) |

### 3、table

不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以设计 MySQL 的大叔规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。

### 4、type

执行计划的一条记录就代表着 MySQL 对某个单表的执行查询时的访问方法，type 字段表示单表访问方法： system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL 。

- system：表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是 system 。
- const：根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const 。
- eq_ref：在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是 eq_ref 。
- ref：当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref 。
- ref_or_null：对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 ref_or_null 。
- index_merge：通常情况下MySQL只会使用一个索引进行单表查询，但是某些特殊情况可以使用 Intersection 、 Union 、 Sort-Union 这三种索引合并的方式来执行查询，其对应的 type 就是 index_merge。
- unique_subquery： unique_subquery 是针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery 。
- index_subquery：针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到普通二级索引进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 index_subquery 。
- range：使用索引获取某些 范围区间 的记录，那么就可能使用到 range 访问方法。一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围扫描索引扫描比全表扫描要好，因为他只需要开始索引的某一点，而结束于另一点，不用扫描全部索引。
- index：可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index 。这通常比ALL快，因为索引文件通常比数据文件小。
- all：权标扫描。

备注：一般来说，这些访问方法按照我们介绍它们的顺序性能依次变差，最好保证查询只是达到range级别，最好达到ref。

### 5、possible_keys/key

 possible_keys 列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些， key 列表示实际用到的索引有哪些。

不过有一点比较特别，就是在使用 index 访问方法来查询某个表时， possible_keys 列是空的，而 key 列展示的是实际使用到的索引。

possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。

### 6、key_len

 key_len 列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：

- 对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100) ，使用的字符集是 utf8 ，那么该列实际占用的最大存储空间就是 100 × 3 = 300 个字节。
- 如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多1个字节。
- 对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。

### 7、ref

当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 const 、 eq_ref 、 ref 、 ref_or_null 、 unique_subquery 、 index_subquery 其中之一时， ref 列展示的就是与索引列作等值匹配的内容，比如只是一个常数或者是某个列。

### 8、rows

如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 rows 列就代表预计扫描的索引记录行数。

### 9、Extra

 Extra 列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解 MySQL 到底将如何执行给定的查询语句。

**1.Using filesort**

MySQL中无法利用索引完成排序操作成为“文件排序”，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，设计 MySQL 的大叔把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名： filesort ）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的 Extra 列中显示 Using filesort 提示。

如果查询中需要使用 filesort 的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用 文件排序 的执行方式改为使用索引进行排序。

**2.Using temporary**

 MySQL 可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 DISTINCT 、 GROUP BY 、 UNION 等子句的查询过程中，如果不能有效利用索引来完成查询， MySQL 很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的 Extra 列将会显示 Using temporary 提示。

执行计划中出现 Using temporary 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表

**3.USING index**

表示相应的select操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表面索引用来读取数据而非执行查找动作。覆盖索引（Covering Index）

**4.Using index condition**

有些搜索条件中虽然出现了索引列，有的可以使用索引，有的不能使用到索引，但是可以使用索引条件下推。

```sql
SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';
```

其中的 key1 > 'z' 可以使用到索引，但是 key1 LIKE '%a' 却无法使用到索引，在以前版本的 MySQL 中，是按照下边步骤来执行这个查询的：

- 先根据 key1 > 'z' 这个条件，从二级索引 idx_key1 中获取到对应的二级索引记录。
- 根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合 key1 LIKE '%a' 这个条件，将符合条件的记录加入到最后的结果集。

但是虽然 key1 LIKE '%a' 不能组成范围区间参与 range 访问方法的执行，但这个条件毕竟只涉及到了 key1 列，所以设计 MySQL 的大叔把上边的步骤改进了一下：

- 先根据 key1 > 'z' 这个条件，定位到二级索引 idx_key1 中对应的二级索引记录。
- 对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足 key1 LIKE '%a' 这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。
- 对于满足 key1 LIKE '%a' 这个条件的二级索引记录执行回表操作。

我们说回表操作其实是一个随机 IO ，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。设计 MySQL 的大叔们把他们的这个改进称之为 索引条件下推 （英文名： Index Condition Pushdown ）。

如果在查询语句的执行过程中将要使用 索引条件下推 这个特性，在 Extra 列中将会显示 Using index condition 

**5.using join buffer**

当被驱动表不能有效的利用索引加快访问速度， MySQL 一般会为其分配一块名叫 join buffer 的内存块来加快查询速度，也就是我们所讲的 基于块的嵌套循环算法 。

**6. Using intersect(...) 、 Using union(...) 和 Using sort_union(...) **

如果执行计划的 Extra 列出现了 Using intersect(...) 提示，说明准备使用 Intersect 索引合并的方式执行查询，括号中的 ... 表示需要进行索引合并的索引名称；如果出现了 Using union(...) 提示，说明准备使用 Union 索引合并的方式执行查询；出现了 Using sort_union(...) 提示，说明准备使用 Sort-Union 索引合并的方式执行查询

**7.Start temporary, End temporary**

我们前边唠叨子查询的时候说过，查询优化器会优先尝试将 IN 子查询转换成 semi-join ，而 semi-join 又有好多种执行策略，当执行策略为 DuplicateWeedout 时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的 Extra 列将显示 Start temporary 提示，被驱动表查询执行计划的 Extra 列将显示 End temporary 提示

**8.LooseScan**

在将 In 子查询转为 semi-join 时，如果采用的是 LooseScan 执行策略，则在驱动表执行计划的 Extra 列就是显示 LooseScan 提示

**9.FirstMatch(tbl_name)**

在将 In 子查询转为 semi-join 时，如果采用的是 FirstMatch 执行策略，则在被驱动表执行计划的 Extra 列就是显示 FirstMatch(tbl_name) 提示

**10.Using where**

当我们使用全表扫描来执行对某个表的查询，并且该语句的 WHERE 子句中有针对该表的搜索条件时 Extra 会提示 using Where。

**11.impossible where**

查询语句的 WHERE 子句永远为 FALSE 时将会提示该额外信息。

**12.select tables optimized away**

在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。

**13.distinct**

优化distinct，在找到第一匹配的元组后即停止找同样值的工作

## Buffer Pool 缓存池

### 1、Buffer Pool 结构

MySQL 为了缓存磁盘中的页，在 MySQL 服务器启动的时候就向操作系统申请了一片连续的内存，他们给这片内存起了个名，叫做 Buffer Pool （中文名是 缓冲池 ），默认情况下 Buffer Pool 只有 128M 。 Buffer Pool 的缓存页除了用来缓存磁盘上的页面以外，还可以存储锁信息、自适应哈希索引等信息。

![image_1d15r7te41q58egj1b4plh615ug7r.png-125、5kB](https://gitee.com/bruceyum/pictures/raw/master/pics/1693e86e2a5de8f2)

- **控制块及缓存页**： Buffer Pool 中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是 16KB ，每一个缓存页都有对应的 控制信息 ，这些控制信息包括该页所属的表空间编号、页号、缓存页在 Buffer Pool 中的地址、链表节点信息、一些锁信息以及 LSN 信息。控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边。

- **chunk**： MySQL5、7、5  之后不再一次性为某个 Buffer Pool 实例向操作系统申请一大片连续的内存空间，而是以一个 chunk 为单位向操作系统申请空间。也就是说一个 Buffer Pool 实例其实是由若干个 chunk 组成的，一个 chunk 就代表一片连续的内存空间。 chunk 的大小是我们在启动操作 MySQL 服务器时通过 innodb_buffer_pool_chunk_size 启动参数指定的，它的默认值是 134217728 ，也就是 128M 。

- **哈希索引**：为了快速定位某个页是否被加载到 Buffer Pool ，使用 表空间号 + 页号 作为 key ，缓存页作为 value ，建立哈希表。在需要访问某个页的数据时，先从哈希表中根据 表空间号 + 页号 看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从 free链表 中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。

- **Buffer Pool 多实例**： Buffer Pool 本质是 InnoDB 向操作系统申请的一块连续的内存空间，在多线程环境下，访问 Buffer Pool 中的各种链表都需要加锁处理啥的，在 Buffer Pool 特别大而且多线程并发访问特别高的情况下，单一的 Buffer Pool 可能会影响请求的处理速度。所以在 Buffer Pool 特别大的时候，我们可以把它们拆分成若干个小的 Buffer Pool ，每个 Buffer Pool 都称为一个 实例 ，它们都是独立的，独立的去申请内存空间，独立的管理各种链表

  不过也不是说 Buffer Pool 实例创建的越多越好，分别管理各个 Buffer Pool 也是需要性能开销的，设计 InnoDB 的大叔们规定：当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances 的值修改为1。而我们鼓励在 Buffer Pool 大于或等于1G的时候设置多个 Buffer Pool 实例。

- **free 链表**：所有空闲的缓存页对应的控制块构成一个双向链表，这个链表也可以被称作 free链表 （或者说空闲链表）。每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 free链表 中取一个空闲的缓存页，并且把该缓存页对应的 控制块 的信息填上（就是该页所在的表空间、页号之类的信息），然后把该缓存页对应的 free链表 节点从链表中移除，表示该缓存页已经被使用了

- **flush 链表**：如果我们修改了 Buffer Pool 中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为 脏页 （英文名： dirty page ）。如果每发生一次修改都将脏页同步到磁盘中会严重影响性能，所以MySQL 将所有 Buffer Pool 中的脏页构成双向列表，称为 flush链表

- **LRU 链表**：Buffer Pool 作为页面缓存池空间有限，当Buffer Buffer 满的时候就 MySQL 采用 LRU 法将旧的页面置换到磁盘，并将即将访问的页面加载到Buffer Pool中。MySQL 维护 一个相应的LRU 链表。

### 2、LRU链表的管理

当 Buffer Pool 中不再有空闲的缓存页时，就需要淘汰掉部分最近很少使用的缓存页。MySQL 使用 LRU 算法进行缓存淘汰。简单的 LRU 算法在缓存页被访问的时候将对应的页面放到链表头，而空间不够的时候淘汰链表尾部的页面。但是简单的 LRU链表在 MySQL Buffer Pool 中应用会存在一些问题：

预读机制： InnoDB 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到 Buffer Pool 

线性预读：如果顺序访问了某个区（ extent ）的页面超过这个innodb_read_ahead_threshold系统变量的值（默认是 56 ），就会触发一次 异步 读取下一个区中全部的页面到 Buffer Pool 的请求。

随机预读：如果 Buffer Pool 中已经缓存了某个区的13个连续的页面，不论这些页面是不是顺序读取的，都会触发一次 异步 读取本区中所有其的页面到 Buffer Pool 的请求。同时提供了 innodb_random_read_ahead 系统变量，它的默认值为 OFF ，也就意味着 InnoDB 并不会默认开启随机预读的功能。

这些预读的页都会放到 LRU 链表的头部，但是如果此时 Buffer Pool 的容量不太大而且很多预读的页面都没有用到的话，这就会导致处在 LRU链表 尾部的一些缓存页会很快的被淘汰掉，也就是所谓的 劣币驱逐良币 ，会大大降低缓存命中率。

全表扫描：MySQL执行查询是很有可能会进行全表扫描，也就意味着该表相关所有的页面都要加载到 Buffer Pool 中，导致 Buffer Pool 中原本缓存的页面被置换出去。然后加载进来的很多数据都是冷数据，缓存命中率不高，那么Buffer Pool 的作用严重下降。

因为 MySQL 对 LRU 链表进行了一些改进： LRU链表 分为 young 和 old 两个区域，可以通过 innodb_old_blocks_pct 来调节 old 区域所占的比例。

- 一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做 热数据 ，或者称 young区域 。
- 另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做 冷数据 ，或者称 old区域 。
- 首次从磁盘上加载到 Buffer Pool 的页会被放到 old 区域的头部，在 innodb_old_blocks_time 间隔时间内访问该页不会把它移动到 young 区域头部。
- 在 Buffer Pool 没有可用的空闲缓存页时，会首先淘汰掉 old 区域的一些页。

![image_1d15fb53d2lf13ovglg1rnv1h2n2g.png-116、5kB](https://gitee.com/bruceyum/pictures/raw/master/pics/1693e86e2a3fffa3)

### 3、刷新脏页到磁盘

后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。

- 从 LRU链表 的冷数据中刷新一部分页面到磁盘。

  后台线程会定时从 LRU链表 尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 innodb_lru_scan_depth 来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为 BUF_FLUSH_LRU 。

- 从 flush链表 中刷新一部分页面到磁盘。

  后台线程也会定时从 flush链表 中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为 BUF_FLUSH_LIST 。

### 4、插入缓冲区

若插入按照聚集索引primary key插入，页中的行记录按照primary存放，一般情况下不需要读取另一个页记录，插入速度很快（如果使用UUID或者指定的ID插入而非自增类型则可能导致非连续插入导致性能下降，由B+树特性决定）。如果按照非聚集索引插入就很有可能存在大量的离散插入，insert buffer对于非聚集索引的插入和更新操作进行一定频率的合并操作，再merge到真正的索引页中。使用insert buffer需满足条件：

  （1）索引为辅助索引。

  （2）索引非唯一。（唯一索引需要从查找索引页中的唯一性，可能导致离散读取）

**Double write**

Doubel write保证了页的可靠性，Redo log是记录对页(16K)的物理操作，若innodb将页写回表时写了一部分(如4K)出现宕机，则物理页将会损坏无法通过redolog恢复。所以在apply重做日志前，将缓冲池中的脏页通过memcpy到doublewrite buffer中，再将doublewrite buffer页分两次每次1MB刷入共享表空间的磁盘文件中（磁盘连续，开销较小），完成doublewrite buffer的页写入后再写入各个表空间的表中。

![图片](https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDefOvq1e9w070kP8icNHQAuXr0a8M0niaRuATyem1Y36IcOc4yhl3xSbELUKgpx2RfOT8SNR9Q7GLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

当写入页时发生系统崩溃，恢复过程中，innodb从共享表空间的doublewrite找到该页的副本，并将其恢复到表空间文件中，再apply重做日志。



## 查询截取分析

### 1、慢查询日志

![](http://cdn.processon.com/605a15141e0853028a9e8cc3)

查看是否开启及如何开启：SHOW VARIABLES LIKE '%slow_query_log%'

![img](http://cdn.processon.com/605a15267d9c08555e50e91f)


![img](http://cdn.processon.com/605a15365653bb2225e19cc3)

set global slow_query_log = 1

![img](http://cdn.processon.com/605a1553f346fb6d9edbe67d)

![img](http://cdn.processon.com/605a156c1e0853028a9e8cfc)


那么开启慢查询日志后，什么样的SQL参会记录到慢查询里面？

![img](http://cdn.processon.com/605a157ef346fb6d9edbe6a2)


查看当前多少秒算慢：SHOW VARIABLES LIKE 'long_query_time%';


设置慢的阙值时间：set global long_query_time=3;

注：为什么设置后看不出变化？需要重新连接或者新开一个回话才能看到修改值。SHOW VARIABLES LIKE 'long_query_time%';

show global variables like 'long_query_time';

记录慢SQL并后续分析

![img](http://cdn.processon.com/605a15a07d9c08555e50e984)

查询当前系统中有多少条慢查询记录

![img](http://cdn.processon.com/605a15af1e0853028a9e8d3c)


配置版

![img](http://cdn.processon.com/605a15c0e0b34d780efcddb6?e=1616520144&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:KjYgdf-M7qqZWPWNFjhVdNH2sV4=)

### 2、mysqldumpshow


查看mysqldumpshow的帮助信息

    s:是表示按何种方式排序
    
    c:访问次数
    
    l:锁定时间
    
    r:返回记录
    
    t:查询时间
    
    al:平均锁定时间
    
    ar:平均返回记录数
    
    at:平均查询时间
    
    t:即为返回前面多少条的数据
    
    g:后边搭配一个正则匹配模式，大小写不敏感的


工作常用参考

![img](http://cdn.processon.com/605a15e307912927bd76bbaa)

### 3、Show profiles

**1、是什么**

是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量

官网：http://dev.mysql.com/doc/refman/5、5/en/show-profile.html

默认情况下，参数处于关闭状态，并保存最近15次的运行结果


**2、怎么用**

1、是否支持，看看当前的SQL版本是否支持

![img](http://cdn.processon.com/605a1611f346fb6d9edbe715)

2、开启功能，默认是关闭，使用前需要开启

3、运行SQL

select * from emp group by id%10 limit 150000

select * from emp group by id%20 order by 5

4、查看结果，show profiles;


5、诊断SQL，show profile cpu,block io for query 上一步前面的问题SQL 数字号码；

![img](http://cdn.processon.com/605a162163768970077474d6)

![img](http://cdn.processon.com/605a162f63768970077474df)


6、日常开发需要注意的结论

    converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。
    
    Creating tmp table 创建临时表
    
    ![img](http://cdn.processon.com/605a1645f346fb6d9edbe73e)
    
    拷贝数据到临时表
    
    用完再删除
    
    Copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！！
    
    locked

### 4、全局查询日志


配置启用

![img](http://cdn.processon.com/605a1654e401fd4c03919bb7)

编码启用

![](http://cdn.processon.com/605a165f7d9c08555e50eab6)

永远不要在生产环境开启这个功能。

## 性能优化建议

1、MySQL Query Optimizer

![img](http://cdn.processon.com/605a0d9e07912927bd76b3c3)

2、MySQL常见瓶颈

- CPU:CPU在饱和的时候一般发生在数据装入在内存或从磁盘上读取数据时候

- IO:磁盘I/O瓶颈发生在装入数据远大于内存容量时

- 服务器硬件的性能瓶颈：top,free,iostat和vmstat来查看系统的性能状态

3、小表驱动大表

![img](http://cdn.processon.com/605a145307912927bd76ba60)

永远小表驱动大表,类似嵌套循环Nested Loop，案例：

![img](http://cdn.processon.com/605a14cce0b34d780efcdd12)

4、order by关键字优化

**1、 排序方式**

ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。MySQL支持二种方式的排序，FileSort和Index, Index 效率高。它指 MySQL 扫描索引本身完成排序。FileSort 方式效率较低。

ORDER BY满足两情况，会使用Index方式排序

- ORDER BY语句使用索引最左前列

- 使用where子句与OrderBy子句条件列组合满足索引最左前列，尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀


如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序

- 双路排序

MySQL4、1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。
读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输。从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4、1之后，出现了第二张改进的算法，就是单路排序。

- 单路排序

从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。


结论及引申出的问题

由于单路是后出来的，总体而言好过双路，但是用单路有问题

![img](http://cdn.processon.com/605a14a9e0b34d780efcdcfa)


**优化策略**

增大sort_buffer_size参数的设置

增大max_length_for_sort_data参数的设置

![img](http://cdn.processon.com/605a149863768970077473b1)

![](http://cdn.processon.com/605a14fae401fd4c03919ab7?e=1616519946&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:u7O6NJlSYiCYOs3LYlfGFeTQ4_0=)

5、GROUP BY关键字优化

group by 实质是先排序后进行分组，遵照索引建的最佳左前缀

当无法使用索引列，增大 max_length_for_sort_data 参数的设置 + 增大 sort_buffer_size 参数的设置

where高于having, 能写在 where 限定的条件就不要去 having 限定了。

6、优化数据访问

**1、 减少请求的数据量**

- 只返回必要的列：最好不要使用 SELECT * 语句。
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
- 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

**2、 减少服务器端扫描的行数**

最有效的方式是使用索引来覆盖查询。

7、重构查询方式

**1、 切分大查询**

一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

```sql
DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);
```

```sql
rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
} while rows_affected > 0
```

**2、 分解大连接查询**

将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
- 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
- 减少锁竞争；
- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
- 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

```sql
SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
```

```sql
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
```

