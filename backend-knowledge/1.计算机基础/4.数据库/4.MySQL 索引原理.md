# MySQL 索引原理

[toc]

在MySQL 数据存储结构中我们知道，MySQL的数据存储在页中，页之间构成双向链表，业内的记录构成单向链表。如果不创建任何索引，只能遍历页面双向链表找到数据所在页，页内通过页目录二分查找找到所在组，遍历记录组找到相应数据。

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。
MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。

## B+ 树概述

### 1、数据结构

B-Tree

一棵m阶的B树满足如下特点（m>2）：

- 如果非空树则root子节点数为[2,m]
- 所有非根非叶子节点的子节点数为[ceiling(m/2),m]
- 所有叶子结点都在同一层
- 一个节点包含n个子节点则和n-1个关键字，且关键字从大到小排序且第 i个关键字对应子节点的关键字小于 i 

B+Tree

与B-Tree相比，B+Tree有以下不同点：

- 非叶子结点的子树指针与关键字个数相同；
- 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
- 所有叶子结点增加一个链指针；
- 所有关键字都在叶子结点出现；
- 内节点不存储data，只存储key

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。

如：（M=3） 的 B+树

![img](http://cdn.processon.com/605a0c8307912927bd76b265?e=1616517779&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ZN38EK6TkG16f2Levm8DySL2Xvo=)



### 2、B+ tree的优点

- B+ tree的磁盘读写代价更低
  B+ tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

  举个例子，假设磁盘中的一个盘块容纳16 bytes，而一个关键字 2 bytes，一个关键字具体信息指针 2 bytes。一棵 9 阶 B-tree(一个结点最多8个关键字)的内部结点需要 2 个盘快。而 B+ tree 内部结点只需要 1 个盘快。当需要把内部结点读入内存中的时候，B 树就比 B+  树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

- B+ tree 的查询效率更加稳定
  由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

### 3、与红黑树的比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。

- B+ 树有更低的树高

  平衡树的树高 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。

- 磁盘访问原理

  操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。

  如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。

- 磁盘预读特性

  为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。

## B+Tree 索引

是大多数 MySQL 存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

### 1、聚簇索引

如上所述，B+ 树所有的数据都存在叶子节点。内部节点不存储真实数据，MySQL 定义专门定义了一种记录类型用户存储目录项记录。`record_type`属性，它的各个取值代表的意思如下：0：普通的用户记录，1：目录项记录，`2`：最小记录`3`：最大记录

- `目录项记录`的`record_type`值是1，而普通用户记录的`record_type`值是0。
- `目录项记录`只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有`InnoDB`自己添加的隐藏列。
- 还记得我们之前在唠叨记录头信息的时候说过一个叫`min_rec_mask`的属性么，只有在存储`目录项记录`的页中的主键值最小的`目录项记录`的`min_rec_mask`值为`1`，其他别的记录的`min_rec_mask`值都是`0`。

在`InnoDB`存储引擎中，`聚簇索引`就是数据的存储方式（所有的用户记录都存储在了`叶子节点`），也就是所谓的索引即数据，数据即索引。

- 页内的记录是按照主键的大小顺序排成一个单向链表。
- 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
- 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

- `B+`树的叶子节点存储的是完整的用户记录：所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

![image_1cacafpso19vpkik1j5rtrd17cm3a.png-158.1kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a01bd2a6c7a65f)

存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到`B+`树这个数据结构中了，所以我们也称这些数据页为`节点`。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为`叶子节点`或`叶节点`，其余用来存放`目录项`的节点称为`非叶子节点`或者`内节点`，其中`B+`树最上边的那个节点也称为`根节点`。现在以查找主键为`20`的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边3步：

1. 确定`目录项记录`页
2. 通过`目录项记录`页确定用户记录真实所在的页。
3. 在真实存储用户记录的页中定位到具体的记录。

### 2、辅助索引

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

![image_1cactc8jg14j91likvmd1h8cn3o4h.png-161.6kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a01bd2a89adfa5)

这个`B+`树与上边介绍的聚簇索引有几处不同：

- 页内的记录是按照`索引列`列的大小顺序排成一个单向链表。
- 各个存放用户记录的页也是根据页中记录的`索引列`列大小顺序排成一个双向链表。
- 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的`索引列`列大小顺序排成一个双向链表。

- `B+`树的叶子节点存储的并不是完整的用户记录，而只是`索引列列+主键`这两个列的值。
- 目录项记录中不再是`主键+页号`的搭配，而变成了`索引列列+主键+页号`的搭配。

所以如果我们现在想通过`索引列`列的值查找某些记录的话就可以使用我们刚刚建好的这个`B+`树了：

1. 确定`目录项记录`页
2. 通过`目录项记录`页确定用户记录真实所在的页。
3. 在真实存储用户记录的页中定位到具体的记录。
4. 但是这个`B+`树的叶子节点中的记录只存储`索引列+主键`两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。

### 3、联合索引

联合索引也是辅助索引，联合索引会按照索引列顺序存储及排序：

1. 每条`目录项记录`都由`索引列1`...`索引列n`、`页号`这三个部分组成，各条记录先按照`索引列1`列的值进行排序，如果记录的`索引列1`列相同，则按照`索引列2`列的值进行排序。
2. `B+`树叶子节点处的用户记录由`索引列1`...`索引列n`和主键列组成。

![image_1d80rmun21al711ok1tvo1i161rnpp.png-172.2kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a01bd2b0b70d72)



## 其它类型索引

### 1、MyISAM 索引

将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为`数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。

使用`MyISAM`存储引擎的表会把索引信息另外存储到一个称为`索引文件`的另一个文件中。`MyISAM`会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是`主键值 + 行号`的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录。

### 2、哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

### 3、全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

### 4、空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。


## 索引的优缺点

### 1、索引缺点

- 空间上的代价：每建立一个索引都要为它建立一棵`B+`树，每一棵`B+`树的每一个节点都是一个数据页，一个页默认会占用`16KB`的存储空间，一棵很大的`B+`树由许多数据页组成，所以索引列也是要占用很大空间。

- 时间上的代价：虽然索引大大提高了查询速度，同时却会降低更新表的速度,如果对表INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，
  都会调整因为更新所带来的键值变化后的索引信息。

- 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句。

### 2、索引优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

## 索引适用条件

### 1、示例表

```sql
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

- 表中的主键是`id`列，它存储一个自动递增的整数。所以`InnoDB`存储引擎会自动为`id`列建立聚簇索引。
- 我们额外定义了一个二级索引`idx_name_birthday_phone_number`，它是由3个列组成的联合索引。所以在这个索引对应的`B+`树的叶子节点处存储的用户记录只保留`name`、`birthday`、`phone_number`这三个列的值以及主键`id`的值，并不会保存`country`列的值。从图中可以看出，这个`idx_name_birthday_phone_number`索引对应的`B+`树中页面和记录的排序方式就是这样的：先按照`name`列的值进行排序，如果`name`列的值相同，则按照`birthday`列的值进行排序，如果`birthday`列的值也相同，则按照`phone_number`的值进行排序。

![image_1dmo2n5c11ij019unpjtpf21tdr9.png-121.1kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16db02bc665cf0b1)

### 2、全值匹配

如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，例如：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

因为 idx_name_birthday_phone_number 索引按照 name, birthday, phone_number 进行排序，所以可以通过索引快速找到需要的记录。

注意：如果调换`name`、`birthday`、`phone_number`这几个搜索列的顺序并不会影响查询执行过程，`MySQL`通过查询优化器分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。

### 3、最左匹配

按照索引创建时索引列的顺序，搜索条件中包含索引列左边的一列或多列，例如：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn';
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
```

但是如果跳过左边列，则无法使用索引。因为`B+`树的数据页和记录先是按照`name`列的值排序的，在`name`列的值相同的情况下才使用`birthday`列进行排序，也就是说`name`列的值不同的记录中`birthday`的值可能是无序的。而现在你跳过`name`列直接根据`birthday`的值去查找是无法使用索引的，例如：

```sql
SELECT * FROM person_info WHERE birthday = '1990-09-27';
```

如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。如果包含最左边的索引列，也包含右边的索引列，跳过中间的索引列，则查询中只能用到左边列的索引。

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND phone_number = '15123983239';
```

这样只能用到`name`列的索引，`birthday`和`phone_number`的索引就用不上了，因为`name`值相同的记录先按照`birthday`的值进行排序，`birthday`值相同的记录才按照`phone_number`值进行排序。

### 4、匹配列前缀

字符串类型的列按照字符串大小排序，会依次比较每个字符的大小，也就是说这些字符串的前n个字符，也就是前缀都是排好序的。所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的。如果不是前缀匹配则无法使用索引，只能全表扫描了。

```sql
SELECT * FROM person_info WHERE name LIKE 'As%';  #前缀匹配可以使用索引
SELECT * FROM person_info WHERE name LIKE '%As%'; #全表扫描
```

### 5、匹配范围值

对联合索引多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到`B+`树索引，由于`B+`树中的数据页和记录是先按`name`列排序的，所以我们上边的查询过程其实是这样的：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';
```

- 通过B+树在叶子节点中找到第一条`name`值大于`Asa`的二级索引记录，读取该记录的主键值进行回表操作，判断 birthday > '1980-01-01'，获得对应的聚簇索引记录后发送给客户端。
- 根据上一步找到的记录，沿着记录所在的链表向后查找（同一页面中的记录使用单向链表连接起来，数据页之间用双向链表连接起来）下一条二级索引记录，判断该记录是否符合 AND name < 'Barlow' 条件，如果符合，则进行回表操作，判断birthday > '1980-01-01' 后发送至客户端。
- 重复上一步骤，直到某条二级索引记录不符合name <'Barlow'条件为止。

精确匹配某一列并范围匹配另外一列

对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列进行范围查找可以用到索引；

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

这个查询的条件可以分为3个部分：

1. `name = 'Ashburn'`，对`name`列进行精确查找，当然可以使用`B+`树索引了。
2. `birthday > '1980-01-01' AND birthday < '2000-12-31'`，由于`name`列是精确查找，所以通过`name = 'Ashburn'`条件查找后得到的结果的`name`值都是相同的，它们会再按照`birthday`的值进行排序。所以此时对`birthday`列进行范围查找是可以用到`B+`树索引的。
3. `phone_number > '15100000000'`，通过`birthday`的范围查找的记录的`birthday`的值可能不同，所以这个条件无法再利用`B+`树索引了，只能遍历上一步查询得到的记录。

### 6、用于排序/分组

我们可以使用 ORDER BY 子句对记录进行排序，通常将记录加载到内存（如果记录太多可能还需要借助磁盘），再采用排序算法进行排序，这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：`filesort`），文件排序很慢。但是如果`ORDER BY`子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤。

- 对于`联合索引`有个问题需要注意，`ORDER BY`的子句后边的列的顺序也必须按照索引列的顺序给出；当联合索引左边列的值为常量，也可以使用后边的列进行排序

  ```sql
  SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;#使用索引排序
  SELECT * FROM person_info ORDER BY birthday, name,phone_number LIMIT 10; #不使用索引排序
  SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10; #可以使用索引排序
  ```

- ASC、DESC混用：name 升序，birthday 降序无法使用索引进行排序

  ```sql
  SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10; #不使用索引排序
  ```

- 排序列包含非同一个索引的列：`name`和`country`并不属于一个联合索引中的列，所以无法使用索引进行排序

  ```sql
  SELECT * FROM person_info ORDER BY name, country LIMIT 10; #不使用索引排序
  ```

- 排序列使用了复杂的表达式：

  ```
  SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;
  ```

利用索引分组和使用`B+`树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。

### 7、覆盖索引

覆盖索引及 SELECT 子句选取的列都包含在索引列中，所有的数据都在辅助索引中存在，则不需要进行回表取数据，这种只需要用到索引的查询方式称为`索引覆盖`。例如，我们只查询`name`, `birthday`, `phone_number`这三个索引列的值，所以在通过`idx_name_birthday_phone_number`索引得到结果后就不必到`聚簇索引`中再查找记录的剩余列，也就是`country`列的值了，这样就省去了`回表`操作带来的性能损耗。

```sql
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
```

### 8、回表的代价

辅助所有顺序I/O：从索引`idx_name_birthday_phone_number`对应的`B+`树中取出`name`值在`Asa`～`Barlow`之间的用户记录。`Asa`～`Barlow`之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为`顺序I/O

回表聚簇索引随机I/O：根据辅助索引中获取到的记录的`id`字段的值可能并不相连，而在聚簇索引中记录是根据`id`（也就是主键）的顺序排列的，所以根据这些并不连续的`id`值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为`随机I/O`。

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用`二级索引`。比方说`name`值在`Asa`～`Barlow`之间的用户记录数量占全部记录数量90%以上，那么如果使用`idx_name_birthday_phone_number`索引的话，有90%多的`id`值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。

## 如何挑选索引

**1.只为用于搜索、排序或分组的列创建索引**：只为出现在`WHERE`子句中的列、连接子句中的连接列，或者出现在`ORDER BY`或`GROUP BY`子句中的列创建索引，只在查询列表中的列就没必要建立索引。

**2.考虑列的基数（可选择性）**：列的基础=不同记录数/总的记录数，最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。例如，性别字段，100万行也只有两个不同的值，不适合创建索引。

**3.索引列类型尽量小**：如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用`INT`就不要使用`BIGINT`，能使用`MEDIUMINT`就不要使用`INT`

- 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘`I/O`带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

**4.索引字符串值的前缀**：只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。

- `B+`树索引中的记录不需要把该列的完整字符串存储起来，节约存储空间。
- 如果`B+`树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间，只索引字符串前缀可以节省字符串比较时间。
- 但是如果使用改字段进行排序，因为索引只包含前缀无法正确排序，只能使用文件排序；

**5.让索引列在比较表达式中单独出现**：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。

**6.主键自增**：如果插入时主键时随机的，那么很可能需要移动大量记录，影响插入性能。所以我们建议：让主键具有`AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入。

**7.避免冗余和重复索引**：浪费存储空间。

注意：对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## 参考资料

- BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.
- 姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.
- [20+ 条 MySQL 性能优化的最佳经验](https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html)
- [服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策](http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/ "服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策")
- [How to create unique row ID in sharded databases?](https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases)
- [SQL Azure Federation – Introduction](http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx "Title of this entry.")
- [MySQL 索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
- [MySQL 性能优化神器 Explain 使用分析](https://segmentfault.com/a/1190000008131735)
- [How Sharding Works](https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6)
- [大众点评订单系统分库分表实践](https://tech.meituan.com/dianping_order_db_sharding.html)
- [B + 树](https://zh.wikipedia.org/wiki/B%2B%E6%A0%91)
