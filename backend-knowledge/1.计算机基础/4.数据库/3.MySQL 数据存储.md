# MySQL 数据结构

[toc]

## InnoDB 存储结构

### 1、数据目录

MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储到这个目录下的某些文件中，这个目录就称为 数据目录 。

**1.数据及表结构**

每个数据库对应一个文件夹：每当我们使用 CREATE DATABASE 数据库名 语句创建一个数据库的时候，MySQL 会在 数据目录 下创建一个和数据库名同名的子目录（或者说是文件夹），在该与数据库名同名的子目录下创建一个名为 db.opt 的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是个啥。

我们的数据其实都是以记录的形式插入到表中的，每个表的信息其实可以分为两种：表结构的定义和表中的数据。表结构文件名是 表名.frm ，数据存储在 表名.ibd 中。

**2.服务器进程文件**

我们知道每运行一个 MySQL 服务器程序，都意味着启动一个进程。 MySQL 服务器会把自己的进程ID写入到一个文件中。

**3.服务器日志文件**

在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志等各种日志，这些日志各有各的用途。

**4.默认/自动生成的SSL和RSA证书和密钥文件**

### 2、页

InnoDB 将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

对于 InnoDB 存储引擎来说，每个索引都对应着一棵 B+ 树，该 B+ 树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有 双向链表 来维护着这些页的顺序。 InnoDB 的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。

### 3、表空间

为了更好的管理这些页，InnoDB 提出了一个 表空间 或者 文件空间 （英文名： table space 或者 file space ）的概念，这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个 表空间 可以被划分为很多很多很多个 页 ，我们的表数据就存放在某个 表空间 下的某些页里。表空间有几种不同的类型

**1.系统表空间（system tablespace）**

 系统表空间 对应文件系统上一个或多个实际的文件，默认情况下， InnoDB 会在 数据目录 下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应的 系统表空间 在文件系统上的表示。这个文件是 自扩展文件 ，当不够用的时候它会自己增加文件大小。在一个MySQL服务器中，系统表空间只有一份。

**2.独立表空间(file-per-table tablespace)**

在MySQL5.6.6以及之后的版本中， InnoDB 并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间。使用 独立表空间 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该 独立表空间 的文件，文件名和表名相同 表名.ibd 。

**3.其他类型的表空间**

随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）等。

### 4、系统数据库

**1.mysql**

存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。

**2.information_schema**

这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引等。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。

**3.performance_schema**

这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。

**4.sys**

这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。

## InnoDB 行格式

MySQL中的数据是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 行格式 或者 记录格式 。MySQL中有4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、 Dynamic 和 Compressed 行格式。在创建或修改表的时候可以指定行格式。

```sql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称

// 建表语句，接下来通过这张表说明MySQL记录数据结构
mysql> CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;

mysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)

```

### 1、COMPACT行格式

![169710e8fafc21aa](https://gitee.com/bruceyum/pictures/raw/master/pics/169710e8fafc21aa.png)

大家从图中可以看出来，一条完整的记录其实可以被分为 记录的额外信息 和 记录的真实数据 两大部分，下边我们详细看一下这两部分的组成。

**1.变长字段长度列表**

我们知道 MySQL 支持一些变长的数据类型，比如 VARCHAR(M) 、 VARBINARY(M) 、各种 TEXT 类型，各种 BLOB 类型，我们也可以把拥有这些数据类型的列称为 变长字段 ，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。变长字段占用的存储空间分为两部分：真正的数据内容和占用的字节数。

在 Compact 行格式中，把所有（非NULL）变长字段的**真实数据占用的字节长度**都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序**逆序**存放。

record_format_demo 表的 c1 、 c2 、 c4 列都是 VARCHAR(10) 类型的，ascii 字符集，每个字符长度为 1 byte。故第一条记录c1=04, c2=03, c4=01; 逆序存放就是 01 03 04 。

第二条记录中 c4 为 NULL，其长度不放入变长字段列表。

![变长字段列表 image_1c9grq2b2jok1062t8tov21lqjbj.png-42.6kB](https://gitee.com/bruceyum/pictures/raw/master/pics/169710e8fe4ee6b0)

**2.NULL值列表**

我们知道表中的某些列可能存储 NULL 值，如果把这些 NULL 值都放到 记录的真实数据 中存储会很占地方，所以 Compact 行格式把这些值为 NULL 的列统一管理起来，存储到 NULL 值列表中

- 首先统计表中允许存储 NULL 的列有哪些。
- 如果表中没有允许存储 ***NULL*** 的列，则 *NULL值列表* 也不存在了，否则将每个允许存储 NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列。二进制位的值为 1 时，代表该列的值为 NULL ，否则该列的值不为 NULL 。

 record_format_demo 有c1, c3, c4 允许为 NULL 的列。record_format_demo 中第一条记录没有NULL值，故NULL值列表为  0 。第二条记录c3 和 c4 的值都为 NULL，按照二进制逆序存储则 NULL值列表为  00000110 

![image_1c9grs9m4co8134u1t2rjhm1q6rc0.png-39kB](https://gitee.com/bruceyum/pictures/raw/master/pics/169710e95903144f)

**3.记录头信息**

除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 记录头信息 ，它是由固定的 5 个字节组成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思，如图：

![image_1c9geiglj1ah31meo80ci8n1eli8f.png-29.5kB](https://gitee.com/bruceyum/pictures/raw/master/pics/169710e97718ef01)

| 名称         | 大小（单位：bit） | 描述                                                         |
| ------------ | ----------------- | ------------------------------------------------------------ |
| 预留位1      | 1                 | 没有使用                                                     |
| 预留位2      | 1                 | 没有使用                                                     |
| delete_mask  | 1                 | 标记该记录是否被删除                                         |
| min_rec_mask | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| n_owned      | 4                 | 表示当前记录拥有的记录数                                     |
| heap_no      | 13                | 表示当前记录在记录堆的位置信息                               |
| record_type  | 3                 | 表示当前记录的类型， 0 表示普通记录， 1 表示B+树非叶子节点记录， 2 表示最小记录， 3 表示最大记录 |
| next_record  | 16                | 表示下一条记录的相对位置                                     |

![记录头信息](https://gitee.com/bruceyum/pictures/raw/master/pics/17075b82cb070959)

**4.真实数据**

对于 record_format_demo 表来说， 记录的真实数据 除了 c1 、 c2 、 c3 、 c4 这几个我们自己定义的列的数据以外， MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ），具体的列如下：

| 列名        | 是否必须 | 占用空间 | 描述                   |
| ----------- | -------- | -------- | ---------------------- |
| DB_ROW_ID   | 否       | 6 字节   | 行ID，唯一标识一条记录 |
| DB_TRX_ID   | 是       | 6 字节   | 事务ID                 |
| DB_ROLL_PTR | 是       | 7 字节   | 回滚指针               |

 InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键。

![image_1c9h256f9nke14311adhtu61ie2dn.png-92kB](https://gitee.com/bruceyum/pictures/raw/master/pics/169710e973b70372)

对于 ***CHAR(M)*** 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。



### 2、Redundant行格式

 Redundant 行格式是 MySQL5.0 之前用的一种行格式，这里就不多介绍了。

![image_1c9h896lcuqi16081qub1v8c12jkft.png-36.2kB](https://gitee.com/bruceyum/pictures/raw/master/pics/169710e99a69ba3d)



### 3、行溢出数据

 VARCHAR(M) 类型的列最多可以占用 65535 个字节。其中的 M 代表该类型最多存储的字符数量，如果我们使用 ascii 字符集的话，一个字符就代表一个字节。 MySQL 对一条记录占用的最大存储空间是有限制的，除了 BLOB 或者 TEXT 类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。因为除了存储 VARCHAR(M) 字段值，一条记录中还需要存储变成字段列表，NULL值列表，记录头等数据，所以VARCHAR(M) 类型的字段并不能存储 65535 字节。

 MySQL 中磁盘和内存交互的基本单位是 页 ，也就是说 MySQL 是以 页 为基本单位来管理存储空间的，我们的记录都会被分配到某个 页 中存储。而一个页的大小一般是 16KB ，也就是 16384 字节，而一个 VARCHAR(M) 类型的列就最多可以存储 65532 个字节，这样就可能造成一个页存放不了一条记录。***TEXT***、***BLOB*** 类型的列在存储数据非常多的时候也会发生 行溢出 。

 MySQL 中规定一个页中至少存放两行记录，页本身要记录一些元数据，行本身也有元数据，除了这些元数据外还有非变长字段占用空间。一条记录的某些列中存储的数据占用的字节数超出页所能承载的数据时，该列就可能成为 溢出列 。

在 Compact 和 Redundant 行格式中，对于占用存储空间非常大的列，在 记录的真实数据 处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后 记录的真实数据 处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：

![image_1d48e3imu1vcp5rsh8cg0b1o169.png-149kB](https://gitee.com/bruceyum/pictures/raw/master/pics/169710e9aab47ea5)



### 4、Dynamic/Compressed

 Dynamic 和 Compressed 行格式，我现在使用的 MySQL 版本是 5.7 ，它的默认行格式就是 Dynamic ，这两种行格式类似于 COMPACT行格式 ，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

另外， Compressed 行格式会采用压缩算法对页面进行压缩。

![image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB](https://gitee.com/bruceyum/pictures/raw/master/pics/169710e9b2c2b71e)

 Compressed 行格式和 Dynamic 不同的一点是， Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间。

## InnoDB数据页结构

### 1、数据页结构概览

 页 是 InnoDB 管理存储空间的基本单位，一个页的大小一般是 16KB 。 InnoDB 为了不同的目的而设计了许多种不同类型的 页 ，比如存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 INODE 信息的页，存放 undo 日志信息的页等等。

数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：

<img src="https://gitee.com/bruceyum/pictures/raw/master/pics/16f13ee1e2dfac7c" width="400"/>

| 名称               | 中文名             | 占用空间大小 | 简单描述                 |
| ------------------ | ------------------ | ------------ | ------------------------ |
| File Header        | 文件头部           | 38 字节      | 页的一些通用信息         |
| Page Header        | 页面头部           | 56 字节      | 数据页专有的一些信息     |
| Infimum + Supremum | 最小记录和最大记录 | 26 字节      | 两个虚拟的行记录         |
| User Records       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| Free Space         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| Page Directory     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| File Trailer       | 文件尾部           | 8 字节       | 校验页是否完整           |

### 2、记录在页中的存储

在页的7个组成部分中，我们自己存储的记录会按照我们指定的 行格式 存储到 User Records 部分。但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

![image_1cosvi1in9st476cdqfki1n39m.png-133.8kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a95c0fe86555ed)

InnoDB定义了两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的 记录头信息 和8字节大小的一个固定的部分组成的。最小记录为 infimum ，最大记录为 supermum ，他们被单独放在一个称为 Infimum + Supremum 的部分。

页内的记录按照主键从小到大的顺序形成了一个单链表，每条记录的记录头中 next_record 指向下一条记录。规定 ***Infimum记录（也就是最小记录）*** 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 ***Supremum记录（也就是最大记录）*** 

![image_1cot1r96210ph1jng1td41ouj85c13.png-120.5kB](https://user-gold-cdn.xitu.io/2019/5/8/16a95c1084c440b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 3、Page Directory

页内的记录按照主键从小到大的顺序形成了一个单链表，同时 InnoDB 将页内的记录分组，将分组信息（槽）记录在Page Directory 中，这样我们就可以通过二分查找来查找页内的记录。

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。对于最小记录所在的分组只能有 ***1*** 条记录，最大记录所在的分组拥有的记录条数只能在 ***1~8*** 条之间，剩下的分组中记录的条数范围只能在是 ***4~8*** 条之间
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近 页 的尾部的地方，这个地方就是所谓的 Page Directory ，也就是 页目录 （此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为 槽 （英文名： Slot ），所以这个页面目录就是由 槽 组成的。

![image_1d6g64af2sgj1816ktl1q22dehp.png-189.1kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a95c10e3449897)

- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从 页目录 中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在 页目录 中新增一个 槽 来记录这个新增分组中最大的那条记录的偏移量。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

1. 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的 next_record 属性遍历该槽所在的组中的各个记录。

### 4、Page Header

Page Header用于存储**数据页**中存储的记录的状态信息，这个部分占用固定的 56 个字节：

| 名称              | 占用空间大小 | 描述                                                         |
| ----------------- | ------------ | :----------------------------------------------------------- |
| PAGE_N_DIR_SLOTS  | 2 字节       | 在页目录中的槽数量                                           |
| PAGE_HEAP_TOP     | 2 字节       | 还未使用的空间最小地址，也就是说从该地址之后就是 Free Space  |
| PAGE_N_HEAP       | 2 字节       | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
| PAGE_FREE         | 2 字节       | 第一个已经标记为删除的记录地址（各个已删除的记录通过 next_record 也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| PAGE_GARBAGE      | 2 字节       | 已删除记录占用的字节数                                       |
| PAGE_LAST_INSERT  | 2 字节       | 最后插入记录的位置                                           |
| PAGE_DIRECTION    | 2 字节       | 记录插入的方向：假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是 PAGE_DIRECTION 。 |
| PAGE_N_DIRECTION  | 2 字节       | 一个方向连续插入的记录数量：假设连续几次插入新记录的方向都是一致的， InnoDB 会把沿着同一个方向插入记录的条数记下来，这个条数就用 PAGE_N_DIRECTION 这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。 |
| PAGE_N_RECS       | 2 字节       | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| PAGE_MAX_TRX_ID   | 8 字节       | 修改当前页的最大事务ID，该值仅在二级索引中定义               |
| PAGE_LEVEL        | 2 字节       | 当前页在B+树中所处的层级                                     |
| PAGE_INDEX_ID     | 8 字节       | 索引ID，表示当前页属于哪个索引                               |
| PAGE_BTR_SEG_LEAF | 10 字节      | B+树叶子段的头部信息，仅在B+树的Root页定义                   |
| PAGE_BTR_SEG_TOP  | 10 字节      | B+树非叶子段的头部信息，仅在B+树的Root页定义                 |

### 5、File Header

File Header 用于存储页本身的元数据，所有类型的页通用，这个部分占用固定的 38 个字节：

| 名称                             | 占用空间大小 | 描述                                                         |
| -------------------------------- | ------------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4 字节       | 页的校验和（checksum值）                                     |
| FIL_PAGE_OFFSET                  | 4 字节       | 页号， InnoDB 通过页号来可以唯一定位一个 页 。               |
| FIL_PAGE_PREV                    | 4 字节       | 上一个页的页号                                               |
| FIL_PAGE_NEXT                    | 4 字节       | 下一个页的页号                                               |
| FIL_PAGE_LSN                     | 8 字节       | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
| FIL_PAGE_TYPE                    | 2 字节       | 页的类型：                                                   |
| FIL_PAGE_FILE_FLUSH_LSN          | 8 字节       | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4 字节       | 页属于哪个表空间                                             |

多个页通过 FIL_PAGE_PREV 和 FIL_PAGE_NEXT 构成双向链表，并不是所有的页都有这两个属性。

![image_1ca00fhg418pl1f1a1iav1uo3aou9.png-90.9kB](https://user-gold-cdn.xitu.io/2019/5/8/16a95c10eb9d61ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

FIL_PAGE_TYPE

这个代表当前 页 的类型，我们前边说过， InnoDB 为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的 数据页 ，类型为FIL_PAGE_INDEX，也就是所谓的 索引页 。其实还有很多别的类型的页，具体如下表：

| 类型名称                | 十六进制 | 描述                            |
| ----------------------- | -------- | ------------------------------- |
| FIL_PAGE_TYPE_ALLOCATED | 0x0000   | 最新分配，还没使用              |
| FIL_PAGE_UNDO_LOG       | 0x0002   | Undo日志页                      |
| FIL_PAGE_INODE          | 0x0003   | 段信息节点                      |
| FIL_PAGE_IBUF_FREE_LIST | 0x0004   | Insert Buffer空闲列表           |
| FIL_PAGE_IBUF_BITMAP    | 0x0005   | Insert Buffer位图               |
| FIL_PAGE_TYPE_SYS       | 0x0006   | 系统页                          |
| FIL_PAGE_TYPE_TRX_SYS   | 0x0007   | 事务系统数据                    |
| FIL_PAGE_TYPE_FSP_HDR   | 0x0008   | 表空间头部信息                  |
| FIL_PAGE_TYPE_XDES      | 0x0009   | 扩展描述页                      |
| FIL_PAGE_TYPE_BLOB      | 0x000A   | 溢出页                          |
| FIL_PAGE_INDEX          | 0x45BF   | 索引页，也就是我们所说的 数据页 |

### 6、File Trailer

InnoDB 以页为单位从磁盘读写数据，修改后的数据需要同步到磁盘中。为保证从内存中同步到磁盘的页的完整性，在 File Header 和 File Trailer 都会存储页中数据的 校验和 和页面最后修改时对应的 LSN 值，如果首部和尾部的校验和和 LSN 值校验不成功的话，就说明同步过程出现了问题。

## InnoDB 表空间

### 1、表空间概述

从 InnoDB 存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。

![image-20210802103510659](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210802103510659.png)

### 2、区/段

1.**区的概念**

我们每向表中插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的 B+ 树的节点中插入数据。而 B+ 树的每一层中的页都会形成一个双向链表，如果是以 页 为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。当我们进行范围查找时，如果两个页面物理位置较远就会产生很多随机I/O。

为了范围查找时能够有更好的性能，MySQL 引入了 区 （ extent ）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照 区 为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。这样页和页之间物理位置就会更多的连续性，随机I/O就会更少。

对于16KB的页来说，连续的64个页就是一个 区 ，也就是说一个区默认占用1MB空间大小。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。

![image_1crjo0hl4q8u1dkdofe187b10fa9.png-105.2kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a739f33df9307a)

- 第一个组最开始的3个页面的类型是固定的，也就是说 extent 0 这个区最开始的3个页面的类型是固定的，分别是：
  -  FSP_HDR 类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的 区 ，也就是 extent 0  ~  extent 255 这256个区的属性，整个表空间只有一个 FSP_HDR 类型的页面。
  -  IBUF_BITMAP 类型：这个类型的页面是存储本组所有的区的所有页面关于 INSERT BUFFER 的信息。
  -  INODE 类型：这个类型的页面存储了许多称为 INODE 的数据结构。
- 其余各组最开始的2个页面的类型是固定的，也就是说 extent 256 、 extent 512 这些区最开始的2个页面的类型是固定的，分别是：
  -  XDES 类型：全称是 extent descriptor ，用来登记本组256个区的属性，也就是说对于在 extent 256 区中的该类型页面存储的就是 extent 256  ~  extent 511 这些区的属性，对于在 extent 512 区中的该类型页面存储的就是 extent 512  ~  extent 767 这些区的属性。上边介绍的 FSP_HDR 类型的页面其实和 XDES 类型的页面的作用类似，只不过 FSP_HDR 类型的页面还会额外存储一些表空间的属性。
  -  IBUF_BITMAP 类型：存储本组所有的区的所有页面关于 INSERT BUFFER 的信息。

**2.段的概念**

但是 MySQL 索引叶子节点存储用户记录，而内部节点存储目录项记录，如果着两种页面混合存储的话，在方位查找时又会产生很多随机 I/O，所以MySQL 引入了 段 （ segment ）的概念，存放叶子节点的区的集合就算是一个 段 （ segment ），存放非叶子节点的区的集合也算是一个 段 。段是某些零散的页面以及一些完整的区的集合。

默认情况下一个使用 InnoDB 存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。MySQL 提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。

- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
- 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。

**3.区链表**

这些区大体上可以分为4种类型：处于 FREE 、 FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，算是直属于表空间；而处于 FSEG 状态的区是附属于某个段的。

- 空闲的区：现在还没有用到这个区中的任何页面。
- 有剩余空间的碎片区：表示碎片区中还有可用的页面。
- 没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。
- 附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。

为了方便管理这些区，MySQL 设计了一个称为 XDES Entry 的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个 XDES Entry 结构： Segment ID （8字节）， List Node （12字节）， State （4字节）， Page State Bitmap （16字节）

![image_1crre79uq9971bsdj9s1i0j11en8a.png-96.2kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a739f343654829)



表空间是由若干个区组成的，每个区都对应一个 XDES Entry 的结构，直属于表空间的区对应的 XDES Entry 结构可以分成 FREE 、 FREE_FRAG 和 FULL_FRAG 这3个链表；每个段可以附属若干个区，每个段中的区对应的 XDES Entry 结构可以分成 FREE 、 NOT_FULL 和 FULL 这3个链表。每个链表都对应一个 List Base Node 的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。

**4.INODE Entry**

段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成，每个段都定义了一个 INODE Entry 结构来记录一下段中的属性。

![image_1crrju0cnji91a2fhv91ijb15hgb1.png-111.4kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a739f4087c4a56)

###  3、FSP_HDR 类型



![image_1crmfvigk938c8h1hahglr15329.png-146.8kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a739f4733af475)

File Space Header部分

| 名称                                      | 占用空间大小 | 描述                                                         |
| ----------------------------------------- | ------------ | ------------------------------------------------------------ |
| `Space ID`                                | `4`字节      | 表空间的ID                                                   |
| `Not Used`                                | `4`字节      | 这4个字节未被使用，可以忽略                                  |
| `Size`                                    | `4`字节      | 当前表空间占有的页面数                                       |
| `FREE Limit`                              | `4`字节      | 尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表 |
| `Space Flags`                             | `4`字节      | 表空间的一些占用存储空间比较小的属性                         |
| `FRAG_N_USED`                             | `4`字节      | FREE_FRAG链表中已使用的页面数量                              |
| `List Base Node for FREE List`            | `16`字节     | FREE链表的基节点                                             |
| `List Base Node for FREE_FRAG List`       | `16`字节     | FREE_FRAG链表的基节点                                        |
| `List Base Node for FULL_FRAG List`       | `16`字节     | FULL_FRAG链表的基节点                                        |
| `Next Unused Segment ID`                  | `8`字节      | 当前表空间中下一个未使用的 Segment ID                        |
| `List Base Node for SEG_INODES_FULL List` | `16`字节     | SEG_INODES_FULL链表的基节点                                  |
| `List Base Node for SEG_INODES_FREE List` | `16`字节     | SEG_INODES_FREE链表的基节点                                  |

List Base Node for SEG_INODES_FULL List 和 List Base Node for SEG_INODES_FREE List

每个段对应的 INODE Entry 结构会集中存放到一个类型为 INODE 的页中，如果表空间中的段特别多，则会有多个 INODE Entry 结构，可能一个页放不下，这些 INODE 类型的页会组成两种列表：

-  SEG_INODES_FULL 链表，该链表中的 INODE 类型的页面都已经被 INODE Entry 结构填充满了，没空闲空间存放额外的 INODE Entry 了。
-  SEG_INODES_FREE 链表，该链表中的 INODE 类型的页面仍有空闲空间来存放 INODE Entry 结构。

### 4、XDES 类型

![image_1cs3vmoii1h971aje1iveack1l109.png-149.5kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a739f475c0ec2a)

###  5、IBUF_BITMAP 类型

每个分组的第二个页面的类型都是 IBUF_BITMAP ，这种类型的页里边记录了一些有关 Change Buffer 信息。

###  6、INODE 类型

 InnoDB 的大叔为每个索引定义了两个段，而且为某些特殊功能定义了些特殊的段。为了方便管理，他们又为每个段设计了一个 INODE Entry 结构，这个结构中记录了关于这个段的相关属性。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/16ef3a8df380813e)

从图中可以看出，一个 INODE 类型的页面是由这几部分构成的：

| 名称                            | 中文名       | 占用空间大小 | 简单描述                                   |
| ------------------------------- | ------------ | ------------ | ------------------------------------------ |
| `File Header`                   | 文件头部     | `38`字节     | 页的一些通用信息                           |
| `List Node for INODE Page List` | 通用链表节点 | `12`字节     | 存储上一个INODE页面和下一个INODE页面的指针 |
| `INODE Entry`                   | 段描述信息   | `16320`字节  |                                            |
| `Empty Space`                   | 尚未使用空间 | `6`字节      | 用于页结构的填充，没啥实际意义             |
| `File Trailer`                  | 文件尾部     | `8`字节      | 校验页是否完整                             |

还是为了方便管理这些 INODE 类型的页面， InnoDB 将这些 INODE 类型的页面串联成两个不同的链表，在File Space Header 里面存放着两个链表的头节点地址：

-  SEG_INODES_FULL 链表：该链表中的 INODE 类型的页面中已经没有空闲空间来存储额外的 INODE Entry 结构了。
-  SEG_INODES_FREE 链表：该链表中的 INODE 类型的页面中还有空闲空间来存储额外的 INODE Entry 结构了。

系统表空间

系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。

![image_1csbied27ohe1rgg32gquulplm.png-147.4kB](https://gitee.com/bruceyum/pictures/raw/master/pics/16a739f4911220d8)

系统表空间和独立表空间的前三个页面（页号分别为 0 、 1 、 2 ，类型分别是 FSP_HDR 、 IBUF_BITMAP 、 INODE ）的类型是一致的，只是页号为 3 ～ 7 的页面是系统表空间特有的。除了这几个记录系统属性的页面之外，系统表空间的 extent 1 和 extent 2 这两个区，也就是页号从 64 ~ 191 这128个页面被称为 Doublewrite buffer ，也就是双写缓冲区。

| 页号 | 页面类型  | 英文描述               | 描述                        |
| ---- | --------- | ---------------------- | --------------------------- |
| `3`  | `SYS`     | Insert Buffer Header   | 存储Insert Buffer的头部信息 |
| `4`  | `INDEX`   | Insert Buffer Root     | 存储Insert Buffer的根页面   |
| `5`  | `TRX_SYS` | Transction System      | 事务系统的相关信息          |
| `6`  | `SYS`     | First Rollback Segment | 第一个回滚段的页面          |
| `7`  | `SYS`     | Data Dictionary Header | 数据字典头部信息            |

### 7、InnoDB数据字典

每当我们向一个表中插入一条记录的时候，MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+ 树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的元数据，这些数据都存储在InnoDB 的数据字典中。InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些 元数据 ，这些表统称为数据字典

| 表名               | 描述                                                       |
| ------------------ | ---------------------------------------------------------- |
| `SYS_TABLES`       | 整个InnoDB存储引擎中所有的表的信息                         |
| `SYS_COLUMNS`      | 整个InnoDB存储引擎中所有的列的信息                         |
| `SYS_INDEXES`      | 整个InnoDB存储引擎中所有的索引的信息                       |
| `SYS_FIELDS`       | 整个InnoDB存储引擎中所有的索引对应的列的信息               |
| `SYS_FOREIGN`      | 整个InnoDB存储引擎中所有的外键的信息                       |
| `SYS_FOREIGN_COLS` | 整个InnoDB存储引擎中所有的外键对应列的信息                 |
| `SYS_TABLESPACES`  | 整个InnoDB存储引擎中所有的表空间信息                       |
| `SYS_DATAFILES`    | 整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息 |
| `SYS_VIRTUAL`      | 整个InnoDB存储引擎中所有的虚拟生成列的信息                 |

其中 SYS_TABLES 、 SYS_COLUMNS 、 SYS_INDEXES 、 SYS_FIELDS 这四个表尤其重要，称之为基本系统表（basic system tables）。只要有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。那这4个表的元数据去哪里获取呢？这4个表的元数据，就是它们有哪些列、哪些索引等信息硬编码到代码中，记录在 Data Dictionary Header 中

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/16efe1e5a01aeac9)