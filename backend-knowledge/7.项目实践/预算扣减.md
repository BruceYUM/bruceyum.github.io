1、预算管理模块
背景描述：
在现今电子商务场景下，预算管理在很多场景下都有广泛应用，比如营销奖品，
积分、红包的发放、商品库存管理等。
预算管理要求消耗的物品的数量能够按照预算库存进行消耗，不能超额，尽可能
的保障预算的消耗率。
大规模请求量以及分布式环境下，预算管理问题更加突出，如果预算控制不合理，
则会出现物品超发或是预算消耗率不高的情况，
超发会导致直接的资金损失出现；预算消耗率不高则会导致商品无法卖出、奖品
无法发放等问题，从而导致间接的资金损失。

不同的业务方，他们有各自的资源库存需要进行管理；

DDD 领域驱动

实体：Budget
id，
name,
description，
count，
delete_falg,
ext_params,
creat_time,
update_time,


1. 业务：
//超发，消耗率
1）Redis LUA脚本：原子操作扣减预算
2）Redis 原子自增，如果多个请求同步减预算，需要进行补偿逻辑；
幂等

https://blog.csdn.net/weixin_34221904/article/details/101690119

https://www.cnblogs.com/xiaoliangge/p/11573712.html

https://www.pianshen.com/article/9955789339/

https://blog.csdn.net/gxl1989225/article/details/84912234

https://www.jianshu.com/p/76bc0e963172

https://www.wwwbuild.net/gh_cc64446f0d6a/14029.html

https://www.freesion.com/article/2537389263/

2. 高并发：
//分布式集群
//缓存：缓存雪崩，缓存击穿，缓存穿透，Redis分库
//异步：MQ，消息重复，幂等，丢失，堆积；
数据一致性？分布式事务？

3. 可用性：
//负载均衡
//限流&降级&熔断&隔离：Sentinel
//监控告警：
//异地多活：


4. 安全
恶意请求


```java

public class Budget{
@Autowired
private JedisCluster jedisCluster;

@Autowire
private Producer producer;

@Autowire
private BudgetDao budgetDao;

/**
* 扣减预算：集群/缓存/异步
* @param consumption 当前需要扣减的消耗量
* @return 预算的扣减是否成功
*/
public boolean budgetDeduct(int consumption){
    //从缓存获取当前积分预算，检查积分预算不足,则返回失败
    String key = "budget:{budgetId}";
    String value = jedisCluster.get(key);
    if (StringUtils.isBlank(value)) {
        return false;
    }
    Integer budget = Integer.valueOf(value);
    if (budget < consumption) {
        return false;
    }

    //LUA 自增
    Long newBudget = jedisCluster.incrBy(key, -consumption);
    if (newSBudget >= 0) {
        // 向 MQ 发消息,  对 MySQL 进行减库存，减少响应时间
        Message msg = new Message("budget", "integralId", String.valueOf(consumption).getBytes(RemotingHelper.DEFAULT_CHARSET));
        SendResult sendResult = producer.send(msg);
    }
    
    return true;
}

/**
 * 添加预算
 * @param id 预算ID
 * @param num 新增预算数量
 */
public void addBudget(String budgetId, int num){
    
    budgetDao.save(budgetId, num);

    String value = jedisCluster.get("budgetId:"+budgetId);
    if(StringUtils.isBlank(value)){
        jedisCluster.set("budgetId:" + budgetId, String.valueOf(num));
    }else{
        jedisCluster.incrBy("budgetId:"+budgetId, num);
    }
}

}

 /**
     * 执行扣库存的脚本
     */
    public static final String STOCK_LUA;

    static {
        /**
         *
         * @desc 扣减库存Lua脚本
         * 库存（stock）-1：表示不限库存
         * 库存（stock）0：表示没有库存
         * 库存（stock）大于0：表示剩余库存
         *
         * @params 库存key
         * @return
         *      -3:库存未初始化
         *      -2:库存不足
         *      -1:不限库存
         *      大于等于0:剩余库存（扣减之后剩余的库存）
         *      redis缓存的库存(value)是-1表示不限库存，直接返回1
         */
        StringBuilder sb = new StringBuilder();
        sb.append("if (redis.call('exists', KEYS[1]) == 1) then");
        sb.append("    local stock = tonumber(redis.call('get', KEYS[1]));");
        sb.append("    local num = tonumber(ARGV[1]);");
        sb.append("    if (stock == -1) then");
        sb.append("        return -1;");
        sb.append("    end;");
        sb.append("    if (stock >= num) then");
        sb.append("        return redis.call('incrby', KEYS[1], 0 - num);");
        sb.append("    end;");
        sb.append("    return -2;");
        sb.append("end;");
        sb.append("return -3;");
        STOCK_LUA = sb.toString();
    }
    
```