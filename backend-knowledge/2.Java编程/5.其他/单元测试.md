## 1 单测概述

### 1.1 单测定义

测试类型：单元测试、增量测试、集成测试、回归测试、冒烟测试、系统测试

单元测试：一个单元测试是一段自动化的代码，这段代码调用被测试的工作单元，之后对这个单元的单个最终结果的某些假设进行检验。单元测试几乎都是用单元测试框架编写的。单元测试容易编写，能快速运行。一般是类级别的，通常是方法级别的。每个测试用例通常只验证一个方法或一个类的功能，不负责检查跨类或者跨系统的交互；

特征：自动化的，可重复执行；很容易实现；第二天还有意义；任何人都应该能一键运行它；运行速度应该很快；结果应该是稳定的(如果运行实现没有修改的话，多次运行一个测试应该总是返回同样的结果)；应该能完全控制被测试的单元；应该完全隔离(独立于其他测试的运行)；如果失败了，应该很容易发现什么是期待的结果，进而定位问题所在

集成测试：集成测试是对一个工作单元进行测试，这个测试对被测试工作单元没有完全的控制，并使用该单元的一个或多个真实依赖物，例如时间、网络、数据库、线程或者随机数产生器等。

集成测试的测试粒度比单元测试的粗，例如验证整个API服务或RPC服务的功能是否符合预期。由于要启动整个服务，会对外界环境（如数据库、Apollo配置）有比较强的依赖，有些应用可能还需要把包部署到外部容器才能进行测试。

特征：依赖外部服务；运行速度不快，结果不稳定；一次测试的东西太多了

### 1.2 单测意义

不啰嗦，反正就是好

### 1.3 单测规范

1、参考[阿里巴巴Java开发手册(终极版)](https://doc.myoas.com/pages/viewpage.action?pageId=333837482&preview=/333837482/335218651/阿里巴巴Java开发手册(终极版).pdf&fileGuid=pQxrWxKQXkPRvkqV)单元测试部分；

2、参考[单测准则 ](https://github.com/yangyubo/zh-unit-testing-guidelines/blob/master/readme.rst?fileGuid=pQxrWxKQXkPRvkqV)

1. 保持单元测试小巧, 快速；2. 单元测试应该是全自动且无交互

2. 让单元测试很容易跑起来；4. 对测试进行评估

3. 立即修正失败的测试；6. 把测试维持在单元级别

4. 由简入繁；8. 保持测试的独立性

5. Keep tests close to the class being tested；10. 合理的命名测试用例

6. 只测公有接口；12. 看成是黑盒

7. 看成是白盒；14. 芝麻函数也要测试

8. 先关注执行覆盖率；16. 覆盖边界值

9. 提供一个随机值生成器；18. 每个特性只测一次

10. 使用显式断言20. 提供反向测试

11. 代码设计时谨记测试22. 不要访问预设的外部资源

12. 权衡测试成本；24. 安排测试优先次序

13. 测试代码要考虑错误处理；26. 写测试用例重现 bug

14. 了解局限

3、评价指标

| 项目 | 平均代码行覆盖率 | 平均代码分支覆盖率 | 新增代码覆盖率 |
| :--- | :--------------- | :----------------- | :------------- |
|      |                  |                    |                |

## 2单测框架

### 2.1JUnitVS TestNG

我们用得最多的基本单元测试框架是Junit和TestNG，下面对这两个工具做个对比。

|        | 注解 | 异常测试 | 忽略测试 | 超时测试 | 套件测试 | 分组 | 参数化(单值) | 参数化(对象) | 依赖测试 | 并发测试 |
| :----: | :--- | :------: | :------- | :------: | :------- | :--: | :----------- | :----------: | :------- | :------: |
| TestNG | Y    |    Y     | Y        |    Y     | Y        |  Y   | Y            |      Y       | Y        |    Y     |
| Junit4 | Y    |    Y     | Y        |    Y     | Y        |  N   | Y            |      N       | N        |    N     |

### 2.2 JUnit注解支持

|                     描述                     | JUnit 4                                     |                        TestNG                         |
| :------------------------------------------: | :------------------------------------------ | :---------------------------------------------------: |
|                   测试注解                   | @Test                                       |                         @Test                         |
|        在套件中的所有测试运行之前运行        | 未实现                                      |                     @BeforeSuite                      |
|        在套件中的所有测试运行之后运行        | 未实现                                      |                      @AfterSuite                      |
|                 测试之前运行                 | 未实现                                      |                      @BeforeTest                      |
|                 测试之后运行                 | 未实现                                      |                      @AfterTest                       |
| 在调用属于任何这些组的第一个测试方法之前运行 | 未实现                                      |                     @BeforeGroups                     |
| 在调用属于任何这些组的第一个测试方法之后运行 | 未实现                                      |                     @AfterGroups                      |
|     在调用当前类的第一个测试方法之前运行     | @BeforeClass                                |                     @BeforeClass                      |
|     在调用当前类的第一个测试方法之后运行     | @AfterClass                                 |                      @AfterClass                      |
|            在每个测试方法之前运行            | @Before                                     |                     @BeforeMethod                     |
|            在每个测试方法之后运行            | @After                                      |                     @AfterMethod                      |
|                   忽略测试                   | @ignore                                     |                  @Test(enbale=false)                  |
|                  预期的异常                  | @Test(expected = ArithmeticException.class) | @Test(expectedExceptions = ArithmeticException.class) |
|                   超时测试                   | @Test(timeout = 1000)                       |                 @Test(timeout = 1000)                 |
|                  参数化测试                  | @RunWith和@Parameter联合                    |                     @DataProvider                     |

通过上面的对比可以看出，TestNG在参数化测试、依赖测试、套件测试、分组测试、并发测试等方面都比Junit4强，同时，TestNG涵盖了JUnit4的全部功能。但是JUnit通过stater自动引入不需要，不需要再单独引入依赖，且功能足够。

详细使用参考：[https://www.w3cschool.cn/junit/](https://www.w3cschool.cn/junit/?fileGuid=pQxrWxKQXkPRvkqV)

### **2.3****Mockito****介绍**

Mock的使用场景：

* 1. 外部依赖的应用的调用，比如WebService等服务依赖。
* 2. DAO层（访问MySQL、MongoDB、Redis底层存储）的调用等。
* 3. 系统间异步交互通知消息。 
* 4. methodA里面调用到的methodB。 
* 5. 一些应用里面自己的Class(abstract，final，static）、Interface、Annotation、Enum和Native等。 

目前市面上有很多mock工具，主要包括mockito、jmockit、easymock、PowerMock、Jmockit等，但用的较多的是mockito、jmockit。

JMockit包依赖在2020年之后就没有更新了，但Mockito目前仍在持续更新中，当前最新的版本是2021年1月更新的3.7.7版本。

Mockito有比较简洁的API，简单易学，可读性强。从Mockito2开始，Mockito支持了很多新特性以及新注解（所以依赖mockito2.x以上版本的需要java8及以上jdk方可），使用很便捷，spring-boot-starter-test包默认内置mockito，鉴于维护性和语言新特性的支持，个人建议使用Mockito作为单元测试的mock工具。

Mockito源码：

[https://github.com/mockito/mockito](https://github.com/mockito/mockito?fileGuid=pQxrWxKQXkPRvkqV)

Mockito2.x新特性介绍：

[https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2](https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2?fileGuid=pQxrWxKQXkPRvkqV)

Mockito的javadoc地址：

[https://javadoc.io/doc/org.mockito/mockito-core#](https://javadoc.io/doc/org.mockito/mockito-core#?fileGuid=pQxrWxKQXkPRvkqV)

### **2.4 Mockito的使用**

* 采用spy 或 @Spy 注解监控真实对象

在有需要的地方进行mock，否则走真实方法调用。

```java
@EnableAutoConfiguration
public class RSAUtilsWithSpyTest extends TestMain {
    /**
     * PropertyManager 有配置中心的注解 @HeraclesDynamicConfig
     * 所以，必须要启动spring容器，并启动配置中心:
     */
    @Autowired
    private PropertyManager propertyManager;
    
    /**
     * 采用静态方法{@link Mockito#spy(Object)}打桩
     */
    @Test
    public void testPublicEncrypt() throws Exception {
        PropertyManager spy = spy(propertyManager);
        //只对getRsaPublicKey()方法进行mock，其他方法不变
        Mockito.when(spy.getRsaPublicKey()).thenReturn("test2");
        String rsaPublicKey = propertyManager.getRsaPublicKey();
        //被mock的方法输出预期值 test2
        System.out.println("res:" + rsaPublicKey);
        String privateKey = propertyManager.getRsaPrivateKey();
        //输出配置中心配置值
        System.out.println("res:" + privateKey);
    }
}
```

除了采用静态方法spy以外，还可以通过采用注解的方式：

```java
@EnableAutoConfiguration
public class RSAUtilsWithSpyTest extends TestMain {
   
    @Autowired
    @Spy
    private PropertyManager propertyManager;
    
    private AutoCloseable autoCloseable;
    @BeforeClass
    public void initMock() {
        autoCloseable = MockitoAnnotations.openMocks(this);
    }
    @AfterClass
    public void close() throws Exception {
        autoCloseable.close();
    }
    /**
     * 采用@Spy注解打桩
     */
    @Test
    public void test1() {
        //调用getRsaPublicKey()方法则返回test2
        Mockito.when(propertyManager.getRsaPublicKey()).thenReturn("test2");
        String rsaPublicKey = propertyManager.getRsaPublicKey();
        //输出预期值 test2
        System.out.println("res:" + rsaPublicKey);
        String privateKey = propertyManager.getRsaPrivateKey();
        //输出配置中心配置值
        System.out.println("res:" + privateKey);
    }
}
```

结果示例：
![图片](https://odocs.myoas.com/uploader/f/jv3hVM5vI4Cjuycg.png?fileGuid=pQxrWxKQXkPRvkqV)

**注：使用@Spy注解需要设置（同时保留spring自动注入的注解@Autowired）**

```plain
MockitoAnnotations.openMocks(this)
```

此关键在于初始化被Mockito注解修饰的变量，只有这样才能是注解生效。Mockito官网有关于[MockitoAnnotations的说明](https://javadoc.io/static/org.mockito/mockito-core/3.7.7/org/mockito/MockitoAnnotations.html?fileGuid=pQxrWxKQXkPRvkqV)：
![图片](https://odocs.myoas.com/uploader/f/RQ2Wk0AoPCOxoc0H.jpg?fileGuid=pQxrWxKQXkPRvkqV)

一般普遍做法是在测试类中加：

```java
private AutoCloseable autoCloseable;
@BeforeClass
public void initMock() {
autoCloseable = MockitoAnnotations.openMocks(this);
}
@AfterClass
public void close() throws Exception {
autoCloseable.close();
}
```

如果不设置则会抛出异常：

![图片](https://odocs.myoas.com/uploader/f/yq7RiV3kWoZDheAp.png?fileGuid=pQxrWxKQXkPRvkqV)

**除了@Spy注解需要如此设置，@Mock、****@Captor、@InjectMocks等注解都需要。**

* @Mock 注解 模拟对象

对整个class进行mock

```java
@EnableAutoConfiguration
public class RSAUtilsWithMockTest extends TestMain {

@Mock
private PropertyManager propertyManager;
private AutoCloseable autoCloseable;
@BeforeClass
public void initMock() {
autoCloseable = MockitoAnnotations.openMocks(this);
}
@AfterClass
public void close() throws Exception {
autoCloseable.close();
}
/**
* 采用@Mock注解mock实例
*/
@Test
public void mock_test() {
//调用getRsaPublicKey()方法则返回test2
Mockito.when(propertyManager.getRsaPublicKey()).thenReturn("test2");
String rsaPublicKey = propertyManager.getRsaPublicKey();
//输出预期值 test2
System.out.println("res:" + rsaPublicKey);
String privateKey = propertyManager.getRsaPrivateKey();
//输出null值
System.out.println("res:" + privateKey);
}
}
```

![图片](https://odocs.myoas.com/uploader/f/28evZUbsV4xhS1xL.png?fileGuid=pQxrWxKQXkPRvkqV)

spy 和 mock不同，不同点是：

1. spy 的参数是对象示例，mock 的参数是 class。
2. 被 spy 的对象，调用其方法时默认会走真实方法。mock 对象不会。

* 使用方法预期回调接口生成期望值（Answer结构）

```java
@Test
public void answerTest(){
when(mockList.get(anyInt())).thenAnswer(new CustomAnswer());
assertEquals("hello world:0",mockList.get(0));
assertEquals("hello world:999",mockList.get(999));
}
private class CustomAnswer implements Answer<String>{
@Override
public String answer(InvocationOnMock invocation) throws Throwable {
Object[] args = invocation.getArguments();
return "hello world:"+args[0];
}
}
```

* 重置Mock

```plain
@Test
public void reset_mock(){
List list = mock(List.class);
when(list.size()).thenReturn(10);
list.add(1);
assertEquals(10,list.size());
//重置mock，清除所有的互动和预设
reset(list);
assertEquals(0,list.size());
}
```

* verify验证

```java
@Test
public void mock_times() {
//调用getRsaPublicKey()方法则返回test2
Mockito.when(propertyManager.getRsaPublicKey()).thenReturn("test2");
String rsaPublicKey = propertyManager.getRsaPublicKey();
//输出预期值 test2
System.out.println("res:" + rsaPublicKey);
System.out.println("res:" +propertyManager.getRsaPublicKey());
Mockito.verify(propertyManager, Mockito.times(2)).getRsaPublicKey();
}
```

验证方法的调用次数，不过一般我们单元测试很少用到。

* mock模拟静态方法

如果要用mockito模拟静态方法，一是要保证mockito包版本在3.4.0以上，二是需要额外加mockito-inline依赖，如下：

```xml
<dependency>
<groupId>org.mockito</groupId>
<artifactId>mockito-inline</artifactId>
<version>3.7.7</version>
<scope>test</scope>
</dependency>
```

加好依赖后，通过*Mockito.mockStatic*来模拟静态方法。

```java
public class NumberValidatorStaticTest {
/**
* mock静态方法
*/
@Test
public void testStaticMethod() {
//未mock前返回true
Assert.assertTrue(NumberValidator.alwaysTrue());
System.out.println("res: " + NumberValidator.alwaysTrue());
//模拟返回false
try (MockedStatic mockedStatic = Mockito.mockStatic(NumberValidator.class)) {
mockedStatic.when(NumberValidator::alwaysTrue).thenReturn(false);
System.out.println("res: " + NumberValidator.alwaysTrue());
Assert.assertFalse(NumberValidator.alwaysTrue());
}
//mockStatic可用区外依然返回true
Assert.assertTrue(NumberValidator.alwaysTrue());
System.out.println("res: " + NumberValidator.alwaysTrue());
}
}
```

结果：
![图片](https://odocs.myoas.com/uploader/f/gbDQvWdFiyZFhk56.png?fileGuid=pQxrWxKQXkPRvkqV)

## 3 单测实践

### 3.1 单测范围

| **应用名**                                                   | **功能层**     | **是否需要单元测试** | **对应的包** | **目标覆盖率** |
| :----------------------------------------------------------- | :------------- | :------------------- | :----------- | :------------- |
| jits-**<br>jits-engine-<br>jits-open<br>jits-openlocal<br>jits-center<br>jits-rank<br>jits-user | **controller** | **是**               | ****         | **70%+**       |
|                                                              | **service**    | **是**               | ****         | **70%+**       |
|                                                              | **task**       | **是**               | ****         | **70%+**       |
|                                                              | util           | 是                   |              | 70%            |
|                                                              | dao            | 否                   |              |                |
|                                                              | domain         | 否                   |              |                |
|                                                              | facede         | 否                   |              |                |

旧代码：在Controller层可以采用集成测试（可以依赖Spring上下文环境）

service, task：不建议依赖Spring上下文环境，或者较少依赖Spring环境

Redis（Redis-Mock），MySQL(h2内存数据库)

### 3.2 单测隔离

1、Restlight

参考Restlight MockMvc：[http://cloud.oppoer.me/docsCenter/productdaea24db49901bd28f84b5534/docsDetail?fileId=dfec1df62af944ea9408ae9b291b77e7&aimpoint=1_Context_24](http://cloud.oppoer.me/docsCenter/productdaea24db49901bd28f84b5534/docsDetail?fileId=dfec1df62af944ea9408ae9b291b77e7&aimpoint=1_Context_24&fileGuid=pQxrWxKQXkPRvkqV)

2、配置中心

1）SDK 升级到 2.30 及以上

2）修改 heracles.properties 配置文件，禁用远程加载

```plain
#从本地读取文件
heracles_enable_remote=false
heracles_download_dir=conf
#指定本地配置文件，以英文逗号分隔
heracles_conf_files=mysql.properties,dubbo.properties
```

3、HttpClient

使用Mockito或者WireMock

WireMock：[https://blog.csdn.net/dadiyang/article/details/85255262](https://blog.csdn.net/dadiyang/article/details/85255262?fileGuid=pQxrWxKQXkPRvkqV)

4、Dubbo

Mockito @MockBean @Mock

dubbo-rpc-mock(不推荐)：[http://cloud.oppoer.me/docsCenter/productca20742e89bad82c41439aa0e/docsDetail?fileId=8217b76204ec4c94938e4cbabb8ea2d5&aimpoint=_1](http://cloud.oppoer.me/docsCenter/productca20742e89bad82c41439aa0e/docsDetail?fileId=8217b76204ec4c94938e4cbabb8ea2d5&aimpoint=_1&fileGuid=pQxrWxKQXkPRvkqV)

基于动态代理的Dubbo Mock：[https://tech.youzan.com/ji-yu-dong-tai-dai-li-mock-dubbofu-wu-de-shi-xian-fang-an/](https://tech.youzan.com/ji-yu-dong-tai-dai-li-mock-dubbofu-wu-de-shi-xian-fang-an/?fileGuid=pQxrWxKQXkPRvkqV)

5、Redis

待完善

6、MySQL

待完善

### 3.3 单测覆盖

第一步：在父pom.xml中加入配置

```plain
<build>
        <plugins>
            <!--
             ... 其他插件 ...
            -->
 
           <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.19.1</version>
                <configuration>
                    <!-  注意这里一定要设置为false -->
                    <skipTests>false</skipTests>
                    <!-- 这里设置需要排除的test包下的哪些包路径下的用例不运行，比如一些启动spring容器的用例不运行 -->
                    <excludes>
                        <exclude>**/springtest/**</exclude>
                     </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-report-plugin</artifactId>
                <version>2.19.1</version>
                <configuration>
                    <aggregate>true</aggregate>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>0.8.5</version>
                <executions>
                    <execution>
                        <id>default-prepare-agent</id>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
```

第二步：新建一个单独的、空的测试module
因为jacoco要做聚合的话，需要新增单独的模块来承接，比如示例项目，新增一个空的模块  jits-demo-test

|- jits-demo

|- jits-demo-core

- pom.xml

|- jits-demo-dal

- pom.xml

|- jits-demo-domain

- pom.xml

|- jits-demo-facade

- pom.xml

|- jits-demo-rpc

- pom.xml

|- jits-demo-test

- pom.xml

- pom.xml

注意，新建的jits-demo-test模块确保在父pom.xml中有引入

第三步：在jits-demo-test模块中的pom.xml中配置以下内容：

```plain
<!-- 单元测试模块名称 -->
    <artifactId>jits-demo-test</artifactId>
 
    <!-- 把需要进行单元测试的各个模块依赖进来，这样就会对依赖进来的模块进行单元测试，并且把内容进行聚合输出 -->
    <dependencies>
        <dependency>
            <groupId>com.oppo.jits.demo</groupId>
            <artifactId>jits-demo-core</artifactId>
            <version>${parent.version}</version>
        </dependency>
        <dependency>
            <groupId>com.oppo.jits.demo</groupId>
            <artifactId>jits-demo-rpc</artifactId>
            <version>${parent.version}</version>
        </dependency>
    </dependencies>
 
    <build>
        <plugins>
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>0.8.5</version>
                <configuration>
                    <!-- 这里根据自己项目中的包路径，指定要针对哪些包下的类进行单元测试覆盖率扫描 -->
                    <includes>
                        <include>com/oppo/jits/rank/core/**</include>
                        <include>com/oppo/jits/rank/rpc/**</include>
                    </includes>
                    <!-- 这里根据自己项目中的包路径，指定要针对哪些包下的类是不需要进行单元测试覆盖率的，将其排除 -->
                    <excludes>
                        <exclude>**/contants/**</exclude>
                        <exclude>**/dto/**</exclude>
                        <exclude>**/entity/**</exclude>
                    </excludes>
                </configuration>
                <executions>
                    <execution>
                        <id>report-aggregate</id>
                        <phase>test</phase>
                        <goals>
                            <goal>report-aggregate</goal>
                        </goals>
                        <configuration>
                            <!-- <dataFile>target/jacoco.exec</dataFile>-->
                            <!-- 单元测试覆盖率报告输出路径 -->
                            <outputDirectory>../target/site/jacoco</outputDirectory>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
```

第四部：本地运行

运行命令：mvn  clean test -Dmaven.test.failure.ignore=true surefire-report:report-only -DalwaysGenerateSurefireReport=false  -Daggregate=true

第五步：持续集成-单元测试卡点

![图片](https://odocs.myoas.com/uploader/f/GUZ45RIUOS5K1KTl.png?fileGuid=pQxrWxKQXkPRvkqV)



