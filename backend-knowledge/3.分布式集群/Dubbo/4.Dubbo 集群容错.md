# Dubbo 集群容错

[toc]



## Cluster 层概述

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/cluster.jpg)

在微服务环境中，为了保证服务的高可用，很少会有单点服务出现，服务通常都是以集群的形式出现的。被调用的远程服务并不是每时每刻都保持良好状况，当某个服务调用出现异常时，如网络抖动、服务短暂不可用需要自动容错，或者只想本地测试、服务降级，需要 Mock 返回结果，就需要有一套集群容错机制。

Cluster 层的总体工作流程可以分为以下几步:

1） 生成Invoker对象。不同的 Cluster 实现会生成不同类型的 Clusterinvoker 对象并返回。然后调 ClusterInvoker 的 Invoker 方法，正式开始调用流程。
2） 获得可调用的服务列表。首先会做前置校验，检查远程服务是否已被销毁。然后通过 Directory#list 方法获取所有可用的服务列表。
3）接着使用 Router 接口处理该服务列表，根据路由规则过滤一部分服务，最终返回剩余的服务列表。
4）负载均衡。在第 2 步中得到的服务列表还需要通过不同的负载均衡策略选出一个服务，用作最后的调用。首先框架会根据用户的配置，调用 ExtensionLoader 获取不同负载均衡策略的扩展点实现。然后做一些后置操作，如果是异步调用则设置调用编号。接着调用子类实现的 dolnvoke 方法，子类会根据具体的负载均衡策略选出一个可以调用的服务。
5） RPC 调用。首先保存每次调用的 Invoker 到 RPC 上下文，并做 RPC 调用。然后处理调用结果，对于调用出现异常、成功、失败等情况，每种容错策略会有不同的处理方式。

## 容错机制

### 1、容错概述

Dubbo容错机制能增强整个应用的鲁棒性，容错过程对上层用户是完全透明的，Dubbo 中现有 Failover、Failfast、Failsafe、Fallback、Forking、Broadcast 等容错机制。容错的接口主要分为两大类，第一类是Cluster类，第二类是Clusterinvoker类。Cluster 和 Clusterinvoker 之间的关系也非常简单：Cluster 接口下面有多种不同的实现，每种实现中都需要实现接口的 join 方法，在方法中会 new 一个对应的 Clusterinvoker 实现。

![image-20210716112723490](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210716112723490.png)

| 机制名    | 机制简介                                                     |
| --------- | ------------------------------------------------------------ |
| Failover  | 当出现失败时，会重试其他服务器。用户可以通过 retries=2 设置重试次数。这是 Dubbo 的默认容错机制，会对请求做负载均衡。通常使用在读操作或幂等的写操作上，但重试会导致接口的延退增大，在下游机器负载已经达到极限时，重试容易加重下游服务的负载。 |
| Failfast  | 快速失败，当请求失败后，快速返回异常结果，不做任何重试。该容错机制会对请求做负载均衡，通常使用在非幂等接口的调用上。该机制受网络抖动的影响较大。 |
| Failsafe  | 当出现异常时，直接忽略异常。会对请求做负载均衡。通常使用在“佛系”调用场景，即不关心调用是否成功，并且不想抛异常影响外层调用，如某些不重要的日志同步，即使出现异常也无所谓 |
| Fallback  | 请求失败后，会自动记录在失败队列中，并由一个定时线程池定时重试，适用于一些异步或最终一致性的请求。请求会做负载均衡 |
| Forking   | 同时调用多个相同的服务，只要其中一个返回，则立即返回结果。用户可以配置forks=："最大并行调用数” 参数来确定最大并行调用的服务数量。通常使用在对接口实时性要求极高的调用上，但也会浪费更多的资源。 |
| Broadcast | 广播调用所有可用的服务，任意一个节点报错则报错。由于是广播，因此请求不需要做负载均衡。通常用于服务状态更新后的广播 |

### 2、Failover 策略

Cluster 接口上有 SPI 注解 @SPI(FailoverCluster.NAME), 即默认实现是 Failover。该策略的代码逻辑如下：
1) 校验。校验从 AbstractClusterlnvoker 传入的 Invoker 列表是否为空。
2) 获取配置参数。从调用 URL 中获取对应的 retries 重试次数。
3) 初始化一些集合和对象。用于保存调用过程中出现的异常、记录调用了哪些节点(这个会在负载均衡中使用，在某些配置下，尽量不要一直调用同一个服务)。
4) 使用 for 循环实现重试，for 循环的次数就是重试的次数。成功则返回，否则继续循环。如果 for 循环完，还没有一个成功的返回，则抛出异常，把 3) 中记录的信息抛出去。前 3 步都是做一些校验、数据准备的工作。第4步开始真正的调用逻辑。以下步骤是 for 循环中的逻辑：

- 校验。如果 for 循环次数大于 1，即有过一次失败，则会再次校验节点是否被销毁、传入的 Invoker 列表是否为空。
- 负载均衡。调用 select 方法做负载均衡，得到要调用的节点，并记录这个节点到步骤3的集合里，再把己经调用的节点信息放进RPC上下文中。
- 远程调用。调用 invoker#invoke 方法做远程调用，成功则返回，异常则记录异常信息，再做下次循环。

![image-20210716114347851](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210716114347851.png)

### 3、Failfast 策略

Failfast会在失败后直接抛出异常并返回，实现非常简单，步骤如下：
1） 校验。校验从AbstractClusterlnvoker传入的Invoker列表是否为空。
2） 负载均衡。调用select方法做负载均衡，得到要调用的节点。
3） 进行远程调用。在try代码块中调用invoker#invoke方法做远程调用。如果捕获到异常，则直接封装成RpcException抛出。

### 4、Failsafe 策略

Failsafe调用时如果出现异常，则会直接忽略。实现也非常简单，步骤如下：
1） 校验传入的参数。校验从AbstractClusterlnvoker传入的Invoker列表是否为空。
2） 负载均衡。调用select方法做负载均衡，得到要调用的节点。
3）远程调用。在try代码块中调用invoker#invoke方法做远程调用，“catch”到任何异常都直接“吞掉”，返回一个空的结果集。

### 5、Fallback 策略

Fallback如果调用失败，则会定期重试。FailbackClusterlnvoker 里面定义了一个 ConcurrentHashMap,专门用来保存失败的调用。另外定义了一个定时线程池，默认每5秒把所有失败的调用拿出来，重试一次。如果调用重试成功，则会从ConcurrentHashMap中移除。dolnvoke的调用逻辑如下：

1. 校验传入的参数。校验从 AbstractClusterlnvoker 传入的Invoker列表是否为空。
2. 负载均衡。调用 select 方法做负载均衡，得到要调用的节点。
3. 远程调用。在try代码块中调用 invoker#invoke 方法做远程调用，“catch” 到异常后直接把invocation保存到重试的 ConcurrentHashMap 中，并返回一个空的结果集。
4. 定时线程池会定时把 ConcurrentHashMap 中的失败请求拿出来重新请求，请求成功则从 ConcurrentHashMap中移除。如果请求还是失败，则异常也会被“catch”住，不会影响 ConcurrentHashMap 中后面的重试。

### 6、Available 策略

Available是找到第一个可用的服务直接调用，并返回结果。步骤如下：

1. 遍历从AbstractClusterlnvoker传入的Invoker列表，如果Invoker是可用的，则直接调用并返回。
2. 如果遍历整个列表还没找到可用的Invoker,则抛出异常。

### 7、Broadcast 策略

Broadcast会广播给所有可用的节点，如果任何一个节点报错，则返回异常。步骤如下：

1. 前置操作。校验从AbstractClusterlnvoker传入的Invoker列表是否为空；在RPC上下文中设置Invoker列表；初始化一些对象，用于保存调用过程中产生的异常和结果信息等。
2. 循环遍历所有Invoker,直接做RPC调用。任何一个节点调用出错，并不会中断整个广播过程，会先记录异常，在最后广播完成后再抛出。如果多个节点异常，则只有最后一个节点的异常会被抛出，前面的异常会被覆盖。

### 8、Forking 策略

Forking可以同时并行请求多个服务，有任何一个返回，则直接返回。相对于其他调用策略，Forking的实现是最复杂的。其步骤如下：

1. 准备工作。校验传入的Invoker列表是否可用；初始化一个Invoker集合，用于保存真正要调用的Invoker列表；从URL中得到最大并行数、超时时间。
2. 获取最终要调用的Invoker列表。假设用户设置最大的并行数为们 实际可以调用的最大服务数为 v。如果n < 0或n < v, 则说明可用的服务数小于用户的设置，因此最终要调用的 Invoker 能有 v 个；如果n<v, 则会循环调用负载均衡方法，不断得到可调用的Invoker, 加入步骤1中的 Invoker 集合里。
   这里有一点需要注意：在Invoker加入集合时，会做去重操作。因此，如果用户设置的负载均衡策略每次返回的都是同一个Invoker,那么集合中最后只会存在一个Invoker,也就是只会调用一个节点。
3. 调用前的准备工作。设置要调用的Invoker列表到RPC上下文；初始化一个异常计数器；初始化一个阻塞队列，用于记录并行调用的结果。
4. 执行调用。循环使用线程池并行调用，调用成功，则把结果加入阻塞队列；调用失败，则失败计数+1。如果所有线程的调用都失败了，即失败计数》所有可调用的Invoker时，则把异常信息加入阻塞队列。
   这里有一点需要注意：并行调用是如何保证个别调用失败不返回异常信息，只有全部失败才返回异常信息的呢？因为有判断条件，当失败计数N所有可调用的Invoker时，才会把异常信息放入阻塞队列，所以只有当最后一个Invoker也调用失败时才会把异常信息保存到阻塞队列，从而达到全部失败才返回异常的效果。
5. 同步等待结果。由于步骤4中的步骤是在线程池中执行的，因此主线程还会继续往下执行，主线程中会使用阻塞队列的poll(-超时时间“)方法，同步等待阻塞队列中的第一个结果，如果是正常结果则返回，如果是异常则抛出。

![image-20210716115016578](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210716115016578.png)



## 服务目录

### 1、服务目录概述

![directory-inherit-hierarchy](https://gitee.com/bruceyum/pictures/raw/master/pics/directory-inherit-hierarchy.png)

Directory是顶层的接口。AbstractDirectory封装了通用的实现逻辑。抽象类包含RegistryDirectory和StaticDirectory两个子类。下面分别介绍每个类的职责和工作：
1) AbstractDirectoryo封装了通用逻辑，主要实现了四个方法：检测Invoker是否可用，销毁所有Invoker, list方法，还留了一个抽象的doList方法给子类自行实现。list 方法是最主要的方法，用于返回所有可用的 list,逻辑分为两步：

- 调用抽象方法doList获取所有Invoker列表，不同子类有不同的实现；doList抽象方法是返回所有的Invoker列表，由于是抽象方法，子类继承后必须要有自己的实现。
- 遍历所有的router,进行Invoker的过滤，最后返回过滤好的Invoker列表。

2) RegistryDirectory属于Directory的动态列表实现，会自动从注册中心更新Invoker列表、配置信息、路由列表。
3) StaticDirectoryo Directory的静态列表实现，即将传入的Invoker列表封装成静态的Directory对象，里面的列表不会改变。因为Cluste「#join(Directopy〈T> directory)方法需要传入Directory对象，因此该实现主要使用在一些上层已经知道自己要调用哪些Invoker,只需要包装一个 Directory对象返回即可的场景。在ReferenceConfig#createProxy和RegistryDirectory#toMergeMethodInvokerMap 中使用了 Cluster#join 方法。StaticDirectory 的逻辑非常简单，在构造方法中需要传入Invoker列表，doList方法则直接返回初始化时传入的列表。

### 2、RegistryDirectory

RegistryDirectory 中有两条比较重要的逻辑线，第一条，框架与注册中心的订阅，并动态更新本地Invoker列表、路由列表、配置信息的逻辑；第二条，子类实现父类的 doList 方法。

**1.订阅与动态更新**
我们先看一下订阅和动态更新逻辑。这个逻辑主要涉及subscribe、notify、refreshinvoker三个方法，其余是一些数据转换的辅助类方法，如toConfigurators、 toRouters、subscribe是订阅某个URL的更新信息。Dubbo在引用每个需要RPC调用的Bean的时候，会调用directory. 

subscribe来订阅这个Bean的各种URL的变化(Bean的配置在配置中心中都是以URL的形式存放的)。这个方法比较简单，只有两行代码，仅仅使用registry.subscribe订阅。订阅发布在前面章节已经有了详细的讲解，因此不在此展开。

notify就是监听到配置中心对应的URL的变化，然后更新本地的配置参数。监听的URL
分为三类：配置configurators>路由规则router> Invoker列表。工作流程如下：
(1) 新建三个List,分别用于保存更新的Invoker URL、路由配置URL、配置URL。遍历监听返回的所有URL,分类后放入三个List中。
(2) 解析并更新配置参数。

- 对于router类参数，首先遍历所有router类型的URL,然后通过Router工厂把每个URL包装成路由规则，最后更新本地的路由信息。这个过程会忽略以empty开头的URL。
- 对于Configurator类的参数，管理员可以在dubbo-admin动态配置功能上修改生产者的参数，这些参数会保存在配置中心的configurators类目下。notify监听到URL配置参数的变化，会解析并更新本地的Configurator配置。
- 对于Invoker类型的参数，如果是empty协议的URL,则会禁用该服务，并销毁本地缓存的Invoker；如果监听到的Invoker类型URL都是空的，则说明没有更新，直接使用本地的老缓存；如果监听到的Invoker类型URL不为空，则把新的URL和本地老的URL合并，创建新的Invoker,找出差异的老Invoker并销毁。

**2.doList的实现**
notify 中更新的 Invoker 列表最终会转化为一个字典 Map<Stringj List<Invoker<T>>>methodlnvokerMap key是对应的方法名称，value 是整个 Invoker 列表。doList 的最终目标就是在字典里匹配出可以调用的Invoker列表，并返回给上层。其主要步骤如下：
1) 检查服务是否被禁用。如果配置中心禁用了某个服务，则该服务无法被调用。如果服务被禁用则会抛出异常。
2) 根据方法名和首参数匹配Invoker这是一个比较奇特的特性。根据方法名和首参数查找对应的Invoker列表，暂时没看到相关的应用场景。如果在这一步没有匹配到Invoker列表，则进入第3步。
3) 根据方法名匹配 Invoker 以方法名为 key 去 methodlnvokerMap 中匹配 Invoker 列表,如果还是没有匹配到，则进入第4步。
4) 根据"*”匹配 Invoker 用星号去匹配 Invoker 列表，如果还没有匹配到，则进入最后一步兜底操作。
5) 遍历 methodlnvokerMap, 找到第一个 Invoker 列表返回。如果还没有，则返回一个空列表。

## 服务路由

### 1、服务路由概述

通过 Directory 获取所有 Invoker 列表的时候，就会调用到本节的路由接口。路由接口会根据用户配置的不同路由策略对Invoker列表进行过滤，只返回符合规则的Invoker。例如：如果用户配置了接口 A的所有调用，都使用IP为192.168.1.22的节点，则路由会过滤其他的 Invoker, 只返回 IP 为 192.168.1.22 的 Invoker。

路由分为条件路由、文件路由、脚本路由，对应dubbo-admin中三种不同的规则配置方式。条件路由是用户使用Dubbo定义的语法规则去写路由规则;文件路由则需要用户提交一个文件,里面写着对应的路由规则，框架基于文件读取对应的规则；脚本路由则是使用JDK自身的脚本引擎解析路由规则脚本，所有JDK脚本引擎支持的脚本都能解析，默认是JavaScript。

![image-20210718142224553](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210718142224553.png)

RouterFactory 是一个SPI接口，没有设置默认值，但由于有@Adaptive("protocol")注解，因此它会根据URL中的protocol参数确定要初始化哪一个具体的Router实现。RouterFactory的实现类也非常简单，就是直接“new” 一个对应的Router并返回。例如：ConditionRouterFactory 直接"new” 并返回一个 ConditionRouter。当然，FileRouterFactory 除外，直接在工厂类中实现了所有逻辑。

![image-20210718142059425](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210718142059425.png)

### 2、条件路由

条件路由使用的是 condition://协议，URL 形式是”condition:// 0.0.0.0/com.fbo.BarService?category=routers&dynamic=false&rule=" + URL.encode(nhost = 10.20.153.10 => host = 10.20.153.11")。我们可以看到，最后的路由规则会用URL.encode进行编码。

| 参数名称                                                     | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| condition://                                                 | 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，必填 |
| 0.0.0.0                                                      | 表示对所有IP地址生效，如果只想对某个IP的生效，则填入具体IP   |
| com.fdo.BarService                                           | 表示只对指定服务生效，必填                                   |
| category=routers                                             | 表示该数据为动态配置类型，必填                               |
| dynamic=false                                                | 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填 |
| enabled=true                                                 | 覆盖规则是否生效，可不填，默认生效                           |
| force=false                                                  | 当路由结果为空时，是否强制执行，如果不强制执行，则路由结果为空的路由规则将自动失效，可不填，默认为 false |
| runtime=false                                                | 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，则必须设为 true |
| priority=l                                                   | 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，默认为0 |
| rule=URL.encode("host = 10.20.153.10 =>host = 10.20.153. 11") | 表示路由规则的内容，必填                                     |

条件路由的具体实现类是ConditionRouter, Dubbo会根据自定义的规则语法来实现路由规则。我们主要需要关注其构造方法和实现父类接口的route方法。

**1.ConditionRouter构造方法的逻辑**

ConditionRouterFactory在初始化ConditionRouter的时候，其构造方法中含有规则解析的逻辑。步骤如下：

1）根据URL的键rule获取对应的规则字符串。以 => 为界，把规则分成两段，前面部分为 whenRule, 即消费者匹配条件；后面部分为 thenRule, 即提供者地址列表的过滤条件。我们以代码清单7-8的规则为例，其会被解析为whenRule: method = find\* 和 thenRule: host =192.168.1.22。

2）分别解析两个路由规则。调用parseRule方法，通过正则表达式不断循环匹配 whenRule 和 thenRule 字符串。解析的时候，会根据 key-value 之间的分隔符对 key-value 做分类(如果 A=B, 则分隔符为 =)，支持的分隔符形式有：A=B、A&B、A!=B、A,B这4种形式。最终参数都会被封装成一个个 MatchPair 对象，放入 Map 中保存。Map的 key 是参数值，value 是 MatchPair 对象。若以代码清单7-8的规则为例，则会生成以 method 为 key 的when Map,以host 为 key 的 then Mapo value 则分别是包装了 find。和 192.168.1.22 的 MatchPair 对象。

MatchPair对象是用来做什么的呢？这个对象一共有两个作用。第一个作用是通配符的匹配和占位符的赋值。MatchPair对象是内部类，里面只有一个isMatch方法，用于判断值是否能匹配得上规则。规则里的$、\*等通配符都会在MatchPair对象中进行匹配。其中$支持protocok、username、password、host、port、path这几个动态参数的占位符。例如：规则中写了$protocol,则会自动从URL中获取protocol的值，并赋值进去。第二个作用是缓存规则。MatchPair 对象中有两个 Set 集合，一个用于保存匹配的规则，如=find\*；另一个则用于保存不匹配的规则，如 !=find* 这两个集合在后续路由规则匹配的时候会使用到。

**2.route方法的实现原理**

ConditionRouter 继承了 Router 接口，需要实现接口的 route 方法。该方法的主要功能是过滤出符合路由规则的Invoker列表，即做具体的条件匹配判断，其步骤如下：

1）校验。如果规则没有启用，则直接返回；如果传入的 Invoker 列表为空，则直接返回空；如果没有任何的whenRule 匹配，即没有规则匹配，则直接返回传入的 Invoker 列表；如果 whenRule 有匹配的，但是 thenRule 为空，即没有匹配上规则的 Invoker, 则返回空。

2）遍历 Invoker 列表，通过 thenRule 找出所有符合规则的 Invoker 加入集合。例如：匹配规则中的 method 名称和当前 URL 中的 method 是不是相等。

3）返回结果。如果结果集不为空，则直接返回；如果结果集为空，但是规则配置了 force=true, 即强制过滤，那么就会返回空结果集；非强制则不过滤，即返回所有 Invoker 列表。

## 负载均衡

### 1、负载均衡概述

**1.Abstractclusterinvoker **

在整个集群容错流程中，首先经过 Directory 获取所有 Invoker 列表，然后经过 Router 根据路由规则过滤Invoker, 最后幸存下来的 Invoker 还需要经过负载均衡这一关，选出最终要调用的 Invoker。所有的容错策略中的负载均衡都使用了抽象父类 Abstractclusterinvoker 中定义的 Invoker<T> select 方法，而并不是直接使用LoadBalance 方法。因为抽象父类在 LoadBalance 的基础上又封装了一些新的特性：

1）粘滞连接。Dubbo 中有一种特性叫粘滞连接，粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者“挂了”，再连接另一台。粘滞连接将自动开启延迟连接，以减少长连接数。
`<dubbo:protocol name=Hdubbo" sticky="true" />`

2）可用检测。Dubbo 调用的 URL 中，如果含有 cluster.availablecheck=false, 则不会检测远程服务是否可用，直接调用。如果不设置，则默认会开启检查，对所有的服务都做是否可用的检查，如果不可用，则再次做负载均衡。

3）避免重复调用。对于已经调用过的远程服务，避免重复选择，每次都使用同一个节点。这种特性主要是为了避免并发场景下，某个节点瞬间被大量请求。

框架会优先处理粘滞连接。否则会根据可用性检测或重复调用检测过滤一些节点，并在剩余的节点中做负载均衡。如果可用性检测或重复调用检测把节点都过滤了，则兜底的策略是：在己经调用过的节点中通过负载均衡选择出一个可用的节点。整个逻辑过程大致可以分为4步：

1）检查URL中是否有配置粘滞连接，如果有则使用粘滞连接的Invoker。如果没有配置粘滞连接，或者重复调用检测不通过、可用检测不通过，则进入第2步。

2）通过ExtensionLoader获取负载均衡的具体实现，并通过负载均衡做节点的选择。对选择出来的节点做重复调用、可用性检测，通过则直接返回，否则进入第3步。

3）进行节点的重新选择。如果需要做可用性检测，则会遍历Directory中得到的所有节点，过滤不可用和已经调用过的节点，在剩余的节点中重新做负载均衡；如果不需要做可用性检测，那么也会遍历Directory中得到的所有节点，但只过滤已经调用过的，在剩余的节点中重新做负载均衡。这里存在一种情况，就是在过滤不可用或已经调用过的节点时，节点全部被过滤，没有剩下任何节点，此时进入第4步。

4）遍历所有已经调用过的节点，选出所有可用的节点，再通过负载均衡选出一个节点并返回。如果还找不到可调用的节点，则返回null。

**2.Loadbalance总体结构**



![image-20210720194004430](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210720194004430.png)



```java
@SPI(RandomLoadBalance.NAME)
public interface LoadBalance {
    @Adaptive("loadbalance")
    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;

}
```



**3.负载均衡算法**

| 算法名称                   | 效果说明                                                     |
| -------------------------- | ------------------------------------------------------------ |
| Random LoadBalance         | 随机，按权重设置随机概率。在一个节点上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者的权重 |
| RoundRobin LoadBalance     | 轮询，按公约后的权重设置轮询比例。存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没“挂”，当请求调到第二台时就卡在那里，久而久之，所有请求都卡在调到第二台上 |
| LeastActive LoadBalance    | 最少活跃调用数，如果活跃数相同则随机调用，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大 |
| ConsistentHash LoadBalance | 一致性Hash,相同参数的请求总是发到同一提供者。当某一台提供者“挂”时，原本发往该提供者的请求，基于虚拟节点，会平摊到其他提供者，不会引起剧烈变动。默认只对第一个参数“Hash”，如果要修改，则配置 <dubbo:parameter key="hash.arguments" value="0,1"/>默认使用160份虚拟节点，如果要修改，则配置<dubbo:parameter key="hash.nodes" value="320" /> |



### 2、随机负载均衡

Random负载均衡是按照权重设置随机概率做负载均衡的。这种负载均衡算法并不能精确地平均请求，但是随着请求数量的增加，最终结果是大致平均的。它的负载计算步骤如下：

1）计算总权重并判断每个Invoker的权重是否一样。遍历整个Invoker列表，求和总权重。在遍历过程中，会对比每个Invoker的权重，判断所有Invoker的权重是否相同。

2）如果权重相同，则说明每个 Invoker 的概率都一样，因此直接用nextlnt随机选一个 Invoker 返回即可。

3）如果权重不同，则首先得到偏移值，然后根据偏移值找到对应的Invoke

### 3、轮询负载均衡

权重，轮询负载均衡会根据设置的权重来判断轮询的比例。普通轮询负载均衡的好处是每个节点获得的请求会很均匀，如果某些节点的负载能力明显较弱，则这个节点会堆积比较多的请求。因此普通的轮询还不能满足需求，还需要能根据节点权重进行干预。权重轮询又分为普通权重轮询和平滑权重轮询。普通权重轮询会造成某个节点会突然被频繁选中，这样很容易突然让一个节点流量暴增。Nginx中有一种叫平滑轮询的算法(smooth weighted round-robinbalancing),这种算法在轮询时会穿插选择其他节点，让整个服务器选择的过程比较均匀，不会“逮住”一个节点一直调用oDubbo框架中最新的RoundRobin代码已经改为平滑权重轮询算法。我们先来看一下Dubbo中RoundRobin负载均衡的工作步骤，如下：

1）初始化权重缓存Map。以每个Invoker的URL为key,对象WeightedRoundRobin为value生成一个 ConcurrentMap,并把这个 Map 保存到全局的 methodWeightMap 中：ConcurrentMap<String, ConcurrentMap<StringJ WeightedRoundRobin>> methodWeightMap。methodWeightMap的key是每个接口 +方法名。这一步只会生成这个缓存Map,但里面是空的，第2步才会生成每个Invoker对应的键值。WeightedRoundRobin封装了每个Invoker的权重，对象中保存了三个属性，如代玛清单7-15
所示。

(2) 遍历所有Invoker。首先，在遍历的过程中把每个Invoker的数据填充到第1步生成的权重缓存Map中。其次，获取每个Invoker的预热权重，新版的框架RoundRobin也支持预热，通过和Random负载均衡中相同的方式获得预热阶段的权重。如果预热权重和Invoker设置的权重不相等，则说明还在预热阶段，此时会以预热权重为准。然后，进行平滑轮询。每个 Invoker 会把权重加到自己的current属性上，并更新当前Invoker的lastUpdate。同时累加每个Invoker的权重到totalweighto最终，遍历完后，选出所有Invoker中current最大的作为最终要调用
的节点。

(3) 清除已经没有使用的缓存节点。由于所有的Invoker的权重都会被封装成一个



### 4、最少连接负载均衡



### 5、一致性哈希负载均衡



