

# Dubbo SPI 机制


[toc]

## 扩展点概述

Dubbo 良好的扩展性与两个方面是密不可分的，一是整个框架中针对不同的场景，恰到好处地使用了各种设计模式，二就是扩展点加载机制。基于 Dubbo SPI 加载机制，让整个框架的接口和具体实现完全解耦，从而奠定了整个框架良好可扩展性的基础。Dubbo 几乎所有的功能组件都是基于扩展机制(SPI)实现的。Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。

### 1、Java SPI 使用

SPI 的全称是 Service Provider Interface, 起初是提供给厂商做插件开发的。Java SPI使用了策略模式，一个接口多种实现。我们只声明接口，具体的实现并不在程序中直接确定，而是由程序之外的配置掌控，用于具体实现的装配。具体步骤如下：

1. 定义一个接口及对应的方法。
2. 编写该接口的一个实现类。
3. 在 META-INF/services/ 目录下，创建一个以接口全路径命名的文件，如 com.test.spi.PrintService。
4. 文件内容为具体实现类的全路径名，如果有多个，则用分行符分隔。
5. 在代码中通过 java.util.ServiceLoader 来加载具体的实现类。

### 2、Dubbo SPI 使用

**1.SPI注解**

使用 @SPI 注解标记这个接口是一个 Dubbo SPI 接口，即是一个扩展点，可以有多个不同的内置或用户定义的实现，运行时需要通过配置找到具体的实现类，获取扩展点实现类是会判断对应的 Class 是否有 SPI 注解。SPI注解有一个 value 属性，通过这个属性，我们可以传入不同的参数来设置这个接口的默认实现类。

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface SPI {
    String value() default "";
}
//1）为接口类添加SPI注解，设置默认实现为impl
@SPI("impl") 
public interface Printservice {
	void printlnfo();
}
```

**2.定义实现类**
```java
//2）实现类
public class PrintServicelmpl implements Printservice (
    @Override
    public void printlnfo() (
    	System.out・println("hello world");
    }
}
```

**3.SPI配置文件**

Dubbo SPI 和 Java SPI 类似，在Dubbo启动的时候，会默认扫这三个目录下的配置文件：META-INF/services/、META-INF/dubbo/、META-INF/dubbo/internal。文件名称需要命名为接口的全路径名，配置文件的内容为 key= 扩展点实现类全路径名，如果有多个实现类则使用换行符分隔。其中，key 会作为 Dubbo SPI 注解中的传入参数。

```java
//3）在目录META-INF/dubbo/internal下建立配置文件com.test.spi.Printservice，内容如下
impl=com.test.spi.PrintServiceImpl
```

**4.加载扩展点**

```java
//4）调用 Dubbo SPI 通过，ExtensionLoader 获取接口实现类
public static void main(String[] args) (
    PrintService printservice = ExtensionLoader
    	.getExtensionLoader(PrintService.class).getDefaultExtension();
    printService.printInfo();
}
```

### 3、Dubbo SPI 特性

扩展类一共包含四种特性：自动包装、自动加载、自适应和自动激活。自动包装是构造参数包含其他扩展点时注入依赖的扩展点，自动加载即通过setter注入依赖的扩展点。自适应是在动态代理类中获取URL参数，并根据URL参数获取普通的扩展点实现类，自动激活是根据激活条件激活多个普通扩展点。

 **1.扩展点自动包装**

自动包装扩展点的 Wrapper 类。`ExtensionLoader` 在加载扩展点时，这个扩展类包含其他扩展点作为构造函数的参数，则这个扩展类就会被认为是Wrapper类。例如，ProtocolFilterWrapper：

```java
public class ProtocolFilterWrapper implements Protocol {
    private final Protocol protocol;//被包装类
    //实现了 Protocol,但构造函数中又传入了一个 Protocol 类型的参数，框架会自动注入
    public ProtocolFilterWrapper(Protocol protocol) {
        if (protocol == null) {
        	throw new IllegalArgumentException("protocol == null");
        }
        this.protocol = protocol;
    }
    // 接口方法做一个操作后，再调用extension的方法
    public void refer() {
        //... 一些操作
        protocol.refer();
        // ... 一些操作
    }
}
```

Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 `ExtensionLoader` 返回扩展点时，包装在真正的扩展点实现外。即从 `ExtensionLoader` 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。

**2. 扩展点自动装配**

除了在构造函数中传入其他扩展实例，我们还经常使用setter方法设置属性值。如果某个扩展类是另外一个扩展点类的成员属性，并且拥有setter方法，那么框架也会自动注入对应的扩展点实例。`ExtensionLoader` 通过扫描扩展点实现类的所有 setter 方法来判定其成员。即 `ExtensionLoader` 会执行扩展点的拼装操作。

这里带来另一个问题，`ExtensionLoader` 要注入依赖扩展点时，如何决定要注入依赖扩展点的哪个实现。在这个示例中，即是在多个`WheelMaker` 的实现中要注入哪个。这个问题在下面一点 [扩展点自适应](#扩展点自适应) 中说明。

**3.扩展点自适应**

在Dubbo SPI中，我们使用@Adaptive注解标注在接口的方法上，即方法级别注解，则可以通过参数动态获得实现类。方法级别注解在第一次 ExtensionLoader.getExtension() 时，会自动生成和编译一个动态的 Xxx$Adaptive 代理类，从而达到动态实现类的效果，在代理类中动态地通过URL中的参数来确定要使用哪个具体的实现类。

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Adaptive {
    String[] value() default {};
}
```

该注解可以传入value参数，是一个数组。我们在代码清单4.9中可以看到，Adaptive可以传入多个key值，在初始化Adaptive注解的接口时，会先对传入的URL进行key值匹配，第一个key没匹配上则匹配第二个，以此类推。直到所有的key匹配完毕，如果还没有匹配到，则会会自动把接口名称根据驼峰大小写分开，并用"."符号连接起来，如果也没匹配到，则会抛出IllegalStateException异常。

下面是 Dubbo 的 Transporter 扩展点的代码：

```java
@SPI("netty")
public interface Transporter {
    @Adaptive({"server", "transport"})
    Server bind(URL url, ChannelHandler handler) throws RemotingException;
 
    @Adaptive({"client", "transport"})
    Client connect(URL url, ChannelHandler handler) throws RemotingException;
}

// 下面是自动生成的Transporter$Adaptive#bind实现代码
public org.apache.dubbo.remoting.Server bind(org.apache.dubbo.common.URL arg0 org.apache.dubbo.remoting.ChannelHandler argl) throws org.apache.dubbo.remoting.RemotingException {
    org.apache.dubbo.common.URL url = arg0;
	//通过@Adaptive注解中的两个key去寻找实现类的名称
	String extName = url.getParameter("server", url.getParameter("transporter","netty"));
    try { 
        //根据URL中的参数，尝试获取真正的扩展点实现类
        extension = (org.apache.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader(org.apache.dubbo.remoting.Transporter.class).getExtension(extName);
    }catch (Exception e) {
    // 如果获取失败，则使用默认的 Netty 实现
    extension = (org.apache.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader(org, apache. dubbo.remoting.Transporter.class).getExtension("netty");
    } 
    // 最终会调用具体扩展点实现类的bind方法
    return extension.bind(arg0, argl);
}
```

Dubbo在初始化扩展点时，会生成一个Transporter$Adaptive类，里面会实现这两个方法，方法里会有一些抽象的通用逻辑，通过@Adaptive注解中传入的以及URL中的参数，找到并调用真正的实现类。

当外部调用 Transporter#bind 方法时，会动态从传入的参数 “URL” 中提取 key 参数 “server” 的 value 值，如果能匹配上某个扩展实现类则直接使用对应的实现类；如果未匹配上，则继续通过第二个 key 参数 “transporter” 提取 value 值。如果都没匹配上，则抛出异常。也就是说，如果 @Adaptive 中传入了多个参数，则依次进行实现类的匹配，直到最后抛出异常。

在扩展点接口的多个实现里，只能有一个实现上可以加@Adaptive注解。如果多个实现类都有该注解，则会抛出异常：More than 1 adaptive class found0。

**4.扩展点自动激活**

自适应这种动态寻找实现类的方式比较灵活，但只能激活一个具体的实现类，如果需要多个实现类同时被激活，比如：`Filter`, `InvokerListener`, `ExportListener`, `TelnetHandler`, `StatusChecker` 等，可以同时加载多个实现，可以用自动激活实现。自动激活使用@Activate注解，可以标记对应的扩展点默认被激活启用。该注解还可以通过传入不同的参数，设置扩展点在不同的条件下被自动激活。

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Activate {
    // URL中的分组如果匹配则激活，则可以设置多个
    String[] group() default {};
    // 查找URL中如果含有该key值，则会激活
    String[] value() default {};
    // 填写扩展点列表，表示哪些扩展点要在本扩展点之前
    String[] before() default {};
    // 同上，表示哪些需要在本扩展点之后
    String[] after() default {};
    // 整型，直接的排序信息
    int order() default 0;
}

// 只对提供方激活，group选"provider"或"consumer"
@Activate(group = "provider", value = "xxx") 
public class XxxFilter implements Filter {
    // ...
}
```

### 4、Dubbo SPI 优点

Dubbo 改进了 JDK 标准的 SPI 的以下问题：

* JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。
* 如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 `getName()` 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby  脚本时，会报不支持 ruby，而不是真正失败的原因。
* 增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。



## 扩展点加载流程

ExtensionLoader 是整个扩展机制的主要逻辑类，在这个类里面实现了配置的加载、扩展类缓存、自适应对象生成等所有工作。ExtensionLoader 的逻辑入口可以分为 getExtension、getAdaptiveExtension、getActivateExtension，分别是获取普通扩展类、获取自适应扩展类、获取自动激活的扩展类。

### 1、整体流程

![image-20210711153328074](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210711153328074.png)

[Dubbo 源码分析：SPI与自适应扩展机制](https://www.processon.com/view/5d5d52ade4b0ac2b61821e46?fromnew=1)

**1.getExtension**

getExtension(String name) 是整个扩展加载器中最核心的方法，实现了一个完整的普通扩展类加载过程。加载过程中的每一步，都会先检查缓存中是否己经存在所需的数据，如果存在则直接从缓存中读取，没有则重新加载。这个方法每次只会根据名称返回一个扩展点实现类。初始化的过程可以分为4步：

- 框架读取SPI对应路径下的配置文件，并根据配置加载所有扩展类并缓存(不初始化)。

- 根据传入的名称初始化对应的扩展类。

- 尝试查找符合条件的包装类：包含扩展点的setter方法，例如setProtocol(Protocol protocol)方法会自动注入protocol 扩展点实现；包含与扩展点类型相同的构造函数，为其注入扩展类实例，例如本次初始化了一个Class A,初始化完成后，会寻找构造参数中需要 Class A 的包装类(Wrapper), 然后注入 Class A 实例，并初始化这个包装类。
- 返回对应的扩展类实例。

**2.getAdaptiveExtension **

getAdaptiveExtension 相对独立，只有加载配置信息部分与 getExtension 共用了同一个方法。和获取普通扩展类一样，框架会先检查缓存中是否有已经初始化化好的 Adaptive 实例，没有则调用 createAdaptiveExtension 重新初始化。初始化过程分为4步：

- 和 getExtension 一样先加载配置文件。
- 生成自适应类的代码字符串。
- 获取类加载器和编译器，并用编译器编译刚才生成的代码字符 串。
- 返回对应的自适应类实例。

**2.getActivateExtension** 

getActivateExtension 方法只是根据不同的条件同时激活多个普通扩展类。因此，该方法中只会做一些通用的判断逻辑，如接口是否包含 @Activate 注解、匹配条件是否符合等。最终还是通过调用 getExtension 方法获得具体扩展点实现类。

### 2、getExtension 

**1.流程图**



**2.核心代码注解**

```java
public T getExtension(String name) {
    // 从缓存中获取，如果不存在则双重校验锁调用createExtension(name)创建扩展点实例，并放入缓存；
    Holder<Object> holder = cachedInstances.get(name);
    instance = createExtension(name);
}
private T createExtension(String name) {
    // 1)先检查缓存中是否有配置信息，如果不存在扩展类，则会读取所有的配置文件得到配置文件中对应的扩展点实现类的全称(如 xxx.impl.GroupActivateExtImpl)
    Class<?> clazz = getExtensionClasses().get(name);
    // 2)通过反射实例化并放入缓存
    EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
    // 3)为当前实例注入依赖
    injectExtension(instance);
    // 4)当扩展类初始化后，会检查一次包装扩展类Set<Class<?> wrapperclasses,查找包含与扩展点类型相同的构造函数，为其注入刚初始化的扩展类
    for (Class<?> wrapperClass : wrapperClasses) {
        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
    }
}
//=======================================================================================
private Map<String, Class<?>> getExtensionClasses() {
    // 双重校验锁调用loadExtensionClasses()读取配置文件，加载缓存
    classes = loadExtensionClasses();
}
private Map<String, Class<?>> loadExtensionClasses() {
    // 加载指定路径下的SPI配置文件
    Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();
    loadDirectory(extensionClasses, "META-INF/services/");
    loadDirectory(extensionClasses, "META-INF/dubbo/");
    loadDirectory(extensionClasses, "META-INF/dubbo/internal/");
}
private void loadDirectory(Map<String, Class<?>> extensionClasses, String dir) {
    // 待加载的配置文件明是配置文件目录+当前扩展点类全限定名
    String fileName = dir + type.getName();
    urls = classLoader.getResources(fileName);
    //循环遍历urls,解析字符串，得到扩展实现类，并加入缓存
    while (urls.hasMoreElements()) {
        java.net.URL resourceURL = urls.nextElement();
        loadResource(extensionClasses, classLoader, resourceURL);
    }
}
private void loadResource(Map<String, Class<?>> extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) {
    //通过BufferedReader按行读取配置文件，等号分隔得到key(name),value(line),调用loadClass
    loadClass(extensionClasses, resourceURL, Class.forName(line, true, classLoader), name);
}
private void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL, Class<?> clazz, String name){
    // 如果是自适应类(Adaptive)放入cachedAdaptiveClass缓存, 缓存的自适应类只能有一个
    cachedAdaptiveClass = clazz;
    // 如果是包装扩展类(Wrapper ),则直接加入包装扩展类的 cachedWrapperClasses Set集合
    Set<Class<?>> wrappers = cachedWrapperClasses;
    wrappers.add(clazz);
    //如果有自动激活注解(Activate ),则缓存到自动激活的缓存中
    cachedActivates.put(names[0], activate);
    // 普通扩展类放入相应的缓存
    for (String n : names) {
        cachedNames.put(clazz, n);
        extensionClasses.put(n, clazz);
    }
}
//=======================================================================================
private T injectExtension(T instance) {
    //首先通过反射获取类的所有方法，然后遍历以字符串set开头的方法，得到set方法的参数类型，
    for (Method method : instance.getClass().getMethods()) {
        if (method.getName().startsWith("set") && ...) {
            //通过字符串截取，获得小写开头的类名, 如 setTestService,截取 testService
            String property = method.getName().length() > 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : "";
            //再通过 ExtensionFactory 寻找参数类型相同的扩展类实例，如果找到，就设值进去
            Object object = objectFactory.getExtension(pt, property);
            if (object != null) {
                method.invoke(instance, object);
            }
        }
    }
}

```



### 3、getAdaptiveExtension 

**1.流程图**

![image-20210712195156389](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210712195156389.png)

**2.核心代码注解**

```java
public T getAdaptiveExtension() {
    // 从自适应扩展实例缓存中获取实例，不存在则双重校验锁调用createAdaptiveExtension创建实例
    Object instance = cachedAdaptiveInstance.get();
    instance = createAdaptiveExtension();
}
private T createAdaptiveExtension() {
    // 调用getAdaptiveExtensionClass加载自适应类Class对应，创建实例并注入依赖；
    return injectExtension((T) getAdaptiveExtensionClass().newInstance());
}
private Class<?> getAdaptiveExtensionClass() {
    // 和普通扩展类一样先读取配置文件，加载相应扩展点Class放入缓存
    getExtensionClasses();
    // 调用 createAdaptiveExtensionClass 创建自适应扩展点代理类Class；
    return cachedAdaptiveClass = createAdaptiveExtensionClass();
}
private Class<?> createAdaptiveExtensionClass() {
    // 生成自适应扩展代理类代码
    String code = createAdaptiveExtensionClassCode();
    // 获取编译器编译扩展点代理类
    Compiler compiler = ExtensionLoader.
        getExtensionLoader(Compiler.class).getAdaptiveExtension();
    return compiler.compile(code, classLoader);
}
private String createAdaptiveExtensionClassCode() {
    /*生成代码的逻辑主要分为7步，具体步骤如下：
    1) 生成package、 import、类名称等头部信息。此处只会引入一个类 ExtensionLoader。为了不写其他类的import 方法，其他方法调用时全部使用全路径。类名称会变为“接口名称+$Adaptive ” 的格式。例如：Transporter 接口会生成 Transporter$Adpative。
    2) 遍历接口所有方法，获取方法的返回类型、参数类型、异常类型等。为第3)步判断是否为空值做准备。
    3) 生成参数为空校验代码，如参数是否为空的校验。如果有远程调用，还会添加 Invocation 参数为空的校验。
    4) 生成默认实现类名称。如果 @Adaptive 注解中没有设定默认值，则根据类名称生成，如YyylnvokerWrapper会被转换为yyy.invoker.wrappero生成的规则是不断找大写字母，并把它们用连接起来。得到默认实现类名称后，还需要知道这个实现是哪个扩展点的。
    5) 生成获取扩展点名称的代码。根据@Adaptive注解中配置的key值生成不同的获取代码，例如：如果是@Adaptive("protocol"),则会生成 ur1.getProtocol()。
    6) 生成获取具体扩展实现类代码。最终还是通过getExtension(extName)方法获取自适应扩展类的真正实现。如果根据URL中配置的key没有找到对应的实现类，则会使用第4)步中生成的默认实现类名称去找。
    7) 生成调用结果代码。[生成结果参考上一章 扩展点概述-3、Dubbo SPI特性-3.扩展点自适应]
    */
}
```

### 4、getActivateExtension

```java
public List<T> getActivateExtension(URL url, String[] values, String group) {
    // 检查缓存，如果缓存中没有，则初始化所有扩展类实现的集合。
	getExtensionClasses();
    // 遍历整个©Activate注解集合，根据传入URL匹配条件(匹配group> name等)，
    // 得到所有符合激活条件的扩展类实现
    for (Map.Entry<String, Activate> entry : cachedActivates.entrySet()) {
        String name = entry.getKey();
        Activate activate = entry.getValue();
        if (isMatchGroup(group, activate.group())) {
            if (!names.contains(name)
                && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)
                && isActive(activate, url)) {
                T ext = getExtension(name);
                exts.add(ext);
            }
        }
    }
    // 然后根据 @Activate 中配置的 before、after、order 等参数进行排序
    Collections.sort(exts, ActivateComparator.COMPARATOR);
    // 遍历所有用户自定义扩展类名称，根据用户URL配置的顺序，调整扩展点激活顺序
}
```



### 5、ExtensionFactory

ExtensionLoader 是通过工厂方法 ExtensionFactory 创建的，并且这个工厂接口本身也是一个扩展点（有SPI注解）。ExtensionFactory 有三个实现类：AdaptiveExtensionFactory、SpiExtensionFactory、SpringExtensionFactory。

![image-20210712173508591](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210712173508591.png)

**1.AdaptiveExtensionFactory**

我们可以看到 AdaptiveExtensionFactory 这个实现类工厂上W@Adaptive 注解。因此 AdaptiveExtensionFactory 会作为一开始的默认实现。当我们通过ExtensionLoager获取工厂类时，返回默认的自适应工厂类。

这个默认工厂在构造方法中就获取了所有扩展类工厂并缓存起来，包括SpiExtensionFactory 和 SpringExtensionFactory。

AdaptiveExtensionFactor持有了所有的具体工厂实现，它的 getExtension 方法中只是遍历了它持有的所有工厂，最终还是调用 SPI 或 Spring 工厂实现的 getExtension 方法。

**2.SpringExtensionFactory**

SpringExtensionFactory 工厂提供了保存Spring上下文的静态方法，可以把Spring上下文保存到Set集合中。当调用getExtension获取扩展类时，会遍历Set集合中所有的Spring上下文，先根据名字依次从每个Spring容器中进行匹配，如果根据名字没匹配到，则根据类型去匹配，如果还没匹配到则返回nul。

```java
// 在 ReferenceBean 和 ServiceBean 中会调用静态方法保存Spring上下文
private static final Set<ApplicationContext> contexts = new ConcurrentHashSet<ApplicationContext>();
public static void addApplicationContext(ApplicationContext context) {
	contexts.add(context);
}
public <T> T getExtension(Class<T> type, String name) {
    //遍历所有Spring 上下文，先根据名字从Spring容器中查找；
    Object bean = context.getBean(name);
    //根据名称没有找到，再遍历所有Spring 上下文，通过类型从Spring 容器中查找；
    return context.getBean(type);
}
```

**3.SpiExtensionFactory**

```java
public <T> T getExtension(Class<T> type, String name) {
    if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {
        //根据类型从 EXTENSION_LOADERS 缓存获取所有的扩展点加载器,每个Class都有对应的扩展点加载器；
        ExtensionLoader<T> loader = ExtensionLoader.getExtensionLoader(type);
        if (!loader.getSupportedExtensions().isEmpty()) {
            // 通过扩展点加载器获取对应的自适应扩展点
        	return loader.getAdaptiveExtension();
        }
    }
    return null;
}
```



## 扩展点动态编译

Dubbo SPI 自适应特性通过动态编译生成自适应代理类，虽然我们可以使用反射来动态代理一个类，但是在性能上和直接编译好的Class会有一定的差距。Dubbo SPI通过代码的动态生成，并配合动态编译器，灵活地在原始类基础上创建新的自适应类。

### 1、整体流程

Dubbo中有三种代码编译器，分别是 JDK 编译器、Javassist 编译器和 AdaptiveCompiler 编译器。这几种编译器都实现了 Compiler接口。从下图可知编译器本身是一个扩展点，并且AdaptiveCompiler 是一个自适应扩展类，被@Adaptive 注解标识，是编译器默认实现，所以获取自适应扩展点时通过 ExtensionLoader 获取到AdaptiveCompiler，再调用AdaptiveCompiler.compile()。

![image-20210712190156158](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210712190156158.png)

**1.AdaptiveCompile**

AdaptiveCompiler#setDefaultCompiler 方法会在 ApplicationConfig 中被调用，也就是 Dubbo 在启动时，会解析配置中的<dubbo:application compiler="jdk" />标签，获取设置的值，初始化对应的编译器。如果没有标签设置，则使用@SPI(Hjavassistn)中的设置，即3avassistCompilero

```java
public Class<?> compile(String code, ClassLoader classLoader) {
    // 通过ExtensionLoader获取对应的编译器扩展类实现
ExtensionLoader<Compiler> loader = ExtensionLoader.getExtensionLoader(Compiler.class);
    compiler = loader.getDefaultExtension();
    // 并调用真正的 compile 做编译（）
    return compiler.compile(code, classLoader);
}
```

**2.AbstpactCompiler**

Abstractcompiler 是一个抽象类，这里采用模板方法设计模式，通用逻辑在抽象类中实现，并 定义了doCompile() 抽象方法由子类实现具体编译逻辑。的主要抽象逻辑如下：

1. 通过正则匹配出包路径、类名，再根据包路径、类名拼接出全路径类名。
2. 尝试通过Class.forName加载该类并返回，防止重复编译。如果类加载器中没有这个类，则进入第3步。
3. 调用doCompile方法进行编译。这个抽象方法由子类实现。

### 2、Javassist 编译器

Java中动态生成 Class 的方式有很多，可以直接基于字节码的方式生成，常见的工具库有CGLIB、ASM、Javassist等。在编译之前已经生成了相应的 Code，因此在 JavassistCompiler 中，就是不断通过正则表达式匹配不同部位的代码，然后调用 Javassist 库中的 API 生成不同部位的代码，最后得到一个完整的 Class 对象。

```java
public Class<?> doCompile(String name, String source) throws Throwable {
    // 1)初始化Javassist,设置默认参数，如设置当前的classpatho
    ClassPool pool = new ClassPool(true);
    // 2)通过正则匹配出所有import的包，并使用Javassist添加import
    Matcher matcher = IMPORT_PATTERN.matcher(source);
    pool.importPackage(pkgName);
    // 3)通过正则匹配出所有extends的包，创建Class对象，并使用Javassist 添加 extends
    matcher = EXTENDS_PATTERN.matcher(source);
    cls = pool.makeClass(name, pool.get(extendClass));
    // 4)通过正则匹配出所有implements包，并使用Javassist添加implements。
    matcher = IMPLEMENTS_PATTERN.matcher(source);
    cls.addInterface(pool.get(ifaceClass));
    // 5)通过正则匹配出类里面所有内容，即得到｛｝中的内容，再通过正则匹配出所有方法,并使用Javassist添加类方法。
    String body = source.substring(source.indexOf("{") + 1, source.length() - 1);
    String[] methods = METHODS_PATTERN.split(body);
    cls.addMethod(CtNewMethod.make("public " + method, cls));
    // 6)生成Class对象。
    return cls.toClass(ClassHelper.getCallerClassLoader(getClass()), JavassistCompiler.class.getProtectionDomain());
}
```

### 3、JDK 编译器

JDK 动态编译过程可以简单地总结为：首先初始化一个 JavaFileObject 对象，并把代码字符串作为参数传入构造
方法，然后调用 JavaCompiler.CompilationTask 方法编译出具体的类。JavaFileManager 负责管理类文件的输入/输出位置。

```java
public Class<?> doCompile(String name, String sourceCode) throws Throwable {
    // 1)JavaFileObject接口。字符串代码会被包装成一个文件对象，并提供获取二进制流的接口
    javaFileObjectImpl javaFileObject = new JavaFileObjectImpl(className, sourceCode);
    // 2)DavaFileManager接口。主要管理文件的读取和输出位置。
    javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH, packageName,
            className + ClassUtils.JAVA_EXTENSION, javaFileObject);
    // 3)javaCompiler.CompilationTask 把 DavaFileObject 对象编译成具体的类。
    Boolean result = compiler.getTask(null, javaFileManager, diagnosticCollector, 					options,null, Arrays.asList(javaFileObject)).call();
}
```

