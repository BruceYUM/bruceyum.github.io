# Dubbo 实践及问题

[toc]

## Dubbo 规范及调优

### 1、配置及流程

![image-20210719171337655](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210719171337655.png)

 1）当consumer发起一个请求时，首先经过active limit(参数actives）进行方法级别的限制，其实现方式为CHM中存放计数器(AtomicInteger)，请求时加1，请求完成（包括异常）减1,如果超过actives则等待有其他请求完成后重试或者超时后失败；

2）从多个连接(connections）中选择一个连接发送数据，对于默认的netty实现来说，由于可以复用连接，默认一个连接就可以。不过如果你在压测，且只有一个consumer,一个provider，此时适当的加大connections确实能够增强网络传输能力。但线上业务由于有多个consumer多个provider，因此不建议增加connections参数；

3）连接到达provider时（如dubbo的初次连接），首先会判断总连接数是否超限（acceps），超过限制连接将被拒绝；

4）连接成功后，具体的请求交给io thread处理。io threads虽然是处理数据的读写，但io部分为异步，更多的消耗的是cpu，因此iothreads默认cpu个数+1是比较合理的设置，不建议调整此参数;

5）数据读取并反序列化以后，交给业务线程池处理，默认情况下线程池为fixed，且排队队列为0(queues)，这种情况下，最大并发等于业务线程池大小(threads)，如果希望有请求的堆积能力，可以调整queues参数。如果希望快速失败由其他节点处理（官方推荐方式），则不修改queues，只调整threads;

6）execute limit（参数executes）是方法级别的并发限制，原理与actives类似，只是少了等待的过程，即受限后立即失败；

7）tps，控制指定时间内（默认60s）的请求数。注意目前dubbo默认没有支持该参数，需要加一个META-INF/dubbo/com.alibaba.dubbo.rpc.Filter文件，文件内容为： tps=com.alibaba.dubbo.rpc.filter.TpsLimitFilter

从上面的分析，可以看出如果consumer数\*actives>provider数\*threads且queues=0，则会存在部分请求无法申请到资源，重试也有很大几率失败。 当需要对一个接口的不同方法进行不同的并发控制时使用executes，否则调整threads就可以。

### 2、provider配置

provider 配置分为以下几个层级

|                | 影响范围                    | 备注                                                         |
| -------------- | --------------------------- | ------------------------------------------------------------ |
| dubbo:method   | 方法级                      | 注意配置了方法级表示会覆盖接口级的配置，而不是只暴露配置了的方法 |
| dubbo:service  | 接口级                      | 一个service包含1+个method                                    |
| dubbo:protocol | 协议级别                    | 一个service可以注册到多个protocol中                          |
| dubbo:provider | 所有配置该provider的service | 一个service属于一个provider                                  |

provider 参数调优建议

| 参数名    | 作用范围 | 默认值 | 说明                                                         | 备注                                                         |
| --------- | -------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| delay     | provider |        | [调优]延迟注册服务时间(毫秒)                                 | 选填。建议设置为-1，表示spring初始化完成时暴露服务，防止未初始化完全导致的bug |
| iothreads | provider | CPU+1  | io线程池大小                                                 | 不建议修改                                                   |
| threads   | provider | 200    | 业务处理线程池大小                                           | threads 参数配置的是业务处理线程池的最大（或核心）线程数。<br />并发量大的服务必填（如播放端），根据压测结果得到，可以考虑 64->128->256->512, 超过 512 需要考虑是否要增加实例。 |
| queues    | provider | 0      | 线程池队列大小，当线程池满时，排队等待执行的队列大小，建议不要设置，当线程池满时应立即失败，重试其它服务提供机器，而不是排队，除非有特殊需求 | 分别在 FixedThreadPool.java、LimitedThreadPool.java 和 CachedThreadPool.java 中使用， 由代码可见，默认值为 0，表示使用同步阻塞队列；如果 queues 设置为小于 0 的值，则使用容量为 Integer.MAX_VALUE 的阻塞链表队列；如果为其他值，则使用指定大小的阻塞链表队列。<br />不建议设置该值，设置为非0值请求到provider后如果provider中执行的任务超过最大线程数数量，则会先在队列中排队，这种设置会影响consumer的重试策略 |
| executes  | provider |        | [限流]服务提供者每服务每方法最大可并行执行请求数             | 必填。0表示不限制，Provider处理请求时，统计方法维度的调用情况，如果并发数超过设置的最大值，则阻直接抛出异常。<br />必须大于0，根据压测值来定<br/>建议同一个服务下的所有方法的executes相加（约）等于threads参数值 |
| acceptes  | provider | 0      | 服务提供方最大可接受连接数                                   | 0表示不限制当连接数大于最大值时，关闭当前连接。              |

provider 参数源码解析

![image-20210719195200842](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210719195200842.png)

```java
@SPI("fixed")
public interface ThreadPool {
    @Adaptive({Constants.THREADPOOL_KEY})
    Executor getExecutor(URL url);
}
public class FixedThreadPool implements ThreadPool {

    @Override
    public Executor getExecutor(URL url) {
        String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);
        // 1) Constants.DEFAULT_QUEUES = 200。threads 参数配置的是业务处理线程池的最大（或核心）线程数。
        int threads = url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS);
        // 2)默认值为 0，表示使用同步阻塞队列；如果 queues 设置为小于 0 的值，则使用容量为 Integer.MAX_VALUE 的阻塞链表队列；如果为其他值，则使用指定大小的阻塞链表队列。
        int queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);
        return new ThreadPoolExecutor(threads, threads, 0, TimeUnit.MILLISECONDS,
                queues == 0 ? new SynchronousQueue<Runnable>() :
                        (queues < 0 ? new LinkedBlockingQueue<Runnable>()
                                : new LinkedBlockingQueue<Runnable>(queues)),
                new NamedInternalThreadFactory(name, true), new AbortPolicyWithReport(name, url));
    }

}

protected void NettyServer#doOpen() throws Throwable {
    bootstrap = new ServerBootstrap();
	
    bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("NettyServerBoss", true));
	// 默认iothreads = CPU + 1；
    // public static final int DEFAULT_IO_THREADS = Math.min(Runtime.getRuntime().availableProcessors() + 1, 32);
    workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),
                new DefaultThreadFactory("NettyServerWorker", true));
    //...
}

// Provider处理请求时，统计方法维度的调用情况，如果并发数超过设置的最大值，则阻直接抛出异常。
public Result ExecuteLimitFilter#invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
    Semaphore executesLimit = null;
    if (max > 0) {
        RpcStatus count = RpcStatus.getStatus(url, invocation.getMethodName());
        executesLimit = count.getSemaphore(max);
        if(executesLimit != null && !(acquireResult = executesLimit.tryAcquire())) {
            throw new RpcException("Failed to invoke method " + invocation.getMethodName() + " in provider " + url + ", cause: The service using threads greater than <dubbo:service executes=\"" + max + "\" /> limited.");
        }
    }
}

// AbstractServer 构造方法中获取最大可接受连接数
this.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);
// 当连接数大于最大值时，关闭当前连接。
public void connected(Channel ch) throws RemotingException {
    Collection<Channel> channels = getChannels();
    if (accepts > 0 && channels.size() > accepts) {
        logger.error("Close channel " + ch + ", cause: The server " + ch.getLocalAddress() + " connections greater than max config " + accepts);
        ch.close();
        return;
    }
}
```

### 3、consumer配置

| 参数名      | 作用范围 | 默认值 | 说明                                                         | 备注                                                         |
| ----------- | -------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| async       | consumer |        | consumer端异步执行                                           | 不建议开启，默认为false。在2.5.x或之前版本中开启异步可能导致bug。如果确实需要开启异步，需要确定所有对应的provider的第一行代码前增加：<br/>RpcContext.getContext().removeAttachment(Constants.ASYNC_KEY); |
| timeout     | consumer |        | [调优]服务调用超时时间                                       | 必填。大于0，根据业务的实际情况设置。注意超时时间比较敏感的业务，不能依赖dubbo的timeout，需要业务自己用代码管理超时。建议使用线程池+Future |
| retries     | consumer | 2      | [调优]cosumer调用provider的重试次数，默认2，表示最大可能产生三次请求 | 选填。默认为2，表示最大可能产生三次请求；如果是写服务且provider不具备幂等性，则必须关闭重试(retries=0)，如果对性能要求较高且可以降级的服务，建议关闭重试 |
| connections | consumer | 0      | [调优]单个cosumer对单个provider的最大连接数                  | 对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，Dubbo等长连接协表示建立的长连接个数<br />Dubbo协议默认共享一个长连接 |
| actives     | consumer | 0      | 每服务消费者每服务每方法最大并发调用数                       | 0表示不限制Consumer 调用时，统计服务和方法维度的调用情况，如果并发数超过设置的最大值，则阻塞当前线程，直到前面有请求处理完成。<br />必填。建议在服务方设置，必须大于0, actives <= provider实例数 * executes / consumer个数 |
| check       | consumer | true   | 启动时检查提供者是否存在                                     | 必填。建议用false。如果设置为true则当provider没有实例启动时，对应的consumer所在服务也无法启动 |

源码解析：

```java
// 默认值为0，表示针对每个 Provider，所有客户端共享一个长连接；否则，建立指定数量的长连接。在调用时，如果有多个长连接，则使用轮询方式获得一个长连接。
private ExchangeClient[] DubboProtocol#getClients(URL url) {
	// 是否共享连接
    boolean service_share_connect = false;
    // 获取连接数，默认为0，表示未配置
    int connections = url.getParameter(Constants.CONNECTIONS_KEY, 0);
    // 如果未配置 connections，则共享连接
    if (connections == 0) {
        service_share_connect = true;
        connections = 1;
    }
    ExchangeClient[] clients = new ExchangeClient[connections];
    for (int i = 0; i < clients.length; i++) {
        if (service_share_connect) {
            // 获取共享客户端
            clients[i] = getSharedClient(url);
        } else {
            // 初始化新的客户端
            clients[i] = initClient(url);
        }
    }
    return clients;
}
private ExchangeClient DubboProtocol#getSharedClient(URL url) {
    // 从缓存获取带有“引用计数”功能的 ExchangeClient
    ReferenceCountExchangeClient client = referenceClientMap.get(key);
    // 创建 ExchangeClient 客户端
    ExchangeClient exchangeClient = initClient(url);
}
protected Result doInvoke(final Invocation invocation) throws Throwable {
    // 从 clients 数组中获取 ExchangeClient。为什么会有clients，为什么需要取模
    ExchangeClient currentClient;
    if (clients.length == 1) {
        currentClient = clients[0];
    } else {
        currentClient = clients[index.getAndIncrement() % clients.length];
    }
}
// Consumer 调用时，统计服务和方法维度的调用情况，如果并发数超过设置的最大值，则阻塞当前线程，直到前面有请求处理完成。
public Result ActiveLimitFilter#invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
    // 获取配置的最大并发调用数
    int max = invoker.getUrl().getMethodParameter(methodName, Constants.ACTIVES_KEY, 0);
    RpcStatus count = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());
    long remain = timeout;
    int active = count.getActive();
    if (active >= max) {
        synchronized (count) {
            while ((active = count.getActive()) >= max) {count.wait(remain);}
        }
    }
}
```

### 4、版本分组配置

|         | 作用范围           | 默认值 | 说明     | 备注                                                         |
| ------- | ------------------ | ------ | -------- | ------------------------------------------------------------ |
| group   | provider、consumer | dubbo  | 服务分组 | 必填。建议命名：<br />i/o: i表示内部服务,o表示外部服务 r/w: r表示读服务，w表示写服务，rw表示既有读也有写 如果同一接口不同实现，可以在g后添加后缀区分，例如: iwg_xxx不建议修改 |
| version | provider、consumer |        | 服务版本 | 必填。建议命名：<br/>数字.数字，从1.0开始，接口不兼容时才升级该值<br/>version升级步骤(1.0 -> 1.1)：<br /> - 发布1，保持1.0；<br />- 发布依赖1的服务；<br />- 无依赖0的服务后停止1.0； |

### 5、服务调用原则

**5.1 服务依赖**

应该避免同层服务之间调用，防止耦合、防止循环依赖。当同层服务之间需要调用时，建议增加一层组合服务；
下层服务禁止调用上层服务；

![image-20210719173628723](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210719173628723.png)

### 6、其他

**6.1 enum使用**

服务的 DTO 中禁止使用 enum，防止升级后不兼容, 导致报错

**6.2 服务定义工程(client)**

服务定义的工程中只能存在以下类：

接口、实体、常量、异常类、无任何其他依赖的简单工具类
通过maven的 deploy 插件将其部署到私服中。

业务公共模块规范暂时由业务自己定

**6.3 读写分离**

当服务读写分离时，需要将读方法与写方法定义到不同的接口，否则达不到读写分离的效果。
错误示例：

![image-20210720151926823](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210720151926823.png)

应该将getSetById和listSetInfoByCategory单独定义到一个读服务的接口中，将saveSet、updateSet、removeSet定义到另一个写服务的接口中。

**6.4 序列化**

大部分场景使用默认的序列化方式即可，但如果存在长度较长的list，可以考虑使用自定义的序列化方式pbmix

**6.5 调用链**

所有的dubbo服务需要接入调用链服务，方便线上跟踪问题：
http://columbus.os.adc.com/doc/detail?productId=5&selectedId=61



## Dubbo 问题解决

**1.java.util.concurrent.RejectedExecutionException 或者 Thread pool exhausted**

RejectedExecutionException 表示线程池已经达到最大值，并且没有空闲连，拒绝执行了一些任务。Thread pool exhausted 通常是 min 和 max 不一样大时，表示当前已创建的连接用完，进行了一次扩充，创建了新线程，但不影响运行。

1)原因可能是连接池不够用，请调整 dubbo.properites 中的：设成一样大，减少线程池收缩开销 

```properties
dubbo.service.min.thread.pool.size= 200 
dubbo.service.max.thread.pool.size= 200 
```

2）如果线程池已经有 200，还不够，通常是业务处理占用线程时间过长，需优化业务，可通过运行：
jstack 进程号 > jstack.txt 分析当前大多数线程都在干什么，从而分析出哪个地方是瓶颈，
比如，如果大部分线程都在处理SQL，可能是数据库连接不够，或数据源配置错误，或SQL没走索引等。



**2.调用超时 com.alibaba.dubbo.remoting.TimeoutException**

通常是业务处理太慢，可在服务提供方执行：jstack PID > jstack.log 分析线程都卡在哪个方法调用上，这里就是慢的原因。如果不能调优性能，请将timeout设大。



**3.Remote server returns error: [6], Got invocation exception**

此异常表示 Dubbo 框架调用服务提供者的实现方法失败，并且不是方法本身的业务异常。通常是服务消费者和服务提供者的 API 签名不一致引起，或者提供方比消费方少此函数。一般是服务增加方法，或修改了方法签名，而双方用的服务 API 的 jar 包不一致。



**4.客户端的异常信息里的errorcode是什么意思**

如 Remote server returns error: [6], Got invocation exception
1 — 收到消息的时候线程池拒绝处理
2 — 服务提供者端未能根据服务名找到相应服务
3 — 该服务调用时，服务提供者端不能加载参数类型对应的class
4 — 参数不能被正确的反序列化
5 — 不能正确从Class中create该调用所指示的方法
6 — 不能正确调用该方法



**5.Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'applicationName' of bean class [com.alibaba.dubbo.registry.internal.DefaultRegistryService]: Bean property 'applicationName' is not writable or has an invalid setter method.**

出现类似的 dubbo 某个类的属性没有setter方法的异常，通常是 classpath 下有多个不同版本的dubbo的jar包，导致配置文件与类不匹配。
可以在程序中运行下面的代码发现重复的类或jar包：(代码中的类名视具体冲突而定)

```java
Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources( "com/alibaba/dubbo/registry/internal/DefaultRegistryService.class" ); 
while (urls.hasMoreElements()) { 
     URL url = urls.nextElement(); 
     System.out.println( ">>>>>>>>>>>>>>>>>>>>>>" + url.getFile()); 
} 
```



**6.RpcException: No provider available for remote service**

表示没有可用的服务提供者
1）检查连接的注册中心是否正确
2） 到注册中心查看相应的服务提供者是否存在
3）检查服务提供者是否正常运行



**7. 如果服务注册不上**

1）检查 dubbo 的 jar 包有没有在 classpath 中，以及有没有重复的 jar 包；
2）检查有没有重复的 dubbo.properties 配置文件；
3）检查暴露服务的 spring 配置有没有加载；
4）检查 beanId 或 beanName 有没有重复；
5）查看有没有错误日志：cat ~/output/logs/webx.log
6）在服务提供者机器上测试与注册中心的网络是否通：telnet 172.22.3.94 9090
7）检查与注册中心的连接是否存在：netstat -anp | grep 172.22.3.94
8）如果是预发布机，检查 hosts 文件有没有正确绑定：cat /etc/hosts
9）开启远程调试：

- 在服务器 JVM 参数中加入：-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=7001,server=y,suspend=y
  注意线上只有 7001 和 8080 可以被线下访问，调试端口需用这两个之一，因注册是启动时行为，启动时必需挂起 suspend=y

- 在dubbo源码的DefaultRegistryService的registerService()方法中设置断点。
- 在Eclipse的Debug按钮下拉菜单Debug Configurations中的Remote Java Applications中新增远程调试，并设置IP和端口，以及增加dubbo的源码，进行远程Debug调试。



**8.hessian 序列化失败 com.caucho.hessian.client.HessianRuntimeException**

1）检查服务方法的传入传出参数是否实现 Serializable 接口
2） 检查服务方法的传入传出参数是否继承了 Number, Date, ArrayList, HashMap 等 hessian 特殊化处理的类



**9.Configuration problem: Unable to locate Spring NamespaceHandler for XML schema namespace**

表示spring找不到 \<dubbo:...> 配置的解析处理器。通常是 Dubbo 的jar没有引入，请加入对 Dubbo 的依赖，或者是 ClassLoader 隔离，看是否有使用 osgi 或其它热加载机制。



**10.消息发送失败异常**

通常是接口方法的传入传出参数未实现 Serializable 接口。



**11.org.xml.sax.SAXParseException: cvc-elt.1: Cannot find the declaration of element 'beans'**

表示 xsd 加载失败，
1）检查 spring 版本，如果是 spring2.0 版本，因为该版本不能读取 jar 包内 xsd，会读取外网的 xsd，而线上环境通常不允许访问外网。spring2.5.x版本不存在此问题，可以考虑升级到2.5.x版本。或修改 /etc/hosts 加入：(已将 spring 的 xsd 放在公司内部的 maven 仓库中)`10.20 . 133.138 [repo.alibaba-inc.com](http://repo.alibaba-inc.com) [www.springframework.org](http://www.springframework.org) `
2） 检查有没有使用 osgi 的 xsd，如果用了，需要将 spring-osgi.jar 及其依赖包加进来



**12.项目依赖的三方库与 Dubbo 所依赖的版本冲突**

比如，项目使用的 spring 和 commons.pool 与 dubbo 冲突，dubbo 使用的是 spring2.5 和commons.pool1.4，而项目中其它模块依赖的是 spring2.0.1 和 commons.pool1.3。
1）在Maven中，在项目根 pom.xml 中的 dependencyManagement 进行版本仲裁解决：

```java
< dependencyManagement >   
    < dependencies >    
        < dependency >      
            < groupId >com.alibaba.external</ groupId >      
            < artifactId >sourceforge.spring</ artifactId >      
            < version >2.0.1</ version >    
        </ dependency >    
        < dependency >      
            < groupId >com.alibaba.external</ groupId >      
            < artifactId >jakarta.commons.poolg</ artifactId >      
            < version >1.3</ version >    
        </ dependency >   
    </ dependencies > 
</ dependencyManagement > 
```



**13.com.alibaba.dubbo.registry.internal.rpc.exception.RpcLocalExceptionIoTargetIsNotConnected**

1）检查注册中心是否开启白名单功能，如果开启，当 IP 不在白名单列表中，注册中心将拒绝连接。
2） 检查端口是否正确，注册中心有两个端口，一个为控制台HTTP端口，用于管理员查看数据，一个为程序注册服务用的 TCP 端口。



**14.org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'xxxService': Initialization of bean failed; nested exception is java.lang.IllegalArgumentException: Method must not be null**

通常是 classpath下存在 spring 多个版本的 jar 包，排除掉不需要的 spring 包即可。

 

**15.服务提供者没挂，但在注册中心找不到服务**

1）确认服务提供者是否连接了正确的注册中心，不只是检查配置中的注册中心地址，而且要检查实际的网络连接。
2）看服务提供者是否非常繁忙，比如压力测试，以至于没有CPU片段向注册中心发送心跳，这种情况，减小压力，将自动恢复。

**16.ERROR monitor.StatLog -拒绝连接 java.net.ConnectException:拒绝连接com.alibaba.dubbo.monitor.StatLog.sendStatData**

监控中心不可用，发送统计信息失败，不影响调用，但将丢失统计信息。



**16.通过 netstat -anp 看到连接的注册中心和配置的不一样**

检查 classpath 下是否存在两个 dubbo.properties 文件：

```java
Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources( "dubbo.properties" ); 
while (urls.hasMoreElements()) { 
    URL url = urls.nextElement(); 
    System.out.println( ">>>>>>>>>>>>>>>>>>>>>>" + url.getFile()); 
} 
```

 

**17.预发布环境，在本地的 /etc/hosts 文件作了对注册中心的绑定，为什么服务还是注册到生产环境的注册中心**

antx.properties 中配置的

`dubbo.registry.address = [dubbo-reg1.hst.xyi.cn.alidc.net](http://dubbo-reg1.hst.xyi.cn.alidc.net) [dubbo-reg2.hst.xyi.cn.alidc.net](http://dubbo-reg2.hst.xyi.cn.alidc.net) [dubbo-reg3.hst.xyi.cn.alidc.net](http://dubbo-reg3.hst.xyi.cn.alidc.net) [dubbo-reg4.hst.xyi.cn.alidc.net](http://dubbo-reg4.hst.xyi.cn.alidc.net)`

而 /etc/hosts 里的绑定如下：
`172.22.14.13 [dubbo-reg1.hst.xyi.cn.alidc.net](http://dubbo-reg1.hst.xyi.cn.alidc.net) [dubbo-reg2.hst.xyi.cn.alidc.net](http://dubbo-reg2.hst.xyi.cn.alidc.net)`

两边的不一致，导致该问题出现,将绑定修改为：

`172.22.14.13 [dubbo-reg1.hst.xyi.cn.alidc.net](http://dubbo-reg1.hst.xyi.cn.alidc.net) [dubbo-reg2.hst.xyi.cn.alidc.net](http://dubbo-reg2.hst.xyi.cn.alidc.net) [dubbo-reg3.hst.xyi.cn.alidc.net](http://dubbo-reg3.hst.xyi.cn.alidc.net) [dubbo-reg4.hst.xyi.cn.alidc.net](http://dubbo-reg4.hst.xyi.cn.alidc.net) `

 

**18.注册中心上服务是存在的，为什么报找不到服务的错误**

报错信息： Caused by: com.alibaba.dubbo.rpc.RpcException: No invoker available for remote service com.alibaba.china.album.service.IBankNewPicService:1.0.0, servers: []

注册中心上看到的服务提供者提供的服务地址是：`[dubbo://172.29.61.76:55372?version=1.0.0&group=ibank&dubbo=1.0.0&application=ibank](dubbo://172.29.61.76:55372?version=1.0.0&group=ibank&dubbo=1.0.0&application=ibank)`
原因：服务提供者配置了 group 属性，默认的路由规则是 服务名 = group/serviceName。
对这个服务，根据默认的路由规则，消费者消费的服务名应该是ibank/com.alibaba.china.album.service.IBankNewPicService:1.0.0



**19.出现 Error closing connection/tbr-client java.lang.NullPointerException**

【略】如果服务提供者先关闭，当注册中心通知服务消费者后，服务消费者会再次关闭与服务提供者的连接，而此时连接早已不存在，TBRemoting 没有判断 null，直接调用了 close 方法，所以会抛出空指针异常，由于 TBRemoting 源码由 taobao 管理，暂时未解决此 BUG，但不影响使用，可忽略。Dubbo1.0.11-3 以后版本已 hack 了 taobao的代码，不存在此问题。

**20.服务地址出现 127.0.0.1**

【略】Dubbo1.0.7 以后版本不存在此问题，当发现本机 IP 为 127.0.0.1 时，将遍历所有网卡查找有效 IP。
之前版本处理方式：正确配置的IP映射，Linux 下为/etc/hosts，Windows 下为 C:/WINDOWS/system32/drivers/etc/hosts

假设：ifconfig 命令行结果为 10.20.130.230，hostname 命令行结果为 test2，则配置为：

`127.0 . 0.1 localhost 10.20 . 130.230 test2 `

**21.expected string at 0×33 java.lang.String**

【略】这是 Hessian3.2.1 的一个 BUG，Dubbo 内部使用 Hessian3.2.1 做序列化，升级到 Dubbo1.0.14 以上版本，已解决此问题。具体原因参见：
http://pt.alibaba-inc.com/wp/experience_929/hessian-big-string-serialize-problems.html

**22.获取版本号出现 java.lang.NullPointerException**

【略】java.lang.NullPointerException at com.alibaba.dubbo.classic.DubboVersion.getVersion
这个只有1.0.14和1.0.14-2存在的问题，在获取版本时静态字段初始化顺序不对，不影使用，可忽略，升级为1.0.15以上版本不再会有该问题。

**23.配置中如何使用占位符**

注：此为Spring的标准功能，仅在此提示使用方式，不属于 Dubbo 范畴。

使用 Spring 自带的 PropertyPlaceholderConfigurer 实现 properties 配置：

xxx=10.20.130.230:9090 
yyy=morgan 

```xml
<? xml version = "1.0" encoding = "UTF-8" ?> 
< beans xmlns = "http://www.springframework.org/schema/beans" 
     xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance" 
     xmlns:dubbo = "http://repo.alibaba-inc.com/schema/dubbo" 
     xsi:schemaLocation = "http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://repo.alibaba-inc.com/schema/dubbohttp://repo.alibaba-inc.com/schema/dubbo/dubbo-component.xsd" > 
  
     <!-- 使用Spring自带的占位符替换功能 --> 
     < bean class = "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" > 
         <!-- 指定properties配置所在位置 --> 
         < property name = "location" value = "classpath:xxx.properties" /> 
     </ bean > 
  
     <!-- 使用${}引用配置项 --> 
     < dubbo:registry address = "${xxx}" application = "${yyy}" /> 
  
</ beans > 
```

 

**24.使用多个进程启动服务，端口冲突**

注：此为Spring的标准功能，仅在此提示使用方式，不属于Dubbo范畴。

使用 Spring 自带的 PropertyPlaceholderConfigurer 的 SYSTEM_PROPERTIES_MODE_OVERRIDE 实现通过 -D 参数设置端口：`java -Ddubbo.service.server.port=20881 `

```xml
<? xml version = "1.0" encoding = "UTF-8" ?> 
< beans xmlns = "http://www.springframework.org/schema/beans" 
     xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance" 
     xmlns:dubbo = "http://repo.alibaba-inc.com/schema/dubbo" 
     xsi:schemaLocation = "http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://repo.alibaba-inc.com/schema/dubbohttp://repo.alibaba-inc.com/schema/dubbo/dubbo-component.xsd" > 
  
     <!-- 使用Spring自带的占位符替换功能 --> 
     < bean class = "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" > 
         <!-- 系统-D参数覆盖 --> 
         < property name = "systemPropertiesModeName" value = "SYSTEM_PROPERTIES_MODE_OVERRIDE" /> 
         <!-- 指定properties配置所在位置 --> 
         < property name = "location" value = "classpath:xxx.properties" /> 
     </ bean > 
  
     <!-- 使用${}引用配置项 --> 
     < dubbo:provider port = "${dubbo.service.server.port}" /> 
  
</ beans > 
```

 

 
