# Dubbo 初始化

[toc]

## 注册中心原理

### 1、概述

**1. 注册中心作用**

在Dubbo微服务体系中，注册中心是其核心组件之一。Dubbo通过注册中心实现了分布式环境中各服务之间的注册与发现，是各个分布式节点之间的纽带。其主要作用如下：

- 动态加入。一个服务提供者通过注册中心可以动态地把自己暴露给其他消费者，无须消费者逐个去更新配置文件。
- 动态发现。一个消费者可以动态地感知新的配置、路由规则和新的服务提供者，无须重启服务使之生效。
- 动态调整。注册中心支持参数的动态调整，新参数自动更新到所有相关服务节点。
- 统一配置。避免了本地配置导致每个服务的配置不一致问题。

**2. 注册中心流程**

注册中心的总体流程比较简单，不同的节点会注册并订阅（监听）不同的元数据，当元数据变化时会收到通知，并做出相应反应：

- 服务提供者启动时会向注册中心写入自己的元数据信息，同时会订阅配置元数据信息。
- 消费者启动时也会向注册中心写入自己的元数据信息，并订阅服务提供者、路由和配置元数据信息。
- 服务治理中心(dubbo-admin)启动时，会同时订阅所有消费者、服务提供者、路由和配置元数据信息。
- 当有服务提供者离开或有新的服务提供者加入时，注册中心服务提供者目录会发生变化，变化信息会动态通知给消费者、服务治理中心。
- 当消费方发起服务调用时,会异步将调用、统计信息等上报给监控中心（dubbo-monitor-simple）。

![dubbo-architucture](https://gitee.com/bruceyum/pictures/raw/master/pics/dubbo-architecture.jpg)

### 2、集成体系

![image-20210712201604005](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210712201604005.png)

AbstractRegistry 实现了 Registry 接口中的注册、订阅、查询、通知等方法，还实现了磁盘文件持久化注册信息这一通用方法。但是注册、订阅、查询、通知等方法只是简单地把 URL 加入对应的集合，没有具体的注册或订阅逻辑。FailbackRegistry 又继承了 AbstractRegistry, 重写了父类的注册、订阅、查询和通知等方法，并且添加了重试机制，具体的注册订阅等逻辑通过抽象模板方法，由子类（Zookeeper）实现。

### 3、数据结构

ZooKeeper 是树形结构的注册中心，每个节点的类型分为持久节点、持久顺序节点、临时节点和临时顺序节点。Dubbo 使用 ZooKeeper 作为注册中心时，只会创建持久节点和临时节点两种，对创建的顺序并没有要求。树形结构示例如下：

```
+ /dubbo
    +-- service
        +-- providers
        +-- consumers
        +-- routers
        +-- configurators
```

1) 树的根节点是注册中心分组，下面有多个服务接口，分组值来自用户配置 \<dubbo:registry> 中的 group 属性，默认是 /dubbo。
2) 服务接口下包含4类子目录，分别是 providers、consumers、routers、configurators, 这个路径是持久节点。
3) 服务提供者目录 (/dubbo/service/providers) 下面包含的接口有多个服务者 URL 元数据信息。
4) 服务消费者目录 (/dubbo/service/consumers) 下面包含的接口有多个消费者 URL 元数据信息。
5) 路由配置目录 (/dubbo/service/routers) 下面包含多个用于消费者路由策略 URL 元数据信息。
6) 动态配置目录 (/dubbo/service/configurators) 下面包含多个用于服务者动态配置URL元数据信息。

| 目录名称                     | 存储值样例                                                   |
| ---------------------------- | ------------------------------------------------------------ |
| /dubbo/service/providers     | dubbo://192.168.0.1.20880/com.alibaba.demo.Service?key=value&... |
| / dubbo/service/consumers    | consumer://192.168.0.1.5002/com. alibaba. demo. Service?key=value&... |
| /dubbo/service/routers       | condition: //0.0.0.0/com. alibaba. demo.Service?category=routers&key=value&... |
| /dubbo/service/configurators | override://0.0.0.0/com.alibaba.demo.Service?category=configurators&key=value&... |

在Dubbo框架启动时，会根据用户配置的服务，在注册中心中创建4个目录，在 providers 和 consumers 目录中分别存储服务提供方、消费方元数据信息，主要包括 IP、端口、权重和应用名等数据。
在 Dubbo 框架进行服务调用时，用户可以通过服务治理平台 (dubbo-admin) 下发路由配置。如果要在运行时改变服务参数，则用户可以通过服务治理平台 (dubbo-admin) 下发动态配置。服务器端会通过订阅机制收到属性变更，并重新更新已经暴露的服务。

### 4、注册|订阅

**1.服务注册**

ZooKeeper 发布代码非常简单，只是调用了ZooKeeper的客户端库在注册中心上创建一个目录，取消发布也很简单，只是把ZooKeeper注册中心上对应的路径删除。

```java
zkClient.create(toUrlPath(url)
zkClient.delete(toUrlPath(url));
```

**2.服务订阅**

ZooKeeper 注册中心采用的是“事件通知” + “客户端拉取”的方式，客户端在第一次连接上注册中心时，会获取对应目录下全量的数据。并在订阅的节点上注册一个watcher, 客户端与注册中心之间保持 TCP 长连接，后续每个节点有任何数据变化的时候，注册中心会根据 watcher 的回调主动通知客户端（事件通知），客户端接到通知后，会把对应节点下的全量数据都拉取过来（客户端拉取），这一点在 NotifyListener#notify（List\<URL> urls）接口上就有约束的注释说明。全量拉取有一个局限，当微服务节点较多时会对网络造成很大的压力。

在服务暴露时，服务端会订阅 configurators 用于监听动态配置。在消费端启动时，消费端会订阅 providers、routers 和 configurations 这三个目录，分别对应服务提供者、路由和动态配置变更通知。服务治理中心会处理所有service层的订阅，service被设置成特殊值*。此外，服务治理中心除了订阅当前节点，还会订阅这个节点下的所有子节点。

```java
List<URL> urls = new ArrayList<URL>();
for (String path : toCategoriesPath(url)) {//根据 URL 的类别，获取一组要订阅的路径
    ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);
    //如果 1isteners 缓存为空则创建缓存
    if (listeners == null) {
        zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());
        listeners = zkListeners.get(url);
    }
    ChildListener zkListener = listeners.get(listener);
    // zkListener 为空，说明是第一次，新建一个listener
    if (zkListener == null) {
        listeners.putIfAbsent(listener, new ChildListener() {
            // KEYPOINT 内部类的方法，不会立即执行，只会在触发变更通知时执行
            @Override
            public void childChanged(String parentPath, List<String> currentChilds) {
                ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));
            }
        });
        zkListener = listeners.get(listener);
    }
    zkClient.create(path, false);
    // KEYPOINT 【服务引用】
    List<String> children = zkClient.addChildListener(path, zkListener);
    if (children != null) {
        urls.addAll(toUrlsWithEmpty(url, path, children));
    }
}
// 回调 NotifyListener,更新本地缓存信息
notify(url, listener, urls);
```

注意，此处会根据URL中的category属性值获取具体的类别：providers、routers、consumers、configurators，然后拉取直接子节点的数据进行通知(notify)。如果是 providers 类别的数据，则订阅方会更新本地 Directory 管理的 Invoker 服务列表；如果是 routers 分类，则订阅方会更新本地路由规则列表；如果是configuators类别，则订阅方会更新或覆盖本地动态参数列表。

### 5、RedistryFactory

所有的注册中心实现，都是通过对应的工厂创建的，其类关系图如下：

![image-20210712201916405](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20210712201916405.png)

RedistryFactory 是一个扩展点，getRegistry 方法上有 @Adaptive({"protocol")) 注解，根据 Dubbo SPI 中自适应机制，当 ExtensionLoader 获取 RegistryFactory 扩展点实现时会由代理类根据URL中的 protocol 参数值获取具体的RegistryFactory 实现。

```java
@SPI("dubbo")
public interface RegistryFactory {
    @Adaptive({"protocol"})
    Registry getRegistry(URL url);
}
```

**1.AbstractRegistryFactory**

整体采用抽象工厂+ 模板方法设计模式，AbstractRegistryFactory 实现了 RegistryFactory 接口的 getRegistry(URL url) 方法，是一个通用实现，主要完成了加锁，以及调用抽象模板方法 createRegistry(URL url) 创建具体实现等操作，并缓存在内存中。抽象模板方法会由具体子类继承并实现。

```java
public Registry getRegistry(URL url) {
    LOCK.lock();//  加锁
    // 缓存未命中，调用模板方法创建 Registry 实例；
    Registry registry = REGISTRIES.get(key);
    registry = createRegistry(url);
}
```

**2.ZookeeperRegistryFactory**

```java
public Registry createRegistry(URL url) {
    return new ZookeeperRegistry(url, zookeeperTransporter);
}
public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {
    // 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter
    zkClient = zookeeperTransporter.connect(url);
}
```



## Dubbo 配置解析

### 1、Dubbo Shema

Dubbo 直接集成了 Spring的能力，利用了 Spring 配置文件扩展出自定义的解析方式。Dubbo 配置约束文件dubbo-conf ig/dubbo-conf igspring/src/main/resources/dubbo.xsd 中。Spring 在解析到自定义的namespace 标签时（比如＜dubbo:service＞标签），会查找对应的 spring.schemas 和 spring.handlers 文件，其中，spring.schemas文件指明约束文件的具体路径，spring.handlers 文件指明DubboNamespaceHandler类来解析标签。最终触发Dubbo 的 DubboNamespaceHandler 类来进行初始化和解析。

```properties
# spring.schemas 文件内容
http\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd
http\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/compat/dubbo.xsd
# spring.handlers 文件内容
http\://dubbo.apache.org/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler
http\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler
```

Dubbo schema 说明：

| 类型定义        | 功能概述                                                     |
| --------------- | ------------------------------------------------------------ |
| applicationType | 配置应用级别的信息，比如应用的名称、应用负责人和应用的版本等 |
| protocolType    | 配置服务提供者暴露的协议，Dubbo允许同时配置多个协议，但只能有一个协议默认暴露 |
| registryType    | 配置注册中心的地址和协议，Dubbo也允许多个注册中心同时使用    |
| providerlype    | 配置服务提供方的全局配置，比如服务方设置了timeout消费方会自动透传超时 |
| consumerType    | 配置消费方全局的配置，比如connections属性代表客户端会创建TCP的连接数，客户端全局配置会覆盖providerType透传的属性 |
| serviceType     | 配置服务提供方接口范围信息，比如服务暴露的接口和具体实现类等 |
| referenceType   | 配置消费方接口范围信息，比如引用的接口名称和是否泛化调用标志等 |
| moduleType      | 配置应用所属模块相关信息                                     |
| monitorType     | 配置应用监控上报相关地址                                     |
| methodType      | 配置方法级别参数，主要应用于＜dubbo:service＞和〈dubbo:reference〉子标签 |
| argumentType    | 配置应用方法参数等辅助信息，比如高级特性中异步参数回调索引的配置等 |
| parameterType   | 选项参数配置，可以作为＜dubbo:protocol〉、〈dubbo:service〉、〈dubbo:reference〉、＜dubbo:provider＞和〈dubbo:consumer〉子标签，方便添加自定义参数，会透传到框架的URL中 |

### 2、基于XML配置解析

从 spring.handlers 可知，主要解析逻辑入口是在 DubboNamespaceHandler 类中DubboNamespaceHandler主要把不同的标签关联至U解析实现类中o registerBeanDef initionParser 方法约定了在Dubbo框架中遇到标签application、module 和registry 等都会委托给DubboBeanDefinitionParser处理。

```java
public class DubboNamespaceHandler extends NamespaceHandlerSupport {
    @Override
    public void init() {
        // 委托给 DubboBeanDefinitionParser 进行解析
        registerBeanDefinitionParser("application", new DubboBeanDefinitionParser(ApplicationConfig.class, true));
        // ...
    }
}
```

**2.DubboBeanDefinitionParser**

DubboBeanDefinitionParser 就是把属性注入 Spring 框架的BeanDefinition。如果属性是引用对象，则 Dubbo默认会创建 RuntimeBeanReference 类型注入，运行时由Spring注入引用对象。通过对属性解析的理解，其实Dubbo 只做了属性提取的事情，运行时属性注入和转换都是 Spring 处理。

```java
private static BeanDefinition parse(Element element, ParserContext parserContext, Class<?> beanClass, boolean required) {
    // 1）把标签解析成对应的 Bean 定义并注册到 Spring 上下文中，同时保证了 Spring 容器中相同 id 的 Bean 不会被覆盖。向Spring注册BeanDefinition，后续会追加属性。
    RootBeanDefinition beanDefinition = new RootBeanDefinition();
    beanDefinition.setBeanClass(beanClass);
    parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);
    // 2）不同的配置类追加不同的属性,eg:<dubbo:service>
    if (ServiceBean.class.equals(beanClass)) {
        // 如果配置了 class属性，那么为具体class 配置的类注册 Bean,并注入 ref 属性
        String className = element.getAttribute("class");
        if (className != null && className.length() > 0) {
            RootBeanDefinition classDefinition = new RootBeanDefinition();
            classDefinition.setBeanClass(ReflectUtils.forName(className));  
            classDefinition.setLazyInit(false);
            parseProperties(element.getChildNodes(), classDefinition);
            beanDefinition.getPropertyValues().addPropertyValue("ref", new BeanDefinitionHolder(classDefinition, id + "Impl"));
        }
    }
    // 3）查找配置对象的get、set和is前缀方法，标签属性名和方法名称相同，则通过反射调用存储标签对应值。
    for (Method setter : beanClass.getMethods()) {
        // 把匹配到的属性注入Spring的Bean
        beanDefinition.getPropertyValues().addPropertyValue(propertyName, reference);
    }
    // 4）如果没有和get、set和is前缀方法匹配，则当作parameters参数存储，parameters 是一个Map对象。
    NamedNodeMap attributes = element.getAttributes();
    int len = attributes.getLength();
    for (int i = 0; i < len; i++) {
        parameters.put(name, new TypedStringValue(value, String.class));
    }
}
```





## Dubbo 服务暴露

### 1 整体流程

第一步将持有的服务实例通过代理转换成Invoker,第二步会把Invoker通过具体的协议（比如Dubbo）转换成Exporter, 框架做了这层抽象也大大方便了功能扩展。这里的Invoker可以简单理解成一个真实的服务对象实例，是Dubbo 框架实体域，所有模型都会向它靠拢，可向它发起invoke调用。它可能是一个本地的实现，也可能是一个远程的实现，还可能是一个集群实现。

![/dev-guide/images/dubbo_rpc_export.jpg](https://gitee.com/bruceyum/pictures/raw/master/pics/dubbo_rpc_export.jpg)

### 2 时序图

![dubbo服务暴露](https://gitee.com/bruceyum/pictures/raw/master/pics/dubbo服务暴露.png)

1. ServiceBean.export()
2. 为某种特定协议进行暴露，调用ProxyFactory.getInvoker生成Invoker代理类；调用RegistryProtocol.export的方法进行进行服务暴露
3. 生成代理Invoker，通过Javassist生成动态代理类，在代理类内部调用真正持有实例的方法。
4. 服务暴露：RegistryProtocol将服务提供者注册到注册中心并订阅 configurators 节点数据，调用DubboProtocol.refer() 方法提供服务。
5. 开发Netty服务：在DubboProtocol内部打开Netty服务器，绑定端口等。

### 3 核心源码

```java
registerBeanDefinitionParser("service", new DubboBeanDefinitionParser(ServiceBean.class, true));
public void onApplicationEvent(ContextRefreshedEvent event) {
    export();
}
public synchronized void export() {
    // 检测 <dubbo:service> 标签的 interface 属性合法性，不合法则抛出异常
	// 检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试从其他配置类对象中获取相应的实例。
	// 检测并处理泛化服务和普通服务类
	// 检测本地存根配置，并进行相应的处理
	// 对 ApplicationConfig、RegistryConfig 等配置类进行检测，为空则尝试创建，若无法创建则抛出异常
    doExport();
}
protected synchronized void doExport() {
    doExportUrls();
}
private void doExportUrls() {
    // 加载注册中心链接
    List<URL> registryURLs = loadRegistries(true);
    // 遍历 protocols，并在每个协议下导出服务
    for (ProtocolConfig protocolConfig : protocols) {
        doExportUrlsFor1Protocol(protocolConfig, registryURLs);
    }
}
protected List<URL> loadRegistries(boolean provider) {
    // 检测是否存在注册中心配置类，不存在则抛出异常
    checkRegistry();
    //构建参数映射集合，也就是 map
    //解析得到 URL 列表，address 可能包含多个注册中心 ip，构建注册中心链接列表
    List<URL> urls = UrlUtils.parseURLs(address, map);
    //遍历链接列表，并根据条件决定是否将其添加到 registryList 中
    for (URL url : urls) {
        url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());
        // 将 URL 协议头设置为 registry
        url = url.setProtocol(Constants.REGISTRY_PROTOCOL);
        // 通过判断条件，决定是否添加 url 到 registryList 中，条件如下：
        // (服务提供者 && register = true 或 null)
        //    || (非服务提供者 && subscribe = true 或 null)
        if ((provider && url.getParameter(Constants.REGISTER_KEY, true))
            || (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {
            registryList.add(url);
        }
    }
}
private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {
    // ====组装 URL====
    // side、版本、时间戳以及进程号等信息到 map 中
    // 通过反射将application、module、provider、protocolConfig等对象的字段信息添加到 map 中
    // 将 MethodConfig 添加到 map中
    // 检测 generic 是否为 "true"，并根据检测结果向 map 中添加不同的信息
    // 添加 token 到 map 中
    // 判断协议名是否为 injvm
    // 获取上下文路径、host 和 port，结合 map 生成待导出服务 URL
    // 加载 ConfiguratorFactory，并生成 Configurator 实例，然后通过实例配置 url
    // scope != remote，导出到本地
    if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {
        exportLocal(url);
    }
    // scope != local，导出到远程
    if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {
        for (URL registryURL : registryURLs) {// 多注册中心
        	// 加载监视器链接，将监视器链接作为参数添加到 url 中
            //通过动态代理转换成Invoker, registryURL存储的是注册中心地址，使用export作为key追加服务元数据信息
            Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
            // DelegateProviderMetaDataInvoker 用于持有 Invoker 和 ServiceConfig
            DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
            // 导出服务，并生成 Exporter；自适应扩展内部会根据URL 中 protocol 值决定调用哪个具体的Protocol实现类
            Exporter<?> exporter = protocol.export(wrapperInvoker);
            exporters.add(exporter);
        }
    }
}
public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
    // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'
    // KEYPOINT 为目标类创建 Wrapper：生成代理类代码code，调用javassist进行编译生成class，通过class生成实例
    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
    // 创建匿名 Invoker 类对象，并实现 doInvoke 方法。
    return new AbstractProxyInvoker<T>(proxy, type, url) {
        @Override
        protected Object doInvoke(T proxy, String methodName,
                                  Class<?>[] parameterTypes,
                                  Object[] arguments) throws Throwable {
            // KEYPOINT 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法
            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
        }
    };
}
public static Wrapper getWrapper(Class<?> c) {
    // 从缓存中获取 Wrapper 实例
    Wrapper ret = WRAPPER_MAP.get(c);
    // 缓存未命中，创建 Wrapper
    ret = makeWrapper(c);
}
private static Wrapper makeWrapper(Class<?> c) {
    // 1）创建 c1、c2、c3 以及 pts、ms、mns 等变量，以及向 c1、c2、c3 中添加方法定义和类型转换代码。为 
    // public 级别的字段生成条件判断取值与赋值代码。
    // 为定义在当前类中的方法生成判断语句，和方法调用语句。
    // 处理 getter、setter 以及以 is/has/can 开头的方法。处理方式是通过正则表达式获取方法类型（get/set/is/…），以及属性名。之后为属性名生成判断语句，然后为方法生成调用语句。
    // 通过 ClassGenerator 为刚刚生成的代码构建 Class 类，并通过反射创建对象。
}

public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {
    // 1）委托具体协议(Dubbo)进行服务暴露，创建NettyServer监听端口和保存服务实例。
    final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);
    // 2）加载 Registry 实现类，比如 ZookeeperRegistry，根据 register 的值决定是否注册服务
    final Registry registry = getRegistry(originInvoker);
    if (register) {
        register(registryUrl, registeredProviderUrl);
        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);
    }
    // 3）创建监听器，向注册中心进行订阅 override 数据,监听服务接口下 configurators
    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);
    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
    // 4）创建并返回 DestroyableExporter，服务销毁收尾工作，比如关闭端口、反注册服务信息等
    return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);
}
private <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker) {
    // 访问缓存
    ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);
    // 创建 Invoker 为委托类对象
    final Invoker<?> invokerDelegete = new InvokerDelegete<T>(originInvoker, getProviderUrl(originInvoker));
    // 调用 protocol 的 export 方法导出服务，具体调用哪个protocol根据url自适应获取
    exporter = new ExporterChangeableWrapper<T>((Exporter<T>) protocol.export(invokerDelegete), originInvoker);
}
public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
    // 获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如：
    String key = serviceKey(url);
    // 启动服务器
    openServer(url);
}
private void openServer(URL url) {
    // 获取 host:port，并将其作为服务器实例的 key，用于标识当前的服务器实例
    String key = url.getAddress();
    ExchangeServer server = serverMap.get(key);
    // 创建服务器实例
    serverMap.put(key, createServer(url));
}
private ExchangeServer createServer(URL url) {
    // 创建 ExchangeServer
    server = Exchangers.bind(url, requestHandler);
}
public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
    // 获取 Exchanger，默认为 HeaderExchanger。
    // 紧接着调用 HeaderExchanger 的 bind 方法创建 ExchangeServer 实例
    return getExchanger(url).bind(url, handler);
}
public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
    // 创建 HeaderExchangeServer 实例，该方法包含了多个逻辑，分别如下：
    //   1. new HeaderExchangeHandler(handler)
    //	 2. new DecodeHandler(new HeaderExchangeHandler(handler))
    //   3. Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler)))
    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));
}
public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException {
    // 获取自适应 Transporter 实例，并调用实例方法
    return getTransporter().bind(url, handler);
}
public Server bind(URL url, ChannelHandler listener) throws RemotingException {
    // 创建 NettyServer
    return new NettyServer(url, listener);
}
public AbstractServer(URL url, ChannelHandler handler) throws RemotingException {
    // 调用父类构造方法
    // 获取 ip 和端口，获取最大可接受连接数
    // 调用模板方法 doOpen 启动服务器
    doOpen();
}
protected void doOpen() throws Throwable {
    bootstrap = new ServerBootstrap();

    bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("NettyServerBoss", true));
    workerGroup = new NioEventLoopGroup(getUrl().
       getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),
            new DefaultThreadFactory("NettyServerWorker", true));

    final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this);
    channels = nettyServerHandler.getChannels();
    ChannelFuture channelFuture = bootstrap.bind(getBindAddress());
    channelFuture.syncUninterruptibly();
    channel = channelFuture.channel();

}
```



## Dubbo 服务引用

### 1、整体流程

第一步通过持有远程服务实例生成 Invoker, 这个Invoker 在客户端是核心的远程代理对象。第二步会把 Invoker 通过动态代理转换成实现用户接口的动态代理引用。这里的 Invoker 承载了网络连接、服务调用和重试等功能，在客户端，它可能是一个远程的实现，也可能是一个集群实现。服务引用的入口点在 ReferenceBean#getObject,不管是 XML 还是注解，都会转换成 ReferenceBean, 它继承自 ReferenceConfig。

![/dev-guide/images/dubbo_rpc_refer.jpg](https://gitee.com/bruceyum/pictures/raw/master/pics/dubbo_rpc_refer.jpg)





### 2、时序图

![dubbo服务引用](https://gitee.com/bruceyum/pictures/raw/master/pics/dubbo%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8.png)

1. ReferenceBean#getObject()
2. 创建代理类：调用 RegistryProtocol 的 refer 构建 Invoker 实例，根据Invoker生成代理类
3. 生成Invoker：生成服务目录，然后注册消费者并订阅providers、configurators、routers 等节点数据，将多个Invoker合并成一个集群Invoker。
4. 生成代理类：生成的代理类内部会调用Invoker.invoke()方法；
5. 服务目录实现Notify接口，成功注册并订阅后会执行notify方法，在内部调用DU币博Protocol.refer()方法，然后初始化Netty客户端，创建连接。

### 3、核心源码

```java
public void ReferenceBean#getObject() throws Exception {
    // Spring 会调用 getObject 方法，并由该方法执行服务引用逻辑。
    getObject();
}
public synchronized T ReferenceConfig#get() {
    // init 方法主要用于处理配置，以及调用 createProxy 生成代理类
    init();
}
private void ReferenceConfig#init() {
    // 1) 这段代码主要用于检测 ConsumerConfig 实例是否存在，如不存在则创建一个新的实例，然后通过系统变量或dubbo.properties 配置文件填充 ConsumerConfig 的字段。接着是检测泛化配置，并根据配置设置 interfaceClass 的值。
    // 2) 从系统属性或配置文件中加载与接口名相对应的配置，并将解析结果赋值给 url 字段。url 字段的作用一般是用于点对点调用。
    // 3) 检测application、module、regis等几个核心配置类是否为空，为空则尝试从其他配置类中获取
    // 4) 收集各种配置，并将配置存储到 map 中.
    // 5) 处理 MethodConfig 实例,该实例包含了事件通知配置，比如 onreturn、onthrow、oninvoke 等
    // 6) 解析服务消费者 ip，以及调用 createProxy 创建代理对象。
    ref = createProxy(map);
}
private T ReferenceConfig#createProxy(Map<String, String> map) {
    // 根据 url 的协议、scope 以及 injvm 等参数检测是否需要本地引用
    // 比如如果用户显式配置了 scope=local，此时 isInjvmRefer 返回 true
    final boolean isJvmRefer;
    // 【本地引用】则调用 InjvmProtocol 的 refer 方法生成 InjvmInvoker 实例
    if (isJvmRefer) {
        // 生成本地引用 URL，协议为 injvm
        URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);
        // 调用 refer 方法构建 InjvmInvoker 实例,使用injvm协议从内存中获取实例
        invoker = refprotocol.refer(interfaceClass, url);
    }
    // 【远程引用】
    // 加载注册中心 url，添加 refer 参数到 url 中，并将 url 添加到 urls 中
    List<URL> us = loadRegistries(false);
    for (URL u : us) {
        urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));
    }
    // 若 urls 元素数量大于1，即存在多个注册中心或服务直连 url，此时先根据 url 构建 Invoker。
    // 然后再通过 Cluster 合并多个 Invoker，最后调用 ProxyFactory 生成代理类
    // 多个注册中心或多个服务提供者，或者两者混合

    URL registryURL = null;
    if (urls.size() == 1) {
        // 调用 RegistryProtocol 的 refer 构建 Invoker 实例
        invoker = refprotocol.refer(interfaceClass, urls.get(0));
    }
    // 生成代理类
    return (T) proxyFactory.getProxy(invoker);
}
public <T> Invoker<T> RegistryProtocol#refer(Class<T> type, URL url) throws RpcException {
    // 取 registry 参数值，并将其设置为协议头
    // 获取注册中心实例，真实消费方的元数据信息是放在refer属性中存储的
    Registry registry = registryFactory.getRegistry(url);
    // group="a,b" or group="*"// 将 url 查询字符串转为 Map
    return doRefer(cluster, registry, type, url);
}
private <T> Invoker<T> RegistryProtocol#doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {
    // 【重要】创建 RegistryDirectory 实例，消费核心关键，持有实际Invoker和接收订阅通知；
    RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
    // 设置注册中心和协议
    directory.setRegistry(registry);
    directory.setProtocol(protocol);
    // all attributes of REFER_KEY
    Map<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());
    // 生成服务消费者链接
    URL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);
    // 【重要】注册服务消费者，在 consumers 目录下新节点
    if (!Constants.ANY_VALUE.equals(url.getServiceInterface())
        && url.getParameter(Constants.REGISTER_KEY, true)) {
        URL registeredConsumerUrl = getRegisteredConsumerUrl(subscribeUrl, url);
        registry.register(registeredConsumerUrl);
        directory.setRegisteredConsumerUrl(registeredConsumerUrl);
    }
    // 【重要】订阅 providers、configurators、routers 等节点数据
    // 第一次发起订阅时会进行一次数据拉取操作，同时触发 RegistryDirectory#notify 方法，
    // 这里的通知数据是某一个类别的全量数据，比如 providers 和 routers 类别数据。
    // 当通知 providers 数据时，在 RegistryDirectory#toInvokers 方法内完成 Invoker 转换。
    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,
                                                  Constants.PROVIDERS_CATEGORY + "," + Constants.CONFIGURATORS_CATEGORY + "," + Constants.ROUTERS_CATEGORY));

    // 【重要】一个注册中心可能有多个服务提供者，因此这里需要将多个服务提供者合并为一个
    Invoker invoker = cluster.join(directory);
    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);
    return invoker;
}
public synchronized void RegistryDirectory#notify(List<URL> urls) {
    // 定义三个集合invokerUrls、routerUrls、configuratorUrls，
    // 根据 category 参数将 url 分别放到不同的列表中分别用于存放服务提供者 url，路由 url，配置器 url
    invokerUrls.add(url);// 添加服务提供者 url
    // 刷新 Invoker 列表
    refreshInvoker(invokerUrls);
}
private void RegistryDirectory#refreshInvoker(List<URL> invokerUrls) {
    // 将 url 转成 Invoker，更新相关缓存
    Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);
    // 将 newUrlInvokerMap 转成方法名到 Invoker 列表的映射
    Map<String, List<Invoker<T>>> newMethodInvokerMap = 		
        toMethodInvokers(newUrlInvokerMap);
}
private Map<String, Invoker<T>> RegistryDirectory#toInvokers(List<URL> urls) {
    for (URL providerUrl : urls) {
        // 检测服务提供者协议是否被服务消费者所支持
        // 合并provider端配置数据，比如服务端IP等
        URL url = mergeUrl(providerUrl);
        // 根据SPI机制，使用具体协议创建Invoker
    	invoker = new InvokerDelegate<T>(protocol.refer(serviceType, url), url, providerUrl);
        // 缓存 Invoker 实例
        newUrlInvokerMap.put(key, invoker);
    }
    
}
public <T> Invoker<T> DubboProtocol#refer(Class<T> serviceType, URL url) throws RpcException {
    optimizeSerialization(url);
    // 创建 DubboInvoker
    // getClients 这个方法用于获取客户端实例，实例类型为 ExchangeClient。
    // ExchangeClient 实际上并不具备通信能力，它需要基于更底层的客户端实例进行通信。
    // 比如 NettyClient、MinaClient 等，默认情况下，Dubbo 使用 NettyClient 进行通信
    DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);
    invokers.add(invoker);
    return invoker;
}
private ExchangeClient[] DubboProtocol#getClients(URL url) {
     // 初始化新的客户端
    ExchangeClient[] clients = new ExchangeClient[connections];
    clients[i] = initClient(url);
}
private ExchangeClient initClient(URL url) {
    // 获取客户端类型，默认为 netty
    // 添加编解码和心跳包参数到 url 中
    // 连接服务器，创建客户端
    client = Exchangers.connect(url, requestHandler);
}
public static ExchangeClient Exchangers#connect(URL url, ExchangeHandler handler) throws RemotingException {
    // 获取 Exchanger SPI 实例，默认为 HeaderExchangeClient
    return getExchanger(url).connect(url, handler);
}
public ExchangeClient HeaderExchanger#connect(URL url, ExchangeHandler handler) throws RemotingException {
    // 这里包含了多个调用，分别如下：
    // 1. 创建 HeaderExchangeHandler 对象
    // 2. 创建 DecodeHandler 对象
    // 3. 通过 Transporters 构建 Client 实例
    // 4. 创建 HeaderExchangeClient 对象
    return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);
}
public static Client Transporters#connect(URL url, ChannelHandler... handlers) throws RemotingException {
    // 如果 handler 数量大于1，则创建一个 ChannelHandler 分发器
    handler = new ChannelHandlerDispatcher(handlers);
    // 获取 Transporter 自适应拓展类，并调用 connect 方法生成 Client 实例
    return getTransporter().connect(url, handler);
}
public Client NettyTransporter#connect(URL url, ChannelHandler listener) throws RemotingException {
    return new NettyClient(url, listener);
}
public NettyClient(final URL url, final ChannelHandler handler) {
    super(url, wrapChannelHandler(url, handler));
}
public AbstractClient(URL url, ChannelHandler handler) throws RemotingException {
    // 模板方法由子类实现：打开 Netty 服务器
    doOpen();
    // 连接服务器
    connect();
}
protected void doOpen() throws Throwable {
    // 初始化 Netty 客户端及对应的 ChannelHandler
    bootstrap = new Bootstrap();
    bootstrap.group(nioEventLoopGroup)...
    bootstrap.handler(new ChannelInitializer() {...});
}
protected void connect() throws RemotingException {
    doConnect();// 和哪个服务器建立连接？
}
protected void doConnect() throws Throwable {
    ChannelFuture future = bootstrap.connect(getConnectAddress());
}
public <T> T AbstractProxyFactory#getProxy(Invoker<T> invoker) throws RpcException {
    return getProxy(invoker, false);
}
public <T> T AbstractProxyFactory#getProxy(Invoker<T> invoker, boolean generic) throws RpcException {
    // 获取接口列表
    // 为 http 和 hessian 协议提供泛化调用支持，参考 pull request #1827
    // 调用抽象模板方法，由子类实现
    return getProxy(invoker, interfaces);
}
public <T> T JavassistProxyFactory#getProxy(Invoker<T> invoker, Class<?>[] interfaces) {
    // 1. 生成 Proxy 子类（Proxy 是抽象类），并调用 Proxy 子类的 newInstance 方法创建 Proxy 实例
    // 2. new InvokerInvocationHandler(invoker)，调用InvokerInvocationHandler.invoke()
    // 3. 这里是MockClusterInvoker -> XxxClusterInvoker -> DubboInvoker.invoke()
    return (T) Proxy.getProxy(interfaces).newInstance(new 
                     InvokerInvocationHandler(invoker));
}
public static Proxy Proxy#getProxy(ClassLoader cl, Class<?>... ics) {
    // 生成代理类，代理类持有 InvocationHandler 实例， InvocationHandler 持有 Invoker；
    // 代理类方法调用 InvocationHandler.invoke()方法，示例如下；
    proxy = (Proxy) pc.newInstance();
}
// 代理类示例
package org.apache.dubbo.common.bytecode;

public class proxy0 implements org.apache.dubbo.demo.DemoService {

    public static java.lang.reflect.Method[] methods;

    private java.lang.reflect.InvocationHandler handler;

    public proxy0() {
    }

    public proxy0(java.lang.reflect.InvocationHandler arg0) {
        handler = $1;
    }

    public java.lang.String sayHello(java.lang.String arg0) {
        Object[] args = new Object[1];
        args[0] = ($w) $1;
        Object ret = handler.invoke(this, methods[0], args);
        return (java.lang.String) ret;
    }
}
```

