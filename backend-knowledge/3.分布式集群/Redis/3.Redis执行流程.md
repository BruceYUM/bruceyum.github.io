# Redis执行流程

[toc]


## 数据库

### 1、RedisDB

Redis 服务器将所有数据库都保存在服务器状态 redis.h/redisServer 结构的 db 数组中，db 数组的每个项都是一个 redis.h/redisDb 结构，每个 redisDb 结构代表一个数据库,在初始化服务器时，程序会根据服务器状态的 dbnum 属性来决定应该创建多少个数据库：

![img](https://note.youdao.com/yws/api/personal/sync?method=download&fileId=WEB0dea513136b6de53ae9bc1905615fe38&version=3468&cstk=6lqG8sux)

### 2、键空间

Redis 是一个键值对（key-value pair）数据库服务器， redisDb 结构的 dict 字典保存了数据库中的所有键值对， 我们将这个字典称为键空间（key space）.

键空间和用户所见的数据库是直接对应的：

- 键空间的键也就是数据库的键， 每个键都是一个字符串对象。
- 键空间的值也就是数据库的值， 每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象在内的任意一种 Redis 对象。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/2015-09-13_55f5228ad7f7c.png)

当使用 Redis 命令对数据库进行读写时， 服务器不仅会对键空间执行指定的读写操作， 还会执行一些额外的维护操作， 其中包括：

- 在读取一个键之后（读操作和写操作都要对键进行读取）， 服务器会根据键是否存在， 以此来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数。
- 在读取一个键之后， 服务器会更新键的 LRU （最后一次使用）时间， 这个值可以用于计算键的闲置时间， 使用命令 OBJECT idletime  命令可以查看键 key 的闲置时间。
- 如果服务器在读取一个键时， 发现该键已经过期， 那么服务器会先删除这个过期键， 然后才执行余下的其他操作。
- 如果有客户端使用 WATCH 命令监视了某个键， 那么服务器在对被监视的键进行修改之后， 会将这个键标记为脏（dirty）， 从而让事务程序注意到这个键已经被修改过。
- 服务器每次修改一个键之后， 都会对脏（dirty）键计数器的值增一， 这个计数器会触发服务器的持久化以及复制操作执行。
- 如果服务器开启了数据库通知功能， 那么在对键进行修改之后， 服务器将按配置发送相应的数据库通知。

### 3、过期删除策略

- 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。
- 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。
- 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。

**Redis 惰性删除**

过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：
- 如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。
- 如果输入键未过期，那么expireIfNeeded函数不做动作。

**Redis定期删除**

过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。

- 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。
- 全局变量 current_db 会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。
- 随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。

**过期删除-持久化**

在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。
当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。
和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。

**过期删除-主从复制**

当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：
- 主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。
- 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。
- 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。



## 事件

### 1、文件事件

Redis 基于 Reactor 模式开发了自己的网络事件处理器： 这个处理器被称为文件事件处理器（file event handler），文件事件处理器的四个组成部分， 它们分别是套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。

- 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

- 虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/graphviz-3c09f0e53bd9d786aa646e5e4c289a11d97d40d7.png)

尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/graphviz-a06632048a0970072c8a20c202c9a0efeb07ddb6.png)


**1. I/O 多路复用**

Redis 的 I/O 多路复用程序的所有功能都是通过包装常见的 select 、 epoll 、 evport 和 kqueue 这些 I/O 多路复用函数库来实现的， 每个 I/O 多路复用函数库在 Redis 源码中都对应一个单独的文件， 比如 ae_select.c 、 ae_epoll.c 、 ae_kqueue.c ， 诸如此类。

Redis 在 I/O 多路复用程序的实现源码中用 #include 宏定义了相应的规则， 程序会在编译时自动选择系统中性能最高的 I/O 多路复用函数库来作为 Redis 的 I/O 多路复用程序的底层实现

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/2015-09-13_55f524bea64ce.png)

**2. 事件的类型**

I/O 多路复用程序可以监听多个套接字的 ae.h/AE_READABLE 事件和 ae.h/AE_WRITABLE 事件， 这两类事件和套接字操作之间的对应关系如下：

- 当套接字变得可读时（客户端对套接字执行 write 操作，或者执行 close 操作）， 或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行 connect 操作）， 套接字产生 AE_READABLE 事件。
- 当套接字变得可写时（客户端对套接字执行 read 操作）， 套接字产生 AE_WRITABLE 事件。

I/O 多路复用程序允许服务器同时监听套接字的 AE_READABLE 事件和 AE_WRITABLE 事件， 如果一个套接字同时产生了这两种事件， 那么文件事件分派器会优先处理 AE_READABLE 事件， 等到 AE_READABLE 事件处理完之后， 才处理 AE_WRITABLE 事件。

**3. 文件事件的处理器**

- 连接应答处理器：当 Redis 服务器进行初始化的时候， 程序会将这个连接应答处理器和服务器监听套接字的 AE_READABLE 事件关联起来， 当有客户端用sys/socket.h/connect 函数连接服务器监听套接字的时候， 套接字就会产生 AE_READABLE 事件， 引发连接应答处理器执行， 并执行相应的套接字应答操作。

- 命令请求处理器：当一个客户端通过连接应答处理器成功连接到服务器之后， 服务器会将客户端套接字的 AE_READABLE 事件和命令请求处理器关联起来， 当客户端向服务器发送命令请求的时候， 套接字就会产生 AE_READABLE 事件， 引发命令请求处理器执行， 并执行相应的套接字读入操作

- 命令回复处理器：当服务器有命令回复需要传送给客户端的时候， 服务器会将客户端套接字的 AE_WRITABLE 事件和命令回复处理器关联起来， 当客户端准备好接收服务器传回的命令回复时， 就会产生 AE_WRITABLE 事件， 引发命令回复处理器执行， 并执行相应的套接字写入操作

- 复制处理器：当主服务器和从服务器进行复制操作时， 主从服务器都需要关联特别为复制功能编写的复制处理器

**4. API**

ae.c/aeCreateFileEvent 函数接受一个套接字描述符、 一个事件类型、 以及一个事件处理器作为参数， 将给定套接字的给定事件加入到 I/O 多路复用程序的监听范围之内， 并对事件和事件处理器进行关联。

ae.c/aeDeleteFileEvent 函数接受一个套接字描述符和一个监听事件类型作为参数， 让 I/O 多路复用程序取消对给定套接字的给定事件的监听， 并取消事件和事件处理器之间的关联。

ae.c/aeGetFileEvents 函数接受一个套接字描述符， 返回该套接字正在被监听的事件类型。

ae.c/aeWait 函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数， 在给定的时间内阻塞并等待套接字的给定类型事件产生， 当事件成功产生， 或者等待超时之后， 函数返回。

ae.c/aeApiPoll 函数接受一个 sys/time.h/struct timeval 结构为参数， 并在指定的时间內， 阻塞并等待所有被 aeCreateFileEvent 函数设置为监听状态的套接字产生文件事件， 当有至少一个事件产生， 或者等待超时后， 函数返回。

ae.c/aeProcessEvents 函数是文件事件分派器， 它先调用 aeApiPoll 函数来等待事件产生， 然后遍历所有已产生的事件， 并调用相应的事件处理器来处理这些事件。

**5. 存在问题**

Redis 6.0 的多线程：Redis 6.0 的多线程方面是针对网络 I/O 部分的，事件处理部分还是走的单线程处理

问题：Redis 基本 IO 模型中还有哪些潜在的性能瓶颈<br>
在 Redis 基本 I/O 模型中，主要是主线程在执行操作，任何耗时的操作，例如 bigkey、全量返回等操作，都是潜在的性能瓶颈。使用 scan 代替 keys 等全量返回


### 2、时间事件

**1. 时间事件定义**

时间事件分为两类：定时事件和周期性事件（周期性事件就是连续执行定时事件）。

- id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。
- when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。
- timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。
- 时间事件放在链表中，时间事件执行器运行时就遍历该链表，查找到达的时间事件并调用相应的事件处理器。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/1A7554E2617B44D993CD3293ED97F710)

**2. API**

ae.c/aeCreateTimeEvent 函数接受一个毫秒数 milliseconds 和一个时间事件处理器 proc 作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的 milliseconds 毫秒之后到达，而事件的处理器为 proc。

ae.c/aeDeleteFileEvent 函数接受一个时间事件 ID 作为参数，然后从服务器中删除该 ID 所对应的时间事件。

ae.c/aeSearchNearestTimer 函数返回到达时间距离当前时间最接近的那个时间事件。

ae.c/processTimeEvents 函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。已到达指的是，时间事件的 when 属性记录的 UNIX 时间戳等于或小于当前时间的 UNIX 时间戳。

**3. serverCron函数**

serverCron 函数持续运行的 Redis 服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由 redis.c/serverCron 函数负责执行，默认每秒 10 次，可通过 hz 选项调整。它的主要工作包括：
- 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。
- 清理数据库中的过期键值对。
- 关闭和清理连接失效的客户端。
- 尝试进行 AOF 或 RDB 持久化操作。
- 如果服务器是主服务器，那么对从服务器进行定期同步。
- 如果处于集群模式，对集群进行定期同步和连接测试。

### 3、事件调度执行

```python
def main():
    #初始化服务器
    init_server()
    #一直处理事件，直到服务器关闭为止
    while server_is_not_shutdown():
        aeProcessEvents()
    #服务器关闭，执行清理操作
    clean_server()
    
def aeProcessEvents():
    #获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    #计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    #如果事件已到达，那么remaind_ms的值可能为负数，将它设定为0
    if remaind_ms ＜ 0:
        remaind_ms = 0
    #根据remaind_ms的值，创建timeval结构
    timeval = create_timeval_with_ms(remaind_ms)
    #阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定
    #如果remaind_ms的值为0，那么aeApiPoll调用之后马上返回，不阻塞
    aeApiPoll(timeval)
    #处理所有已产生的文件事件
    processFileEvents()
    #处理所有已到达的时间事件
    processTimeEvents()

```

- Redis 是单线程的但是要处理两种事件，由 aeProcessEvents 函数负责调度与执行。
- aeApiPoll 函数阻塞直到文件事件出现，其阻塞时间由到达时间最接近当前时间的时间事件决定，可以避免服务器对时间事件频繁的轮询(忙等待)，也可以确保不会阻塞太长时间。
- 两种事件都是同步、有序、原子地执行，所以要尽可能减小程序阻塞时间，有时需主动让出执行权以降低事件饥饿可能性。如，命令回复写入客户端套接字时，写入字数超过预设常量，命令回复器就会 break，余下数据下次再写。另外，耗时的持久化操作会放到子线程执行。
服务器的 main 函数逻辑
- 因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。


## 客户端

一个服务器可以与多个客户端建立网络连接，对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构

Redis 服务器状态结构的 clients 属性是一个链表，保存了所有已连接客户端的状态结构。使用CLIENT LIST命令查看。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/graphviz-4b22fe21bc9e6d2be18d04b0c11b6aafc41e27b2.png)


RedisClient 属性解析

```c
typedef struct redisClient {
    int fd;
    robj *name;
    int flags;
    sds querybuf;
    robj **argv;
    int argc;
    struct redisCommand *cmd;
    char buf[REDIS_REPLY_CHUNK_BYTES];
    int bufpos;
    list *reply;
    
    int authenticated;
    time_t ctime;
    time_t lastinteraction;
    time_t obuf_soft_limit_reached_time;
} redisClient;
```
1. 套接字描述符(fd)：客户端状态的 fd 属性记录了客户端正在使用的套接字描述符。
- 伪客户端（fake client）的 fd 属性的值为 -1 ： 伪客户端处理的命令请求来源于 AOF 文件或者 Lua 脚本， 而不是网络， 所以这种客户端不需要套接字连接，
- 普通客户端的 fd 属性的值为大于 -1 的整数： 普通客户端使用套接字来与服务器进行通讯， 服务器会用 fd 属性来记录客户端套接字的描述符。 

2. 名字(name)：使用 CLIENT_SETNAME 命令可以为客户端设置一个名字， 让客户端的身份变得更清晰。

3. 标志(flags)：客户端的标志属性 flags 记录了客户端的角色（role）， 以及客户端目前所处的状态。flags 属性的值可以是单个标志，也可以是多个标志的二进制。例如，REDIS_MASTER 标志表示客户端代表的是一个主服务器， REDIS_SLAVE 标志表示客户端代表的是一个从服务器。
```
# 客户端是一个主服务器
REDIS_MASTER

# 客户端正在被列表命令阻塞
REDIS_BLOCKED

# 客户端正在执行事务，但事务的安全性已被破坏
REDIS_MULTI | REDIS_DIRTY_CAS

# 客户端是一个从服务器，并且版本低于 Redis 2.8
REDIS_SLAVE | REDIS_PRE_PSYNC

# 这是专门用于执行 Lua 脚本包含的 Redis 命令的伪客户端
# 它强制服务器将当前执行的命令写入 AOF 文件，并复制给从服务器
REDIS_LUA_CLIENT | REDIS_FORCE_AOF | REDIS_FORCE_REPL
```

4. 输入缓冲区(querybuf)： 输入缓冲区用于保存客户端发送的命令请求；输入缓冲区的大小会根据输入内容动态地缩小或者扩大， 但它的最大大小不能超过 1 GB ， 否则服务器将关闭这个客户端。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/2015-09-13_55f5264e6a9d0.png)

5. 命令与命令参数： 服务器将对 querybuf 内容进行分析， 并将得出的命令参数以及命令参数的个数分别保存到客户端状态的 argv 和 argc 属性中 。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/2015-09-13_55f52651e2773.png)

6. 命令实现函数(cmd)：当服务器从协议内容中分析并得出 argv 属性和 argc 属性的值之后， 服务器将根据项 argv[0] 的值， 在命令表中查找命令所对应的命令实现函数。当程序在命令表中成功找到 argv[0] 所对应的 redisCommand 结构时， 它会将客户端状态的 cmd 指针指向这个结构

![img](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f52651e2773.png)

7. 输出缓冲区：执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面， 每个客户端都有两个输出缓冲区可用， 一个缓冲区的大小是固定的 buf 默认 16 KB， 另一个缓冲区的大小是可变的 relay：
- 固定大小的缓冲区用于保存那些长度比较小的回复， 比如 OK 、简短的字符串值、整数值、错误回复，等等。
- 可变大小的缓冲区用于保存那些长度比较大的回复， 比如一个非常长的字符串值， 一个由很多项组成的列表， 一个包含了很多元素的集合， 等等。

当 buf 数组的空间已经用完， 或者回复因为太大而没办法放进 buf 数组里面时， 服务器就会开始使用可变大小缓冲区

lua_client伪客户端用于执行lua脚本的命令，在服务器整个生命期一直存在；aof文件伪客户端在载入aof文件时存在。


## 服务器

### 1、命令请求的执行过程

1. 命令发送：Client 将命令发给 Cerver；
2. 参数解析：Server 读取命令（存入 querybuffer），并分析命令参数（存入 argv 和 argc 属性）；
3. 命令查找：命令执行器根据参数查找命令的实现函数（根据argv[0]，在命令表中查找指定的 redisCommand，并保存在 cmd 属性中）
4. 预备执行：检查参数个数是否正确，是否通过身份验证等等
5. 命令执行：调用 client->cmd->proc(client) 执行命令，并产生相应的命令回复， 这些回复会被保存在客户端状态的输出缓冲区里面（buf 属性和 reply属性）， 之后实现函数还会为客户端的套接字关联命令回复处理器， 这个处理器负责将命令回复返回给客户端。
6. 后续工作：耗时统计，写入 AOF 缓冲区，命令传播给从服务器等
7. 命令恢复：客户端的套接字关联命令回复处理器， 当客户端套接字变为可写状态时， 服务器就会执行命令回复处理器， 将保存在客户端输出缓冲区中的命令回复发送给客户端。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/2015-09-13_55f526d942468.png)

### 2、serverCron 函数

Redis 周期性操作函数 serverCron 默认每 100ms 执行一次，用于对正在运行的服务器进行维护。其执行的操作有如下：

1. 更新服务器时间缓存：为了减少获取系统时间的系统调用，服务器状态的 unixtime 和 mstime 属性缓存当前时间；
2. 更新 LRU 时钟：lruclock属性缓存当前时间，用于计算键的空闲时间，serverCron每10秒更新该属性。服务器的 lruclock 属性记录的时间减去对象的 lru 属性记录的时间，得出的计算结果就是这个对象的空转时间
3. 更新服务器每秒执行命令次数：这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量。
4. 更新服务器内存峰值记录；
5. 处理SIGTERM信号：Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识
6. 管理客户端资源。serverCron 每次执行都调用 clientsCron 函数。
7. 管理数据库资源：每次都会调用databaseCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作。
8. 执行被延迟的 BGREWRITEAOF：服务器的 aof_rewrite_scheduled 标识记录了服务器是否延迟了BGREWRITEAOF命令。
9. 检查持久化操作的运行状态：每次serverCron函数执行时，程序都会检查rdb_child_pid和aof_child_pid两个属性的值，
    - 只要其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程，如果有信号到达，那服务器就进行相应的后续操作（替换 RDB/AOF 文件）
    - 都为-1，查看是否有BGREWRITEAOF被延迟了，如果有的话，那么开始一次新的BGREWRITEAOF操作；
    - 都为-1，检查 save 选项所设置的条件是否满足，若满足执行BGSAVE；
    - 都为-1，查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器将开始一次新的BGREWRITEAOF操作

    ![img](https://gitee.com/bruceyum/pictures/raw/master/pics/graphviz-0ba4963a397efe2b4badfd5a33bbfecc2b9cb00a.png)

10. 将AOF缓冲区中的内容写入AOF文件


### 3、服务器初始化

1. 初始化服务器状态结构：设置服务器的运行ID，运行频率，配置文件路径等。
2. 载入配置选项：载入用户给定的配置参数和配置文件，并根据用户设定的配置，对server变量相关属性的值进行修改。
3. 初始化服务器的数据结构：初始化server.clients链表，server.db数组，执行Lua脚本的Lua环境server.lua，保存慢查询日志的server.slowlog属性等。并为服务器设置进程信号处理器，创建共享对象，打开服务器的监听端口，为serverCron函数创建时间事件等
4. 还原数据库状态（载入 AOF或 RDB 文件）
5. 执行事件循环。

## 其它

### LUA脚本


概念

Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。


优势

- 减少网络开销: 不使用 Lua 的代码需要向 Redis 发送多次请求, 而脚本只需一次即可, 减少网络传输;

- 原子操作: Redis 将整个脚本作为一个原子执行, 无需担心并发, 也就无需事务;

- 复用: 脚本会永久保存 Redis 中, 其他客户端可继续使用.


eval的语法格式

EVAL script numkeys key [key ...] arg [arg ...]

其中：

- script： 你的lua脚本

- numkeys: key的个数

- key: redis中各种数据结构的替代符号

- arg: 你的自定义参数


示例1

eval "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 username age hk 20
第一个参数的字符串是script，也就是lua脚本，2表示keys的个数，KEYS[1] 就是username的占位符, KEYS[2]就是
age的占位符，ARGV[1]就是jk的占位符，ARGV[2]就是20的占位符,以此类推，所以最后的结果应该就是:{return username age hk 20}


示例2:执行Lua脚本文件的方式

- keys.lua脚本文件

return {
KEYS,
type(KEYS),
'-----',
ARGV,
type(ARGV)
}

- 执行语句和结果

[root@centos1 lua]# redis-cli --eval keys.lua k1 k2 , v1 v2
1) 1) "k1"
2) "k2"
2) "table"
3) "-----"
4) 1) "v1"
2) "v2"
5) "table"

### Redis客户端

Jedis定义
jedis就是集成了redis的一些命令操作，封装了redis的java客户端。提供了连接池管理。一般不直接使用jedis，而是在其上再封装一层，作为业务的使用


RedisTemplate

关于spring-redis
连接池自动管理，提供了一个高度封装的“RedisTemplate”类
针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口
提供了对key的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即BoundKeyOperations
将事务操作封装，有容器控制
针对数据的“序列化/反序列化”，提供了多种可选择策略(RedisSerializer)


Jedis与Redisson对比有什么优缺点？

Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。


### 缓存淘汰策略


概念

Redis缓存淘汰策略与Redis键的过期删除策略并不完全相同，前者是在Redis内存使用超过一定值的时候（一般这个值可以配置）使用的淘汰策略；而后者是通过定期删除+惰性删除两者结合的方式进行内存淘汰的。
这里参照官方文档的解释重新叙述一遍过期删除策略：当某个key被设置了过期时间之后，客户端每次对该key的访问（读写）都会事先检测该key是否过期，如果过期就直接删除；

但有一些键只访问一次，无法在访问该key时，去判断是否过期进行删除，因此需要主动删除，默认情况下redis每秒检测10次，检测的对象是所有设置了过期时间的键集合，每次从这个集合中随机检测20个键查看他们是否过期，如果过期就直接删除，如果删除后还有超过25%的集合中的键已经过期，那么继续检测过期集合中的20个随机键进行删除。这样可以保证过期键最大只占所有设置了过期时间键的25%。


ZERO、Redis 内存不足的缓存淘汰策略

- noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键
- allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键
- volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键
- allkeys-random：加入键的时候如果过限，从所有key随机删除
- volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐
- volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键
- volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键
- allkeys-lfu：从所有键中驱逐使用频率最少的键


**1、LRU**

Java中的LRU实现方式

在Java中LRU的实现方式是使用HashMap结合双向链表，HashMap的值是双向链表的节点，双向链表的节点也保存一份key value。

新增key value的时候首先在链表结尾添加Node节点，如果超过LRU设置的阈值就淘汰队头的节点并删除掉HashMap中对应的节点。

修改key对应的值的时候先修改对应的Node中的值，然后把Node节点移动队尾。

访问key对应的值的时候把访问的Node节点移动到队尾即可。


Redis中LRU的实现

Redis维护了一个24位时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟。每个key对象内部同样维护了一个24位的时钟，当新增key对象的时候会把系统的时钟赋值到这个内部对象时钟。比如我现在要进行LRU，那么首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰，这里值得注意的是全局时钟只有24位，按秒为单位来表示才能存储194天，所以可能会出现key的时钟大于全局时钟的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。


redis算法差别

Redis中的LRU与常规的LRU实现并不相同，常规LRU会准确的淘汰掉队头的元素，但是Redis的LRU并不维护队列，只是根据配置的策略要么从所有的key中随机选择N个（N可以配置）要么从所有的设置了过期时间的key中选出N个键，然后再从这N个键中选出最久没有使用的一个key进行淘汰。


**2、LFU**

概念：LFU是在Redis4.0后出现的，LRU的最近最少使用实际上并不精确，考虑下面的情况，如果在|处删除，那么A距离的时间最久，但实际上A的使用频率要比B频繁，所以合理的淘汰策略应该是淘汰B。LFU就是为应对这种情况而生的。

A~~A~~A~~A~~A~~A~~A~~A~~A~~A~~<br>
B~~~~~B~~~~~B~~~~~B~~~~~~~~~~B 

实现

LFU把原来的key对象的内部时钟的24位分成两部分，前16位还代表时钟，后8位代表一个计数器。
16位的情况下如果还按照秒为单位就会导致不够用，所以一般这里以时钟为单位。而后8位表示当前key对象的访问频率，8位只能代表255，但是redis并没有采用线性上升的方式，而是通过一个复杂的公式，通过配置两个参数来调整数据的递增速度。
下图从左到右表示key的命中次数，从上到下表示影响因子，在影响因子(越大计数器改变越慢)为100的条件下，经过10M次命中才能把后8位值加满到255.
lfu-log-factor 10

lfu-decay-time 1

| factor | 100 hits | 1000 hits | 100K hits | 1M hits | 10M hits |
|:--------:|:------------:|:------------:|:------------:|:------------:|:------------:|
| 0 | 104 | 255 | 255 | 255 | 255 |
| 1 | 18 | 49 | 255 | 255 | 255 |
| 10 | 10 | 18 | 142 | 255 | 255 |
| 100 | 8 | 11 | 49 | 143 | 255 |

上面说的情况是key一直被命中的情况，如果一个key经过几分钟没有被命中，那么后8位的值是需要递减的，具体递减多少根据衰减因子lfu-decay-time来控制

上面递增和衰减都有对应参数配置，那么对于新分配的key呢？如果新分配的key计数器开始为0，那么很有可能在内存不足的时候直接就给淘汰掉了，所以默认情况下新分配的key的后8位计数器的值为5（可配置），防止因为访问频率过低而直接被删除。

低8位我们描述完了，那么高16位的时钟是用来干嘛的呢？目前我的理解是用来衰减低8位的计数器的，就是根据这个时钟与全局时钟进行比较，如果过了一定时间（做差）就会对计数器进行衰减


配置：在配置文件有一行：

\# maxmemory-policy volatile-lru

具体实现在evict.c文件中，当redis需要通过释放缓存的key来释放空间时，将会通过ecict.c的freeMemoryIfNeeded()函数来通过设定的算法来清除key以腾出空间。

## Redis事务

Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH  四个原语实现的。

- MULTI 命令用于开启一个事务，它总是返回 OK；
- DISCARD 可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
- WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行；

Redis会将一个事务中的所有命令序列化，然后一次性地按顺序执行。

事务执行过程中，如果服务端收到有 EXEC、DISCARD、WATCH、MULTI 之外的请求，将会把请求放入队列中排队。

Redis 事务的三个阶段：1. 事务开始 MULTI；2. 命令入队；3. 事务执行 EXEC。

Redis 不支持回滚:如果在一个事务中的命令出现错误，那么所有的命令都不会执行；如果在一个事务中出现运行错误，那么其他正确的命令会被执行。

Redis的事务总是具有 ACID 中的一致性（指数据符合定义和要求，无无效或错误数据。通过命令入队错误、执行错误保证）和隔离性（单进程单线程而且不会中断事务），在参数 appendfsyn 为 always 时可以保证持久性，不能保证原子性。

其他方法实现事务：基于 Lua 脚本，Redis 可以保证脚本内的命令一次性、按顺序地执行。

## 发布与订阅(了解即可)

- 服务器状态在 pubsub channels字典保存了所有频道的订阅关系: SUBSCRIBE 命令负责将客户端和被订阅的频道关联到这个字典里面,而 UNSUBSCRIBE命令则负责解除客户端和被退订频道之间的关联。
- 服务器状态在 pubsub patterns链表保存了所有模式的订阅关系: PSUBSCRIBE 命令负责将客户端和被订阅的模式记录到这个链表中,而 PUNSUBSCRIBE命令则负责移除客户端和被退订模式在链表中的记录。
- PUBLISH命令通过访问 pubsub channels字典来向频道的所有订阅者发送消息, 通过访问 pubsub patterns链表来向所有匹配频道的模式的订阅者发送消息
- PUBSUB命令的三个子命令都是通过读取 pubsub channels字典和 pubsub patterns链表中的信息来实现的。


常用命令

PSUBSCRIBE pattern [pattern ...]：订阅一个或多个符合给定模式的频道。

PUBSUB subcommand [argument [argument ...]]：查看订阅与发布系统状态。

PUBLISH channel message：将信息发送到指定的频道。

PUNSUBSCRIBE [pattern [pattern ...]]：退订所有给定模式的频道。

SUBSCRIBE channel [channel ...]：订阅给定的一个或多个频道的信息。

UNSUBSCRIBE [channel [channel ...]]：指退订给定的频道。

巨坑无比没什么人使用，之前做项目的时候使用了下，监听key过期，结果key过期是惰性过期，搞得很无奈。
