# 分布式事务

[toc]

## 分布式事务问题

### 1、问题描述

单体数据库不涉及网络交互，所以在多表之间实现事务是比较简单的，这种事务我们称之为本地事务。

但是单体数据库的性能达到瓶颈的时候，就需要分库(分物理实例)，就会出现跨库(数据库实例)的事务需求；随着企业应用的规模越来越大，企业会进一步进行服务化改造，以满足业务增长的需求；当前微服务架构越来越流行，跨服务的事务场景也会越来越多。

这些都是分布式事务的需求。分布式事务是指是指事务的发起者、参与者、数据资源服务器以及事务管理器分别位于分布式系统的不同节点之上。

概括起来，分布式事务有三种场景：

- 跨数据库分布式事务
- 跨服务分布式事务
- 混合式分布式事务

![图片](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKmlWsfcSEzQjWsYvsVbyAoz5ic6kPc9zqxGLuyhNRkYia5ibek0QwNeYfG3Wa9lBGJXEfHKqxKh4fVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



分布式事务中涉及的参与者分布在异步网络中，参与者通过网络通信来达到分布式一致性，网络通信不可避免出现失败、超时的情况，因此分布式事务的实现比本地事务面临更多的困难。当出现部分业务操作成功、部分业务操作失败时，业务数据就会出现不一致。

### 2、问题示例

例如电商行业中比较常见的下单付款案例，包括下面几个行为：

1. 创建新订单
2. 扣减商品库存
3. 从用户账户余额扣除金额

完成上面的操作需要访问三个不同的微服务和三个不同的数据库。

![image-20200304204442839](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20200304204442839.png)

在分布式环境下，肯定会出现部分操作成功、部分操作失败的问题，比如：订单生成了，库存也扣减了，但是用户账户的余额不足，这就造成数据不一致。

订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。

但是当我们把三件事情看做一个事情事，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是分布式系统下的事务了。

此时ACID难以满足，这是分布式事务要解决的问题

## CAP & BASE

### 1、CAP

分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。

![img](https://gitee.com/bruceyum/pictures/raw/master/pics/a14268b3-b937-4ffa-a34a-4cc53071686b.jpg)<br>

一致性：一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。

对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。

可用性：可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。

在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

分区容忍性：网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。

在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。

权衡

在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。

可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，

- 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；
- 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。

举例子：A，B 两座城市（可以看成是两个网络分区），我们无法保证两个城市之间的网络一定没有问题。
正常情况下 user1 在A城市修改数据，会立即同步到B城市，
保证可用性，那么将将旧的数据返回给用户，但是A、B之间网络故障就无法保证数据一致性了。
保证一致性，等A、B的网络恢复，数据同步之后才提供服务

### 2、BASE

BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。

BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。


基本可用

指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。

例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。

软状态

指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。

最终一致性

最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。

ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。

在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。

### 3、解决方案

分布式事务有多种主流形态，包括：

- 基于 2PC/3PC 实现的分布式事务
- 基于 TCC 实现的分布式事务
- 基于 Saga 实现的分布式事务
- 基于事务消息实现的分布式事务

- 最大努力通知类型 (消息补偿) 的分布式事务

基于 XA 协议的二阶段提交协议方法和三阶段提交协议方法，采用了强一致性，遵从ACID，基于消息的最终一致性方法，采用了最终一致性，遵从 BASE 理论。之所以有这么多形态，是**因为任何事情都没有银弹，只有最合适当前场景的解决方案**。

| 常见实现 | 一致性保证 | 业务友好性 | 性能 | 优缺点                                                       |
| -------- | ---------- | ---------- | ---- | ------------------------------------------------------------ |
| ByteTCC  | 强一致性   | 非常复杂   | 低   | 基于TCC机制，与Spring容器无缝集成，兼容Spring的声明式事务管理。提供对dubbo、Spring Cloud的开箱即用的支持，可满足多数据源、跨应用、跨服务器等各种分布式事务场景的需求；但是缺少大规模落地案例，而且需要侵入业务，实现较为复杂，复杂业务实现幂等有难度 |
| LCN      | 强一致性   | 简单       | 低   | 该框架与其他第三方的框架兼容性强，支持所有的关系型数据库事务，支持多数据源，支持与第三方数据库框架一块使用（如 sharding-jdbc），对业务的侵入性低。但是缺少大规模落地案例，可能会造成死锁，且性能不强 |
| Atomikos | 强一致性   | 简单       | 低   | 兼容标准的JTA API，支持嵌套事务，为XA和非XA提供内置的JDBC适配器； Atomikos对池中connection的管理效率随着连接数的上升，呈现指数级的下降，且缺少大规模落地案例 |
| RocketMQ | 最终一致性 | 复杂       | 高   | 具有重试、消息持久化机制，且管理界面较为完善，同时公司内对于该框架有方便的部署；但是具体实现起来比较麻烦 |
| Seata    | 多种模式   | 一般       | 高   | 性能较高，且是阿里开源的框架（可靠性较高）；但是没有管理化界面，且会造成数据的脏读 |
| DTX      | 多种模式   | 一般       | 高   | 蚂蚁开源的框架（属于中间件SOFA中的组件），拥有多种模式，包括基于BASE理论的TCC模式(侵入式)，基于ACID理论的FMT模式（非侵入式），基于标准XA规范的XA模式（高性能）。同时能够实现对于金融场景的全面覆盖，以及拥有金融级品质的保障。但是需要审批购买 |

基于上述对比，打算采用RocketMQ作为分布式事务最终一致性的解决方案，该方案适用于非核心交易链路，有一定的时间容忍度。如果有业务涉及强一致性，建议采用Seata的TCC模式来解决，比如说传统的订单服务、库存服务等，走的是核心交易链路，属于相对重要的逻辑，而Seata框架的TCC模式具有强一致性，比较适用于该场景。

## 分阶段提交

### 1、2PC/XA

XA 规范中定义了分布式事务处理模型，这个模型中包含四个核心角色：

- RM (Resource Managers)：资源管理器，提供数据资源的操作、管理接口，保证数据的一致性和完整性。最有代表性的就是数据库管理系统，当然有的文件系统、MQ 系统也可以看作 RM。

- TM (Transaction Managers)：事务管理器，是一个协调者的角色，协调跨库事务关联的所有 RM 的行为。

- AP (Application Program)：应用程序，按照业务规则调用 RM 接口来完成对业务模型数据的变更，当数据的变更涉及多个 RM 且要保证事务时，AP 就会通过 TM 来定义事务的边界，TM 负责协调参与事务的各个 RM 一同完成一个全局事务。

- CRMs (Communication Resource Managers)：主要用来进行跨服务的事务的传播。

下图是 XA 规范中定义的事务模型图，其中：发起分布式事务的 TM 实例称之为 root 节点，其他的 TM 实例可以统称为事务的参与者。事务发起者负责开启整个全局事务，事务参与者各自负责执行自己的事务分支。如果TM实例发起了对其他 TM 实例的服务调用，那么发起者就被称为 Superior，被调用这就被称为 Subordinate 节点。

![图片](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKmlWsfcSEzQjWsYvsVbyAoicwHMpQZyxZccLQuHicu0JibI79LFMov1yQibeOIDIuu0vDdjhZUWLyUfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

XA 规范中分布式事务是构建在 RM 本地事务（此时本地事务被看作分支事务）的基础上的，TM 负责协调这些分支事务要么都成功提交、要么都回滚。XA 规范把分布式事务处理过程划分为两个阶段，所以又叫两阶段提交协议（two phrase commit）：

**1.预备阶段**

TM 记录事务开始日志，并询问各个 RM 是否可以执行提交准备操作。

RM 收到指令后，评估自己的状态，尝试执行本地事务的预备操作：预留资源，为资源加锁、执行操作等，但是并不提交事务，并等待 TM 的后续指令。如果尝试失败则告知 TM 本阶段执行失败并且回滚自己的操作，然后不再参与本次事务（以 MySQL 为例，这个阶段会完成资源的加锁，redo log 和 undo log 的写入）。

TM 收集 RM 的响应，记录事务准备完成日志。

**2.提交/回滚阶段**

这个阶段根据上个阶段的协调结果发起事务的提交或者回滚操作。

如果所有 RM 在上一个步骤都返回执行成功，那么：

- TM 记录事务 commit 日志，并向所有 RM 发起事务提交指令。

- RM 收到指令后，提交事务，释放资源，并向 TM 响应“提交完成”。

- 如果 TM 收到所有 RM 的响应，则记录事务结束日志。

如果有 RM 在上一个步骤中返回执行失败或者超时没有应答，则 TM 按照执行失败处理，那么：

- 记录事务 abort 日志，向所有 RM 发送事务回滚指令。

- RM 收到指令后，回滚事务，释放资源，并向 TM 响应回滚完成。

- 如果 TM 收到所有 RM 的响应，则记录事务结束日志。

![图片](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKmlWsfcSEzQjWsYvsVbyAotlExuicGBy9Obyt8LkWo2IsVTWE5GKptjdoEaPEZ9q1nVXxcIKwHUBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



针对部分场景，XA 规范还定义了如下优化措施：

- 如果 TM 发现整个事务只涉及到一个 RM，那么就会将整个过程退化为一阶段提交。

- 如果 RM 收到的 AP 的数据操作是只读操作，那么它可以在阶段 1 就将事务完成并告知 TM 其不再参与阶段 2 的过程。会有脏读的风险。

- 如果 RM 在阶段1完成后，长时间等不到阶段 2 的指令，那么其可以自动提交或者回滚本地事务。这叫做 Heuristic Completion，注意这种场景有可能会破坏事务的一致性，产生异常。

XA 规范中详细定义了各个核心组件之间的交互接口，以 TM 和 RM 的交互接口为例，如下图，一次完整的全局事务，TM 和 RM 之间的交互还是比较频繁的：

![图片](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKmlWsfcSEzQjWsYvsVbyAoiaH54jenYF4YeYYAwryJwfibwv83UIIrtRibmnT12V4kKlrXgzquc7McQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



事务的执行过程中，宕机和网络超时都有可能发生，针对这些异常场景，不同 XA 规范的实现，对异常处理做法可能不同，可参考如下：

- TM 在阶段 1 中询问 RM 前宕机，恢复后无需做任何操作。

- TM 在阶段 1 中询问 RM 后宕机，可能只有部分 RM 收到了阶段 1 的请求，因此此时需要向 RM 发起回滚请求。

- TM 在阶段 1 中询问 RM 完毕，但是在就准备完成日志时宕机，因不清楚宕机前的事务协商的结果，因此恢复后需要向 RM 发起回滚请求。

- TM 在阶段 1 中记录完毕事务准备完成日志后宕机，恢复后可以根据日志发起提交或者回滚的指令。

- TM 在阶段 2 中记录 commit/abort 日志前宕机，恢复后可以根据日志发起提交或者回滚指令。

- TM 在阶段 2 中记录事务结束日志前宕机，恢复后可以根据日志发起提交或者回滚指令。

- TM 在阶段 2 中记录事务结束日志后宕机，恢复后无需做任何操作。

- 阶段 1 中，RM 有超时情况时，TM 按失败处理，给所有 RM 发送回滚指令。

- 阶段 2 中，RM 有超时情况是，TM 需要对超时的 RM 持续重复发送指令。

### 2、3PC

针对 XA 两阶段提交中的问题，有人提出了三阶段提交的改进方案，三阶段提交方案主要解决了单点故障问题，并在 RM 侧也引入了超时机制，以避免资源的长时间锁定。但是三阶段提交方案依然无法避免脑裂的异常情况出现。

三阶段提交协议（Three-phase commit protocol，3PC），是对二阶段提交（2PC）的改进。为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了超时机制和准备阶段。

- 投票阶段：协调者向参与者发送请求操作（CanCommit请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No。
- 预提交：如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预提交：参与者接收到 PreCommit 请求后执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。假如任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就中断事务。
- 提交阶段：DoCmmit 阶段进行真正的事务提交，所有的参与者都成功就执行提交操作，否则终端事务。

### 3、2PC 特点

**ACID支持**

- 原子性：在 prepare 和 commit 阶段保证事务是原子性的。

- 一致性：XA 议实现的是强一致性。

- 隔离性：XA 事务在完成之前一直持有资源的锁，所以可以做到写隔离。

- 持久性：基于本地事务实现，所以这一点没有问题。

**优点**

- XA 是在资源管理层面实现的分布式事务模型，对业务的入侵度较低。

**缺点**

- 同步阻塞：XA 两阶段提交协议可以覆盖分布式事务的三种场景，但是全局事务的执行过程中，RM 一直持有资源的锁，如果参与的 RM 过多，尤其是跨服务的场景下，网络通信的次数和时间会急剧变多，所以阻塞的时间更长，系统的吞吐能力变得很差，事务死锁出现的概率也会变大，所以并不适合微服务架构场景中的跨服务的分布式事务模式。

- 单点故障：每一个 TM 域来说，由于 TM 是单点，存在单点故障风险，如果 TM 在阶段1之后挂掉，会导致参与的 RM 长时间收不到阶段 2 的请求而长期持有资源的锁，影响业务的吞吐能力。同时一次完整的全局事务，TM 和 RM 之间的交互多达 8 次，太繁琐，非常影响系统的处理性能。

- 数据不一致：XA 两阶段协议可能会造成脑裂的异常，假如 TM 在阶段 2 通知 RM 提交事务时，如果指令发出后就宕机了，而只有部分 RM 收到了提交请求，那么当 TM 恢复的时候，就无法协调本次事务所有的 RM 本地事务的一致性了。

- 太过保守：任意一个节点失败就会导致整个事务失败，没有完善的容错机制。
- 2PC 除了性能和可靠性上存在问题，它的适用场景也很局限，它要求参与者实现了 XA 协议，例如使用实现了 XA 协议的数据库作为参与者可以完成 2PC 过程。但是在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。所以 2PC 在分布式应用场景中很少使用。

XA 是出现最早的分布式事务规范，主流数据库 Oracle、MySQL、SQLServer 等都支持 XA 规范，J2EE 中的 JTA 规范也是参照 XA 规范编写的，与 XA 规范兼容。

2PC 和 3PC 这两种方法，有两个共同的缺点，一是都需要锁定资源，降低系统性能；二是，没有解决数据不一致的问题。看不懂3PC到底要干什么？？？投票阶段什么情况回复Yes，什么情况回复No; 提交阶段如果有个消息发送失败，造成部分本地事务未提交怎么办？？？

XA 要处理的异常场景非常多，对框架的实现有一定的挑战，开源的实现，可以参考：Atomikos，Bitronix。

其适用于参与者较少，单个本地事务执行时间较少，并且参与者自身可用性很高的场景，否则，其很可能导致性能下降严重。

## TCC 

### 1、TCC 过程

TCC 就是一种解决多个微服务之间的分布式事务问题的方案。TCC (Try、Commit、Cancel) 是一种补偿型事务，该模型要求应用的每个服务提供 try、confirm、cancel 三个接口，它的核心思想是通过对资源的预留（提供中间态），尽早释放对资源的加锁，如果事务可以提交，则完成对预留资源的确认，如果事务要回滚，则释放预留的资源。

TCC 也是一种两阶段提交协议，可以看作 2PC/XA 的一种变种，本质是一个应用层面上的 2PC，但是不会长时间持有资源锁。

- **准备阶段** ：协调者调用所有的每个微服务提供的 try 接口，将整个全局事务涉及到的资源锁定住，若锁定成功 try 接口向协调者返回 yes。
- **提交阶段** ：若所有的服务的 try 接口在阶段一都返回 yes，则进入提交阶段，协调者调用所有服务的 confirm 接口，各个服务进行事务提交。如果有任何一个服务的 try 接口在阶段一返回 no 或者超时，则协调者调用所有服务的 cancel 接口。

![image-20200305155521612](D:/BaiduNetdiskDownload/%E7%AC%94%E8%AE%B0/assets/image-20200305155521612.png) 



粗看似乎与两阶段提交没什么区别，但其实差别很大：

- try、confirm、cancel 都是独立的事务，不受其它参与者的影响，不会阻塞等待其它事务
- try、confirm、cancel 由程序员在业务层编写，锁粒度有代码控制

2PC 过程中单点故障问题：由于应用服务通常都是集群部署，单个服务器故障并不影响其它服务正常运行。

通过重试解决网络二将军问题导致的数据不一致：由于 try 操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功（所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK）。

这里还有个关键问题，在不断重试 confirm 和 cancel 的过程中（考虑到网络二将军问题的存在）有可能重复进行了 confirm 或 cancel，因此还要再保证 confirm 和 cancel 操作具有幂等性，也就是整个全局事务中，每个参与者只进行一次 confirm 或者 cancel。实现 confirm 和 cancel 操作的幂等性，有很多解决方案，例如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 confirm 或 cancel 操作，若已经进行过，则不再重复执行。

### 2、 TCC 示例

我们以一个简单的电商系统为例，小明在淘宝上花 100 元买了一本书，获赠 10 个积分，产品上有如下几个操作：

- 订单系统创建商品订单
- 支付系统接受小明的支付
- 库存系统扣减产品库存

这几个动作需要作为一个事务执行，要同时成功或者同时撤销。

如果采用 TCC 事务模式，那么各个系统需要改造为如下状态：

1）订单系统

- try：创建一个订单，状态显示为“待支付”
- confirm：更新订单的状态为“已完成”
- cancel：更新订单的状态为“已取消”

2）支付系统

- try：假设小明账户中有 1000 元，冻结小明账户中的 100 元，此时小明看到的余额依然是 1000 元。
- confirm：将账户余额变为 900 元，并清除冻结记录。
- concel：清除冻结记录。

3）库存系统

- try：假设库存中还生 10 本书，冻结其中的一本书，现实库存依然有 10 本书。
- confirm：将剩余库存更新为 9 本书，并清除冻结记录。
- cancel：清除冻结记录。

### 3、TCC 特点

**ACID 支持**

- 原子性：事务发起方协调各个分支事务全部提交或者全部回滚。
- 一致性：TCC 事务提供最终一致性。
- 隔离型：通过 try 预分配资源的方式来实现数据的隔离。锁定预分配资源，二阶段可异步执行？
- 持久性：交由各个分支事务来实现。

**优点**

- TCC 执行的每一个阶段都会提交本地事务并释放锁，并不需要等待其它事务的执行结果。而如果其它事务执行失败，最后不是回滚，而是执行补偿操作。这样就避免了资源的长期锁定和阻塞等待，执行效率比较高，属于性能比较好的分布式事务方式。TCC 事务将分布式事务从资源层提到业务层来实现，可以让业务灵活选择资源的锁定粒度，并且全局事务执行过程中不会一直持有锁，所以系统的吞吐量比 2PC/XA 模式要高很多。

**缺点**

- 代码侵入：需要人为编写代码实现try、confirm、cancel，代码侵入较多
- 开发成本高：一个业务需要拆分成3个步骤，分别编写业务实现，业务编写比较复杂
- 安全性考虑：cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试时的幂等问题

同时 TCC 事务为了解决异步网络中的通信失败或超时带来的异常情况，要求业务方在设计实现上要遵循三个策略：

- 允许空回滚：原因是异常发生在阶段 1 时，部分参与方没有收到 try 请求从而触发整个事务的 cancel 操作，try 失败或者没有执行 try 操作的参与方收到 cancel 请求时，要进行空回滚操作。

- 保持幂等性：原因是异常发生在阶段 2 时，比如网络超时，则会重复调用参与方的 confirm/cancel 方法，因此需要这两个方法实现上保证幂等性。

- 防止资源悬挂：原因网络异常导致两个阶段无法保证严格的顺序执行，出现参与方侧 try 请求比 cancel 请求更晚到达的情况，cancel 会执行空回滚而确保事务的正确性，但是此时 try 方法也不可以再被执行。

TCC 实际上是相对更复杂的一种情况，其能处理所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。

- 对事务有一定的一致性要求（最终一致）
- 对性能要求较高
- 开发人员具备较高的编码能力和幂等处理经验

支持 TCC 事务的开源框架有：ByteTCC、Himly、TCC-transaction。

## Saga

### 1、Saga 过程

Saga 并不是一个新概念，其相关论文在 1987 年就发布了，和 XA 两阶段提交规范出现的时间差不多。Saga 和 TCC 一样，也是一种补偿事务，但是它没有 try 阶段，而是把分布式事务看作一组本地事务构成的事务链。

事务链中的每一个正向事务操作，都对应一个可逆的事务操作。Saga 事务协调器负责按照顺序执行事务链中的分支事务，分支事务执行完毕，即释放资源。如果某个分支事务失败了，则按照反方向执行事务补偿操作。

假如一个 Saga 的分布式事务链有 n 个分支事务构成，[T1,T2,...,Tn]，那么该分布式事务的执行情况有三种：

- T1,T2,...,Tn：n 个事务全部执行成功了。

- T1,T2,...,Ti,Ci,...,C2,C1：执行到第 i (i<=n) 个事务的时候失败了，则按照 i->1 的顺序依次调用补偿操作。如果补偿失败了，就一直重试。补偿操作可以优化为并行执行。

- T1,T2,...,Ti (失败),Ti (重试),Ti (重试),...,Tn：适用于事务必须成功的场景，如果发生失败了就一直重试，不会执行补偿操作。

![图片](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKmlWsfcSEzQjWsYvsVbyAo8QBlNT5fIicHYTovvjknUPUdewNuiaUnfTIb4cd2cYoOe26OIEZoftNA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 2、Saga 示例

假如国庆节小明要出去玩，从北京出发，先去伦敦，在伦敦游玩三天，再去巴黎，在巴黎游玩三天，然后再返回北京。整个行程中涉及不同航空公司的机票预订以及伦敦和巴黎当地的酒店预订，小明的计划是如果任何一张机票或酒店预订不上，就取消本次出行计划。假如综合旅游出行服务平台提供这种一键下单的功能，那么这就是一个长事务，用 Saga 模式编排服务的话，就如下图所示：任何一个环节失败的话，就通过补偿操作取消前面的行程预订。

![图片](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKmlWsfcSEzQjWsYvsVbyAofYfplWLwkRfh0IHghyfdXX9yDEc9BnOXrAXldOE9lJDAyEqibYMQDlA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 3、Saga 特点

**ACID 支持**

- 原子性：Saga 协调器可以协调事务链中的本地事务要么全部提交，要么全部回滚。

- 一致性：Saga 事务可以实现最终一致性。

- 持久性：基于本地事务，所以这个特性可以很好实现。

- 隔离性：但是 Saga 不保证事务隔离性的，本地事务提交后变更就对其他事务可见了。其他事务如果更改了已经提交成功的数据，可能会导致补偿操作失败。比如扣款失败，但是钱已经花掉了，业务设计上需要考虑这种场景并从业务设计上规避这种问题。

Saga 事务和 TCC 事务一样，对业务实现要求高，要求业务设计实现上遵循三个策略：

- 允许空补偿：网络异常导致事务的参与方只收到了补偿操作指令，因为没有执行过正常操作，因此要进行空补偿。

- 保持幂等性：事务的正向操作和补偿操作都可能被重复触发，因此要保证操作的幂等性。

- 防止资源悬挂：网络异常导致事务的正向操作指令晚于补偿操作指令到达，则要丢弃本次正常操作，否则会出现资源悬挂问题。

虽然 Saga 和 TCC 都是补偿事务，但是由于提交阶段不同，所以两者也是有不同的：

- Saga 是不完美补偿，补偿操作会留下之前原始事务操作的痕迹，需要考虑对业务上的影响。

- TCC 是完美补偿，补偿操作会彻底清理之前的原始事务操作，用户是感知不到事务取消之前的状态信息的。

- TCC 的事务可以更好的支持异步化，但是 Saga 模式一般在补偿阶段比较适合异步化。

Saga 模式非常适合于业务流程长的长事务的场景，实现上对业务侵入低，所以非常适合微服务架构的场景。同时 Saga 采用的是一阶段提交模式，不会对资源长时间加锁，不存在“木桶效应”，所以采用这种模式架构的系统性能高、吞吐高。

阿里巴巴的 Seata 开源项目和华为的 ServiceComb 开源项目都支持 Saga 模式。

## 可靠消息

**无论是 2PC/3PC 还是 TCC、事务状态表，基本都遵守 XA 协议的思想**。即这些方案本质上都是事务协调者协调各个事务参与者的本地事务的进度，使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。

但是这些全局事务方案由于操作繁琐、时间跨度大，或者在全局事务期间会排他地锁住相关资源，使得整个分布式系统的全局事务的并发度不会太高。这很难满足电商等高并发场景对事务吞吐量的要求，因此互联网服务提供商探索出了很多与 XA 协议背道而驰的分布式事务解决方案。其中利用消息中间件实现的最终一致性全局事务就是一个经典方案。

### 1、本地消息表

本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。通过本地事务保证数据业务操作和消息的一致性，然后
通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。

1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
2. 之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则通过定时任务继续重新转发。
3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。依靠MQ的可靠性保证消息被成功消费。

![图片](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKmlWsfcSEzQjWsYvsVbyAog9GU5EJqmoLVlzH4D3lzhn4g2aYnfeK2icLvT1h3r5uFAVzb0FhEmsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 2、事务消息

Apache RocketMQ 在 4.3.0 版中已经支持分布式事务消息，RocketMQ 采用了 2PC 的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示，说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。

![img](https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_10.png)

- 发送消息（half消息）。

- 服务端响应消息写入结果。

- 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。

- 根据本地事务状态执行 Commit 或者 Rollback（Commit操作生成消息索引，消息对消费者可见）

### 3、消息事务特点

**ACID 支持**

- 原子性：最终可以实现分支事务都执行或者都不执行。
- 一致性：提供最终一致性。
- 隔离性：不保障隔离性。
- 持久性：由本地事务来保证。

**优点**

- 与tcc相比，实现方式较为简单，开发成本低。
- 是多个本地事务的结合，因此资源锁定周期短，性能好

**缺点**

- 依赖于MQ的可靠性

- 数据一致性完全依赖于消息服务，因此消息服务必须是可靠的。
- 需要处理被动业务方的幂等问题
- 消息发起者可以回滚，但是消息参与者无法引起事务回滚，被动业务失败不会导致主动业务的回滚，而是重试被动的业务
- 事务业务与消息发送业务耦合、业务数据与消息表要在一起

基于消息的分布式事务可以将分布式系统之间更有效的解耦，各个事务参与方之间的调用不再是同步调用。

对 MQ 系统的要求较高，对业务实现也有一定的侵入性，要么提供事务消息状态查询接口，要么需要维护本地消息表。并且原则上只接受下游分支事务的成功，不接受事务的回滚，如果失败就要一直重试，适用于对最终一致性敏感度较低的业务场景，例如跨企业的系统间的调用，适用的场景有限。

无法回滚的事务也叫事务？？针对事务无法回滚的问题，有人提出说可以再事务参与者执行失败后，再次利用MQ通知消息服务，然后由消息服务通知其他参与者回滚。那么，恭喜你，你利用MQ和自定义的消息服务再次实现了2PC 模型，又造了一个大轮子

## 最大努力通知

最大努力通知型的分布式事务解决方案，也是基于 MQ 系统的一种解决方案，但是不要求 MQ 消息可靠。发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。

- 有一定的消息重复通知机制：因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。
- 消息校对机制：如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。

示例

- 账户系统调用充值系统接口。
- 充值系统完成支付处理向账户系统发起充值结果通知，若通知失败，则充值系统按策略进行重复通知。
- 账户系统接收到充值结果通知修改充值状态。
- 账户系统未接收到通知会主动调用充值系统的接口查询充值结果。

特点

最大努力通知型方案本质是通过引入定期校验机制来对最终一致性做兜底，对业务侵入性较低、对 MQ 系统要求较低，实现比较简单，适合于对最终一致性敏感度比较低、业务链路较短的场景，比如跨平台、跨企业的系统间的业务交互。

## Seata 框架

### 1、介绍

Seata（Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架）是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、Saga 和 XA 事务模式，为用户打造一站式的分布式解决方案。

如下图所示，Seata 中有三大模块，分别是 TM、RM 和 TC。 其中 TM 和 RM 是作为 Seata 的客户端与业务系统集成在一起，TC 作为 Seata 的服务端独立部署。

- **TC：**事务协调者，维护全局和分支事务的状态，驱动全局事务提交或回滚。
- **TM：**事务管理器，定义全局事务的范围：开始全局事务、提交或回滚全局事务。
- **RM：**资源管理器，管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

![image-20200305225811888](https://gitee.com/bruceyum/pictures/raw/master/pics/image-20200305225811888.png)

在 Seata 中，分布式事务的执行流程：

- TM 开启分布式事务（TM 向 TC 注册全局事务记录）。
- 按业务场景，编排数据库、服务等事务内资源（RM 向 TC 汇报资源准备状态 ）。
- TM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交/回滚分布式事务）。
- TC 汇总事务信息，决定分布式事务是提交还是回滚。
- TC 通知所有 RM 提交/回滚资源，事务二阶段结束。



### 2、AT 模式

AT 模式是一种无侵入的分布式事务解决方案。在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。

- **一阶段：**业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
- **二阶段：**提交异步化，非常快速地完成。回滚通过一阶段的回滚日志进行反向补偿。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNm1boNZqZkc0iav2WdcCIspeib1DbrVKoN6tqhnJotPplWJtXVicHskCsDLnVeIa7ibpjib0fdLVPCPYrQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。

以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNm1boNZqZkc0iav2WdcCIspeFu6nr8Ie46XJOw7KUo1Q4BjniaeGAiceFgqgVQZibhhlLJHqFjzDP0zOQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 3、TCC 模式



![图片](https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNm1boNZqZkc0iav2WdcCIspeMfWEHdxicwU6lPjnSJtybJlicGmg4US9VVG5ejamZY1wNdBQlxwqk2zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

一个分布式的全局事务，整体是两阶段提交的模型。全局事务是由若干分支事务组成的，分支事务要满足两阶段提交的模型要求，即需要每个分支事务都具备自己的：

- 一阶段 prepare 行为。
- 二阶段 commit 或 rollback 行为。

TCC 模式，不依赖于底层数据资源的事务支持：

- **一阶段 prepare 行为：**调用自定义的 prepare 逻辑。
- **二阶段 commit 行为：**调用自定义的 commit 逻辑。
- **二阶段 rollback 行为：**调用自定义的 rollback 逻辑。

所谓 TCC 模式，是指支持把 自定义 的分支事务纳入到全局事务的管理中。

### 4、Saga 模式

目前 Seata 提供的 Saga 模式是基于状态机引擎来实现的，机制是：

- 通过状态图来定义服务调用的流程并生成 json 状态语言定义文件。
- 状态图中一个节点可以是调用一个服务，节点可以配置它的补偿节点。
- 状态图 json 由状态机引擎驱动执行，当出现异常时状态引擎反向执行已成功节点对应的补偿节点将事务回滚 （异常发生时是否进行补偿也可由用户自定义决定）。
- 可以实现服务编排需求，支持单项选择、并发、子流程、参数转换、参数映射、服务执行状态判断、异常捕获等功能。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNm1boNZqZkc0iav2WdcCIspe0ribTVKmmdxupvZyHBdJUDgH3Vj8PEfoic6w5WXuGqquHPzhsZlS5X4g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

状态机引擎原理：

- 图中的状态图是先执行 stateA，再执行 stateB，然后执行 stateC。
- "状态"的执行是基于事件驱动的模型，stateA 执行完成后，会产生路由消息放入 EventQueue，事件消费端从 EventQueue 取出消息，执行 stateB。
- 在整个状态机启动时会调用 Seata Server 开启分布式事务，并生产 xid，然后记录"状态机实例"启动事件到本地数据库。
- 当执行到一个"状态"时会调用 Seata Server 注册分支事务，并生产 branchId，然后记录"状态实例"开始执行事件到本地数据库。
- 当一个"状态"执行完成后会记录"状态实例"执行结束事件到本地数据库，然后调用 Seata Server 上报分支事务的状态。
- 当整个状态机执行完成, 会记录"状态机实例"执行完成事件到本地数据库，然后调用 Seata Server 提交或回滚分布式事务。



参考文档：

[分布式事务原理](https://mp.weixin.qq.com/s/7gfmnXQRRim0OCIRC0tQ5w)
[如何选择分布式事务解决方案？](https://mp.weixin.qq.com/s/2AL3uJ5BG2X3Y2Vxg0XqnQ)
[Seata 官方文档](http://seata.io/zh-cn/docs/overview/what-is-seata.html)

